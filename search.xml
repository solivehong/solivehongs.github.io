<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MSI算法</title>
    <url>/2020/05/11/2020-05-11-MSI%E7%AE%97%E6%B3%95-msisensor%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="MSI"><a href="#MSI" class="headerlink" title="MSI"></a>MSI</h1><h2 id="msisensor-计算msi原理"><a href="#msisensor-计算msi原理" class="headerlink" title="msisensor 计算msi原理"></a>msisensor 计算msi原理</h2><p> MSI突变中重复至少5次的1-5个碱基的序列。<br> 然后，使用MSIsensor msi命令，<br> 通过使用卡方检验比较肿瘤和正常样品之间的读取长度分布来估计每个微卫星位点<br> （具有≥20个映射读数）和每个肿瘤/正常组织对的突变状态。<br> P从MSIsensor输出中提取每个微卫星的值并用于定义微卫星突变状态<br> （如果P &lt;.05，则认为微卫星是突变的）<br> msisensor-dis文件中标记详细信息<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T0000110000</span><br><span class="line">N0000110000</span><br></pre></td></tr></table></figure><br> T=1,1<br> N=1,1<br>msi 计算每条reads 的 重复数量<br>对比T/N    (T-N)^2/N =X^2  得出 卡方值，结果对应表得出Pvalue<br>直接用python scipy包计算就可以</p>
]]></content>
      <tags>
        <tag>生信算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Strand bias 链偏好</title>
    <url>/2020/05/11/2020-05-11-Strand%20bias%20%E9%93%BE%E5%81%8F%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="Strand-bias-链偏好"><a href="#Strand-bias-链偏好" class="headerlink" title="Strand bias 链偏好"></a>Strand bias 链偏好</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="https://upload-images.jianshu.io/upload_images/15500891-64fe39367e89e6bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GATK.png"></p>
<h3 id="造成链偏好的原因："><a href="#造成链偏好的原因：" class="headerlink" title="造成链偏好的原因："></a>造成链偏好的原因：</h3><p>1.Local realignment<br>目的就是将比对到indel附近的reads进行局部重新比对，将比对的错误率降到最低。一般来说，绝大部分需要进行重新比对的基因组区域，都是因为插入/缺失的存在，因为在indel附近的比对会出现大量的碱基错配，这些碱基的错配很容易被误认为SNP。还有，在比对过程中，比对算法对于每一条read的处理都是独立的，不可能同时把多条reads与参考基因组比对来排错。因此，即使有一些reads能够正确的比对到indel，但那些恰恰比对到indel开始或者结束位置的read也会有很高的比对错误率，这都是需要重新比对的。Local realignment就是将由indel导致错配的区域进行重新比对，将indel附近的比对错误率降到最低。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-34bd5e2375fb8fb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GATK-realignment.png"></p>
<p>2.BAQ（gatk BQSR）<br>对bam文件里reads的碱基质量值进行重新校正，使最后输出的bam文件中reads中碱基的质量值能够更加接近真实的与参考基因组之间错配的概率<br>在reads碱基质量值被校正之前，我们要保留质量值在Q25以上的碱基，但是实际上质量值在Q25的这些碱基的错误率在1%，也就是说质量值只有Q20，这样就会对后续的变异检测的可信度造成影响。还有，在边合成边测序的测序过程中，在reads末端碱基的错误率往往要比起始部位更高。另外，AC的质量值往往要低于TG。BQSR的就是要对这些质量值进行校正。</p>
<p>当两者同时出现的时候，就会产生大量的链偏好性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chr	Pos		Depth	a1	b2	c3	d4	Forward Strand Genotype	Reverse Strand Genotype</span><br><span class="line">6	32975014	21	5	5	10	1	Heterzygous		Homozygous</span><br><span class="line">1	81967962	38	20	11	7	0	Heterzygous		Homozygous</span><br><span class="line">12	10215654	31	15	9	7	0	Heterzygous		Homozygous</span><br><span class="line">1. Forward strand reference allele.</span><br><span class="line">2. Forward strand non reference allele.</span><br><span class="line">3. Reverse strand reference allele.</span><br><span class="line">4. Reverse strand non reference allele.</span><br></pre></td></tr></table></figure>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="SB算法"><a href="#SB算法" class="headerlink" title="SB算法"></a>SB算法</h4><p><img src="https://upload-images.jianshu.io/upload_images/15500891-2ca4f246e643975f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SB.png"></p>
<h4 id="gatk-SB"><a href="#gatk-SB" class="headerlink" title="gatk-SB"></a>gatk-SB</h4><p><img src="https://upload-images.jianshu.io/upload_images/15500891-78517a29149056c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GATK-SB.png"></p>
<h4 id="fisher检验算法范围（0-1）"><a href="#fisher检验算法范围（0-1）" class="headerlink" title="fisher检验算法范围（0-1）"></a>fisher检验算法范围（0-1）</h4><p><img src="https://upload-images.jianshu.io/upload_images/15500891-9edbc217e261bb10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FISHER.png"></p>
<p>Pvalue=1-p</p>
<h4 id="三者结果越大越好"><a href="#三者结果越大越好" class="headerlink" title="三者结果越大越好"></a>三者结果越大越好</h4>]]></content>
      <tags>
        <tag>生信算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-入门教程</title>
    <url>/2020/05/19/2020-05-19-SQ-Navicat%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="创建数据库文件"><a href="#创建数据库文件" class="headerlink" title="创建数据库文件"></a>创建数据库文件</h3><p>文件-新建连接-sqllite-新建sqllite3-数据库文件-选择存放位置</p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>下载文件<br>这是数据分析师的excel实战数据的下载地址：</p>
<p><a href="https://pan.baidu.com/s/1eUjcGaI">https://pan.baidu.com/s/1eUjcGaI</a></p>
<p>提取密码：g5xa</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-9477d45a1c797271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择编码<br>gb2312-windows电脑数据文件<br>utf-8 linux电脑数据文件<br><img src="https://upload-images.jianshu.io/upload_images/15500891-18381028b0550186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15500891-1e4dfaf953a55fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15500891-75844065213089f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="table是表名，column是我们想要查询的字段／列，column可以用-代替，指代全部字段，意为从table表查询所有数据。"><a href="#table是表名，column是我们想要查询的字段／列，column可以用-代替，指代全部字段，意为从table表查询所有数据。" class="headerlink" title="table是表名，column是我们想要查询的字段／列，column可以用 * 代替，指代全部字段，意为从table表查询所有数据。"></a>table是表名，column是我们想要查询的字段／列，column可以用 * 代替，指代全部字段，意为从table表查询所有数据。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column from table</span><br></pre></td></tr></table></figure>
<h3 id="where-是基础查询语法，用于条件判断。"><a href="#where-是基础查询语法，用于条件判断。" class="headerlink" title="where 是基础查询语法，用于条件判断。"></a>where 是基础查询语法，用于条件判断。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where city = &#x27;上海&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="上图是最简化的查询语句，将所有城市为上海的职位数据过滤出来。我们也可以用-and-进行多条件判断。"><a href="#上图是最简化的查询语句，将所有城市为上海的职位数据过滤出来。我们也可以用-and-进行多条件判断。" class="headerlink" title="上图是最简化的查询语句，将所有城市为上海的职位数据过滤出来。我们也可以用 and 进行多条件判断。"></a>上图是最简化的查询语句，将所有城市为上海的职位数据过滤出来。我们也可以用 and 进行多条件判断。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where city = &#x27;上海&#x27; and positionName = &#x27;数据分析师&#x27;</span><br></pre></td></tr></table></figure>
<p>当我们涉及到非常复杂的与或逻辑判断，应该怎么办？比如即满足条件AB，又要满足条件C，或者是满足条件DE。此时需要用括号明确逻辑判断的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line"></span><br><span class="line">where (city = &#x27;上海&#x27; and positionName = &#x27;数据分析师&#x27;) or (city = &#x27;北京&#x27; and positionName = &#x27;数据产品经理&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="接下来的问题来了，当我们要查询多个条件，比如北京上海广州深圳南京这些城市，难道一个个用and关联起来？这太麻烦了，我们可以使用-in-。"><a href="#接下来的问题来了，当我们要查询多个条件，比如北京上海广州深圳南京这些城市，难道一个个用and关联起来？这太麻烦了，我们可以使用-in-。" class="headerlink" title="接下来的问题来了，当我们要查询多个条件，比如北京上海广州深圳南京这些城市，难道一个个用and关联起来？这太麻烦了，我们可以使用 in 。"></a>接下来的问题来了，当我们要查询多个条件，比如北京上海广州深圳南京这些城市，难道一个个用and关联起来？这太麻烦了，我们可以使用 in 。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where city in (&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;广州&#x27;,&#x27;深圳&#x27;,&#x27;南京&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="当我们遇到字段数据类型是数值时，也可以使用符号-gt-、-gt-、-lt-、-lt-、-进行逻辑判断，-指的是不等于，等价于-lt-gt-。"><a href="#当我们遇到字段数据类型是数值时，也可以使用符号-gt-、-gt-、-lt-、-lt-、-进行逻辑判断，-指的是不等于，等价于-lt-gt-。" class="headerlink" title="当我们遇到字段数据类型是数值时，也可以使用符号&gt; 、&gt;=、&lt; 、&lt;=、!= 进行逻辑判断，!= 指的是不等于，等价于 &lt;&gt; 。"></a>当我们遇到字段数据类型是数值时，也可以使用符号&gt; 、&gt;=、&lt; 、&lt;=、!= 进行逻辑判断，!= 指的是不等于，等价于 &lt;&gt; 。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where companyId &gt;= 10000</span><br></pre></td></tr></table></figure>
<h3 id="当我们需要取区间数值时，使用-between-and"><a href="#当我们需要取区间数值时，使用-between-and" class="headerlink" title="当我们需要取区间数值时，使用 between and"></a>当我们需要取区间数值时，使用 between and</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where companyId between 10000 and 20000</span><br></pre></td></tr></table></figure>
<p>between and 包括数值两端的边界，等同于 companyId &gt;=10000 and companyId &lt;= 20000。</p>
<h3 id="如果要模糊查找，能用like。"><a href="#如果要模糊查找，能用like。" class="headerlink" title="如果要模糊查找，能用like。"></a>如果要模糊查找，能用like。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">where positionName like &#x27;%数据分析%&#x27;</span><br></pre></td></tr></table></figure>
<p>语句的含义是在positionName列查找包含「数据分析」字段的数据，%代表的是通配符，含义是无所谓「数据分析」前面后面是什么内容。如果是 ‘数据分析%’ ，则代表字段必须以数据分析开头，无所谓后面是什么。</p>
<h3 id="group-by，它是数据分析中常见的语法，目的是将数据按组／维度划分。类似于Excel中的数据透视表，我们以city为例。"><a href="#group-by，它是数据分析中常见的语法，目的是将数据按组／维度划分。类似于Excel中的数据透视表，我们以city为例。" class="headerlink" title="group by，它是数据分析中常见的语法，目的是将数据按组／维度划分。类似于Excel中的数据透视表，我们以city为例。"></a>group by，它是数据分析中常见的语法，目的是将数据按组／维度划分。类似于Excel中的数据透视表，我们以city为例。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from DataAnalyst</span><br><span class="line">group by city</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-f5211522cf114a2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="它将城市划分成几组，通过group-by-可以快速的浏览数据有哪些城市。我们看一下它的高阶用法。"><a href="#它将城市划分成几组，通过group-by-可以快速的浏览数据有哪些城市。我们看一下它的高阶用法。" class="headerlink" title="它将城市划分成几组，通过group by 可以快速的浏览数据有哪些城市。我们看一下它的高阶用法。"></a>它将城市划分成几组，通过group by 可以快速的浏览数据有哪些城市。我们看一下它的高阶用法。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city,count(1) from DataAnalyst</span><br><span class="line">group by city</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-4b6f33ead3832b98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="上述语句，使用count函数，统计计数了每个城市拥有的职位数量。括号里面的1代表以第一列为计数标准。这里出现新的问题，当我们遇到重复数据怎么办？在DataAnalyst-这张表中，北京职位包含重复的职位ID，我们需要去重。"><a href="#上述语句，使用count函数，统计计数了每个城市拥有的职位数量。括号里面的1代表以第一列为计数标准。这里出现新的问题，当我们遇到重复数据怎么办？在DataAnalyst-这张表中，北京职位包含重复的职位ID，我们需要去重。" class="headerlink" title="上述语句，使用count函数，统计计数了每个城市拥有的职位数量。括号里面的1代表以第一列为计数标准。这里出现新的问题，当我们遇到重复数据怎么办？在DataAnalyst 这张表中，北京职位包含重复的职位ID，我们需要去重。"></a>上述语句，使用count函数，统计计数了每个城市拥有的职位数量。括号里面的1代表以第一列为计数标准。这里出现新的问题，当我们遇到重复数据怎么办？在DataAnalyst 这张表中，北京职位包含重复的职位ID，我们需要去重。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city,count(distinct positionId) from DataAnalyst</span><br><span class="line">group by city</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-557d1ffbae282827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>北京的数据一下子少了2000，多余的重复值被排除在外。distinct 是去重函数，distinct positionId 会只计算唯一的positionId个数。日常工作中，活跃用户数、文章UV，都是用distinct 计算获得，这是唯一标示符ID的重要作用。</p>
<h3 id="除了count，还有max，min，sum，avg等函数，也叫做聚合函数。用法和Excel没什么区别。"><a href="#除了count，还有max，min，sum，avg等函数，也叫做聚合函数。用法和Excel没什么区别。" class="headerlink" title="除了count，还有max，min，sum，avg等函数，也叫做聚合函数。用法和Excel没什么区别。"></a>除了count，还有max，min，sum，avg等函数，也叫做聚合函数。用法和Excel没什么区别。</h3><p>当我们在group by 添加多个字段，它将以多维的形式进行数据聚合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city,workYear,count(distinct positionId) from DataAnalyst</span><br><span class="line">group by city,workYear</span><br></pre></td></tr></table></figure>
<h3 id="接下来是新的问题，如果我想找出各个城市，数据分析师岗位数量在500以上的城市有哪些，应该怎么计算？有两种方法，第一种，是使用having语句，它对聚合后的数据结果进行过滤。"><a href="#接下来是新的问题，如果我想找出各个城市，数据分析师岗位数量在500以上的城市有哪些，应该怎么计算？有两种方法，第一种，是使用having语句，它对聚合后的数据结果进行过滤。" class="headerlink" title="接下来是新的问题，如果我想找出各个城市，数据分析师岗位数量在500以上的城市有哪些，应该怎么计算？有两种方法，第一种，是使用having语句，它对聚合后的数据结果进行过滤。"></a>接下来是新的问题，如果我想找出各个城市，数据分析师岗位数量在500以上的城市有哪些，应该怎么计算？有两种方法，第一种，是使用having语句，它对聚合后的数据结果进行过滤。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city,count(distinct positionId) from DataAnalyst</span><br><span class="line">group by city having count(distinct positionId) &gt;= 500</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-cf19ee6749a57169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>第二种，是利用嵌套子查询。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-8e5a53f2a0f6f841.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们将第一次查询获得的城市职位数的结果，看作一张新的表，利用as 将它命名为t1( table1 的简写)，将职位数命名为一个新的字段counts。然后外面再套一层select 过滤出counts &gt;=500。</p>
<p>这种查询方式就叫嵌套子查询，使用场景比较广泛，where 后面也能跟子查询。</p>
<p>很多时候，数据是凌乱的，我们希望结果能够呈现一定的顺序，这时候就用到order by语句。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city,count(distinct positionId) as counts from DataAnalyst</span><br><span class="line">group by city</span><br><span class="line">order by counts</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>T检验-计算TMB两种方式差异</title>
    <url>/2020/06/06/2020-06-06-T%E6%A3%80%E9%AA%8C-%E8%AE%A1%E7%AE%97TMB%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<h2 id="TMB去除同意突变与非同义突变的差异"><a href="#TMB去除同意突变与非同义突变的差异" class="headerlink" title="TMB去除同意突变与非同义突变的差异"></a>TMB去除同意突变与非同义突变的差异</h2><p>取样一组样本去重并且去除不合格样本后剩余427例样本<br>其中同意第一种使用非同义突变计算</p>
<p>数据取一个header，看看先<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjjc5u6j6j308r04374s.jpg" alt=""></p>
<p>第二种使用同意突变计算，计算的相关性很好<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjjcyo2ylj30k00860tr.jpg" alt=""><br>做一个T检验<br>先看看是不是正态<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjjdcm3vzj30yg0momzf.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjjdrzw64j305r023q2x.jpg" alt=""><br>统计TMB的结果高于cutoff与低于cutoff数量</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjje2m648j30bi04c0sq.jpg" alt=""><br>结果Pvalue=1表示两个样本的均值相同<br>证明去除同义突变对结果是无影响的</p>
]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>T检验、F检验、卡方检验详细分析及应用场景总结</title>
    <url>/2020/06/06/2020-06-06-T%E6%A3%80%E9%AA%8C%E3%80%81F%E6%A3%80%E9%AA%8C%E3%80%81%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、T检验"><a href="#一、T检验" class="headerlink" title="一、T检验"></a>一、T检验</h1><h3 id="（一）什么是T检验"><a href="#（一）什么是T检验" class="headerlink" title="（一）什么是T检验"></a>（一）什么是T检验</h3><p>T检验是一种适合小样本的统计分析方法，通过比较不同数据的均值，研究两组数据是否存在差异。</p>
<h3 id="（二）T检验有什么用"><a href="#（二）T检验有什么用" class="headerlink" title="（二）T检验有什么用"></a>（二）T检验有什么用</h3><p>1.单样本T检验<br>用于比较一组数据与一个特定数值之间的差异情况。</p>
<p>2.配对样本的T检验<br>用于检验有一定对应关系的样本之间的差异情况，需要两组样本数相等。<br>常见的使用场景有：</p>
<p>①同一对象处理前后的对比（同一组人员采用同一种减肥方法前后的效果对比）；</p>
<p>②同一对象采用两种方法检验的结果的对比（同一组人员分别服用两种减肥药后的效果对比）；</p>
<p>③配对的两个对象分别接受两种处理后的结果对比（两组人员，按照体重进行配对，服用不同的减肥药，对比服药后的两组人员的体重）。</p>
<p>3.独立样本的T检验<br>独立样本与配对样本的不同之处在于独立样本T检验两组数据的样本个数可以不等。</p>
<h3 id="（三）T检验怎么用"><a href="#（三）T检验怎么用" class="headerlink" title="（三）T检验怎么用"></a>（三）T检验怎么用</h3><p>1.首先要明确检验的目的，是单样本T检验、配对样本的T检验还是独立样本的T检验。</p>
<p>2.进行正态性检验，独立样本需要进行方差齐性检验</p>
<p>3.选择合适的检验方法进行检验</p>
<h3 id="（四）T检验注意事项"><a href="#（四）T检验注意事项" class="headerlink" title="（四）T检验注意事项"></a>（四）T检验注意事项</h3><p>1.无论哪种T检验、都要数据服从正态或者近似正态分布。正态性的检验方法有：正态图、正态性检验、P-P图/Q-Q图等。</p>
<p>2.独立样本的T检验，除了要满足正态性，还需要满足方差齐性的前提条件。在方差齐性的情况下才可以使用T检验，如果方差不齐性，则应采用校正T检验。</p>
<h1 id="二、F检验"><a href="#二、F检验" class="headerlink" title="二、F检验"></a>二、F检验</h1><h3 id="（一）什么是F检验"><a href="#（一）什么是F检验" class="headerlink" title="（一）什么是F检验"></a>（一）什么是F检验</h3><p>方差分析就是对试验数据进行分析，检验方差相等的多个正态总体均值是否相等，进而判断各因素对试验指标的影响是否显著。其原理认为不同处理组的均数间的差别基本来源有两个：实验条件和随机误差。其思想为通过分析研究不同来源的变异对总变异的贡献大小，从而确定可控因素对研究结果影响力的大小。</p>
<h3 id="（二）F检验有什么用"><a href="#（二）F检验有什么用" class="headerlink" title="（二）F检验有什么用"></a>（二）F检验有什么用</h3><p>1.单因素方差分析</p>
<p>适用于问卷数据和实验数据，实验中只有一个因素改变的样本。判断该因素对样本的影响因素是否显著。</p>
<p>2.双因素方差分析</p>
<p>适用于实验数据，实验中有两个因素改变的样本。</p>
<p>3.多因素方差分析</p>
<p>适用于实验数据，实验中有多个因素改变的样本。</p>
<h3 id="（三）F检验怎么用"><a href="#（三）F检验怎么用" class="headerlink" title="（三）F检验怎么用"></a>（三）F检验怎么用</h3><p>1.判断数据类型</p>
<p>定性数据用卡方检验， t检验一般用来比较两个总体的均值是否相同，而单因素方差分析可用于比较多个总体的均值是否相同。</p>
<p>2.确定方差分析的类型<br>确定实验过程中有几种因素发生了改变，如只有一组，则选择单因素方差分析；如有两组，则选择双因素方差分析；如有多组，则选择多因素方差分析。</p>
<p>3.正态性检验</p>
<p>4.方差齐性检验</p>
<p>5.选择合适的方法进行检验</p>
<p>6.事后多重比较<br>单因素方差分析如果呈现出显著性，说明不同组别之间确实存在显著的差异，事后多重比较可以得出出两组间显著差异的大小。</p>
<h3 id="（四）F检验注意事项"><a href="#（四）F检验注意事项" class="headerlink" title="（四）F检验注意事项"></a>（四）F检验注意事项</h3><p>1.方差分析用来分析定量数据的变化情况，可以比较2组或多组数据的差异。</p>
<p>2.方差分析要求样本满足正态分布</p>
<p>3.方差分析的前提是方差齐性</p>
<h1 id="三、卡方检验"><a href="#三、卡方检验" class="headerlink" title="三、卡方检验"></a>三、卡方检验</h1><h3 id="（一）什么是卡方检验"><a href="#（一）什么是卡方检验" class="headerlink" title="（一）什么是卡方检验"></a>（一）什么是卡方检验</h3><p>卡方检验是一种用途广泛的分析定性数据差异性的方法。是一种通过频数进行检验的方法。</p>
<h3 id="（二）卡方检验有什么用"><a href="#（二）卡方检验有什么用" class="headerlink" title="（二）卡方检验有什么用"></a>（二）卡方检验有什么用</h3><p>1.卡方优度检验<br>对一列数据进行统计检验，分析单个分类变量实际观测的比例与期望的比例是否一致。</p>
<p>2.交叉表卡方<br>研究两组分类变量的关系：如性别与看不看直播是否有关系。</p>
<p>3.配对卡方<br>研究实验过程中，用不同方法检测同一批人，看两个方法的效果是否有显著差异。</p>
<h3 id="（三）卡方检验怎么用"><a href="#（三）卡方检验怎么用" class="headerlink" title="（三）卡方检验怎么用"></a>（三）卡方检验怎么用</h3><p>1.确定卡方检验的类型</p>
<p>2.选用合适的方法进行卡方检验</p>
<h3 id="（四）卡方检验注意事项"><a href="#（四）卡方检验注意事项" class="headerlink" title="（四）卡方检验注意事项"></a>（四）卡方检验注意事项</h3><p>1.需要随机样本数据</p>
<p>2.理论频数不能太小</p>
]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动基因</title>
    <url>/2020/06/06/2020-06-06-%E9%A9%B1%E5%8A%A8%E5%9F%BA%E5%9B%A0%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>肿瘤基因组学目前面临的挑战之一是将肿瘤形成过程中所涉及的基因组变化（即驱动因素）与对癌细胞没有任何益处的基因组区分开来。癌症形成的过程中驱动基因（即那些带有驱动因子变化的基因）给予肿瘤形成过程自然选择的优势，因此可以通过检测肿瘤中的阳性信号来鉴定驱动基因。<br>       为了找到驱动基因，研究者们开发出一系列的肿瘤驱动基因软件和整理了很多数据库。现在简单地介绍下这几个软件</p>
<h2 id="驱动预测软件"><a href="#驱动预测软件" class="headerlink" title="驱动预测软件"></a>驱动预测软件</h2><p>目前这些预测软件使用的方法可以分为三大类：基于基因功能算法、基于突变聚类方法、基于频率的算法。</p>
<h2 id="1-基于频率的算法："><a href="#1-基于频率的算法：" class="headerlink" title="1.基于频率的算法："></a>1.基于频率的算法：</h2><p>基于癌症驱动基因比其他基因的突变频率较高这一原理，使用统计算法计算出高频突变频率高于背景突变频率的基因为癌症驱动基因，这类方法在现有报道中较为常用。</p>
<h2 id="2-基于突变聚类的方法："><a href="#2-基于突变聚类的方法：" class="headerlink" title="2.基于突变聚类的方法："></a>2.基于突变聚类的方法：</h2><p>通过检测基因间显着聚集在氨基酸序列特定区域的突变的基因，发现可能的驱动基因。</p>
<h2 id="3-基于基因功能的算法："><a href="#3-基于基因功能的算法：" class="headerlink" title="3.基于基因功能的算法："></a>3.基于基因功能的算法：</h2><p>根据突变基因对应的蛋白信息构建基因突变有害性的评价模型，最终将有害性较高的基因认定为驱动基因。<br><img src="https://upload-images.jianshu.io/upload_images/15500891-f1f0d5e0df3ed180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="主要原理介绍"><a href="#主要原理介绍" class="headerlink" title="主要原理介绍"></a>主要原理介绍</h2><p>其中MutSigCV考虑了肿瘤异质性，寻找相对于背景突变的高频突变。MutSigCV根据突变信息建立一个突变背景模型，根据模型判断每个基因的突变是否比偶然突变更显著。</p>
<p>下图左侧显示了一组染色体，每个染色体来自不同癌症患者的肿瘤。基因分别为彩色条带，并且体细胞突变由红色三角形表示。如图所示，所有肿瘤的突变可以通过折叠聚集在一起，并且可以计算每个基因的突变总数。然后将此计数转换为分数，最后根据前期构建的突变背景模型计算其显著性。之后通过阈值来控制假阳性率（FDR），并且超过该阈值的基因为阳性突变。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15500891-2a00d079e368e53c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>驱动基因预测的主流方式是寻找高频突变基因（SMG），但是也有局限性，OncodriveCLUST是基于蛋白编码破坏程度的预测方式，是驱动基因检测的补充。OncodriveCLUST分析软件利用驱动突变在位点分布上具有形成突变簇的偏好性以及利用同义突变无偏分布的特点构建背景突变模型，寻找可能的驱动突变。具体算法如下：<br><img src="https://upload-images.jianshu.io/upload_images/15500891-340de7fb70deea00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>i表示簇内的蛋白质位置，fractionMutations是落在该位置的突变的百分比，dist是跨越i的氨基酸的数量。以及具有最大突变数的簇的位置，通过对所有簇的得分求和来获得基因聚类得分。最后，通过将其与计算编码 - 沉默突变的所有基因聚类得分获得的背景模型分布进行比较，来估计观察到的基因聚类得分的显着性。<br><img src="https://upload-images.jianshu.io/upload_images/15500891-36c906a8acc548a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> OncodriveFM(functional mutation)是根据功能突变有害性进行预测，即如果基因发生了影响功能域的突变，则该基因可以作为候选的驱动基因，并且有研究结果也表明高频突变和已知的驱动基因具有较为明确的FM (功能突变)偏好性。具体方法为：<br>如上图所示：第一步包括计算一组患者中鉴定的突变的FI评分，接下来，Oncodrive-fm评估每个基因是否存在对具有高FI（FM偏差）的突变，结果得到P - 每个基因的值。同时Oncodrive-fm也可用于评估基因model的FM偏差<br>基于TCGA数据使用三种方法的对比<br>分别使用OncodriveFM（功能影响标准），OncodriveCLUST（突变聚类标准）和MutSig（突变频率标准）描绘在CGC数据库中注释的基因，白色Not assessable表示无法计算功能影响的基因（OncodriveFM）或无突变簇的基因（OncodriveCLUST）<br><img src="https://upload-images.jianshu.io/upload_images/15500891-a9a2dc98d18ed0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从比较的结果看出，OncodriveCLUST、MutSig、OncodriveFM可以互相发现一些其他检测方法忽略的基因，因此在检测肿瘤的驱动基因时建议使用基于不同原理的软件综合检测。</p>
<p>参考文献<br>Dees N D, Zhang Q, Kandoth C, et al. MuSiC: identifying mutational significance in cancer genomes[J]. Genome research, 2012, 22(8): 1589-1598.<br>Tamborero D, Gonzalez-Perez A, Lopez-Bigas N. OncodriveCLUST: exploiting the positional clustering of somatic mutations to identify cancer genes[J]. Bioinformatics, 2013, 29(18): 2238-2244.<br>Mularoni, Loris, et al. “OncodriveFML: a general framework to identify coding and non-coding regions with cancer driver mutations.” Genome biology 17.1 (2016): 128.</p>
]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>生信培训手册</title>
    <url>/2020/07/13/2020-07-13-%E7%94%9F%E4%BF%A1%E5%9F%B9%E8%AE%AD%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>数据库下载<br>软件安装</p>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#yum install gcc-gfortran              #否则报”configure: error: No F77 compiler found”错误</span><br><span class="line"></span><br><span class="line">#yum install gcc gcc-c++              #否则报”configure: error: C++ preprocessor “/lib/cpp” fails sanity check”错误</span><br><span class="line"></span><br><span class="line">#yum install readline-devel          #否则报”–with-readline=yes (default) and headers/libs are not available”错误</span><br><span class="line"></span><br><span class="line">#yum install libXt-devel                 #否则报”configure: error: –with-x=yes (default) and X11 headers/libs are not available”错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后下载源代码,编译</span><br><span class="line"></span><br><span class="line">yum install R </span><br><span class="line">yum install shiny</span><br><span class="line">wget https://download3.rstudio.org/centos6.3/x86_64/shiny-server-1.5.14.948-x86_64.rpm</span><br><span class="line">sudo yum install --nogpgcheck shiny-server-1.5.14.948-x86_64.rpm</span><br><span class="line">即可完成编译安装。</span><br></pre></td></tr></table></figure>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="1-入门linux"><a href="#1-入门linux" class="headerlink" title="1.入门linux"></a>1.入门linux</h1><pre><code>第1阶段：把linux系统玩得跟Windows或者MacOS那样的桌面操作系统一样顺畅，主要目的就是去可视化，熟悉黑白命令行界面，可以仅仅以键盘交互模式完成常规文件夹及文件管理工作。
第2阶段：做到文本文件的表格化处理，类似于以键盘交互模式完成Excel表格的排序、计数、筛选、去冗余，查找，切割，替换，合并，补齐，熟练掌握awk,sed,grep这文本处理的技巧
第3阶段：元字符，通配符及shell中的各种扩展
第4阶段：高级目录管理：软硬链接，绝对路径和相对路径，环境变量
第5阶段：任务提交及批处理，
第6阶段：软件安装及conda管理
</code></pre><h2 id="1-常规文件夹及文件管理工作"><a href="#1-常规文件夹及文件管理工作" class="headerlink" title="1.常规文件夹及文件管理工作"></a>1.常规文件夹及文件管理工作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls ## list 列出当前路径下信息</span><br><span class="line">pwd ## print working directory 打印工作目录，即当前所在目录</span><br><span class="line">cd ## change directory 切换目录</span><br><span class="line">mkdir ## make directory建立一个新的目录</span><br><span class="line">touch ## 创建文本</span><br><span class="line">mv ## Move 更改文件或目录，移动目录或文件</span><br><span class="line">rm ## ReMove 删除目录或文件</span><br><span class="line">cp ## copy and paste 将给出的文件或目录复制到另一个文件或目录中 tar ## Tape archive 解压文件</span><br><span class="line">ln ## LINk 链接文件</span><br></pre></td></tr></table></figure>
<h2 id="2-文本文件处理"><a href="#2-文本文件处理" class="headerlink" title="2.文本文件处理"></a>2.文本文件处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head # 功能:显示文档的开头至标准输出中，默认显示十行。</span><br><span class="line">tail # 功能:显示文档的末尾至标准输出中，默认显示十行。</span><br><span class="line">less  # 功能:逐页查看文档内容。</span><br><span class="line">more # 也是逐页查看文档内容，跟less类似</span><br><span class="line">cat # cat 命令 (concatenate) 查看文本，输出到屏幕</span><br></pre></td></tr></table></figure>
<h1 id="R-1"><a href="#R-1" class="headerlink" title="R"></a>R</h1><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装</span><br><span class="line">Rstudio windows 可以直接在官网下载</span><br><span class="line"></span><br><span class="line"># 基础</span><br></pre></td></tr></table></figure>
<h2 id="1-介绍R语言及Rstudio"><a href="#1-介绍R语言及Rstudio" class="headerlink" title="1. 介绍R语言及Rstudio"></a>1. 介绍R语言及Rstudio</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">了解R，Rstudio及R包</span><br><span class="line"></span><br><span class="line">安装的包在packages中检查</span><br><span class="line"></span><br><span class="line">.libPaths()  #找安装路径</span><br><span class="line"></span><br><span class="line">帮助文档，帮忙看路径</span><br><span class="line"></span><br><span class="line">?substring</span><br><span class="line"></span><br><span class="line">学会代码所蕴含的含义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; tmp=&#x27;abcde&#x27;</span><br><span class="line">&gt; tmp</span><br><span class="line">[1] &quot;abcde&quot;</span><br><span class="line">&gt; substring(tmp,1,3)</span><br><span class="line">[1] &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">定位文件、设置文件位置</span><br><span class="line"></span><br><span class="line">getwd()</span><br><span class="line">setwd()  </span><br><span class="line"></span><br><span class="line">History- to console, to source </span><br><span class="line"></span><br><span class="line">环境变量：赋值后会被记录</span><br><span class="line"></span><br><span class="line">plot画图，如果没有出现所画的图形，要关掉之前开的窗口，再画图</span><br><span class="line"></span><br><span class="line">plot(1:10)</span><br><span class="line">png(&#x27;tmp.png&#x27;)</span><br><span class="line">dev.off()</span><br><span class="line">plot(1:10)</span><br><span class="line"></span><br><span class="line">下载R语言软件</span><br><span class="line"></span><br><span class="line">下载Rstudio编辑器</span><br><span class="line"></span><br><span class="line">安装一些必要的包，了解CRAN和bioconductor, 了解镜像并设置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-R语言基础变量讲解"><a href="#2-R语言基础变量讲解" class="headerlink" title="2. R语言基础变量讲解"></a>2. R语言基础变量讲解</h2><p>1.使用源代码或者重用R包，报错是因为没有基础知识，即变量类型</p>
<p>2.看五本以上的R书</p>
<p>从无到有创建各种变量，掌握很多函数</p>
<p>理解索引</p>
<p>理解行列</p>
<p>理解取子集的两种方式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep()搜索函数</span><br><span class="line"></span><br><span class="line">index1 = grep(&#x27;RNA-Seq&#x27;, a$Assay_Type)</span><br><span class="line">index2 = grepl(&#x27;RNA-Seq&#x27;, a$Assay_Type)</span><br><span class="line">b = a[index1,]  # 下标</span><br><span class="line">b = a[index2,]  # 索引</span><br><span class="line"></span><br><span class="line">list取元素用双括号来取，不然只能取到子list</span><br><span class="line"></span><br><span class="line">向量型(Vector)</span><br><span class="line"></span><br><span class="line">&gt; a=c(1,2,3)</span><br><span class="line">&gt; a</span><br><span class="line">[1] 1 2 3</span><br><span class="line">&gt; class(a) # 数值类型不相容的时候查变量类型是否不符合函数类型</span><br><span class="line">[1] &quot;numeric&quot;</span><br><span class="line"></span><br><span class="line">双整型double</span><br><span class="line"></span><br><span class="line">整型integer</span><br><span class="line"></span><br><span class="line">字符型character</span><br><span class="line"></span><br><span class="line">逻辑型logical</span><br><span class="line"></span><br><span class="line">复数类型complex</span><br><span class="line"></span><br><span class="line">原始类型raw</span><br><span class="line"></span><br><span class="line">矩阵型(Matrix)和数组型(Array)</span><br><span class="line"></span><br><span class="line">数据框架型(Data Frame)及列表型(List)</span><br><span class="line"></span><br><span class="line">创建字符时，有字符有数值，创建的向量就全变成字符  #向量有优先级</span><br><span class="line"></span><br><span class="line">&gt; a=c(1,&#x27;b&#x27;,2)</span><br><span class="line">&gt; class(a)</span><br><span class="line">[1] &quot;character&quot;</span><br><span class="line"></span><br><span class="line">字符串要加引号，单双引号没啥区别。特殊情况下有区别，单双引号都在</span><br><span class="line">二维和多维</span><br><span class="line"></span><br><span class="line">每个元素可以用$符号取</span><br><span class="line"></span><br><span class="line">概括来说，R可以识别六种基本类型的原子型向量，可以具有名称属性或者维度属性</span><br><span class="line"></span><br><span class="line">用函数或者内置变量创造变量</span><br><span class="line"></span><br><span class="line">&gt; a=1:10</span><br><span class="line">&gt; a</span><br><span class="line">[1]  1  2  3  4  5  6  7  8  9 10</span><br><span class="line">&gt; a = seq(1:10)</span><br><span class="line">&gt; a</span><br><span class="line">[1]  1  2  3  4  5  6  7  8  9 10</span><br><span class="line">&gt; a = LETTERS</span><br><span class="line">&gt; a</span><br><span class="line">[1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot;</span><br><span class="line">[15] &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;</span><br><span class="line">&gt; a = LETTERS[1:10]</span><br><span class="line">&gt; a</span><br><span class="line">[1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot;</span><br><span class="line"></span><br><span class="line">五种变量结构（class属性）</span><br><span class="line"></span><br><span class="line">变量的类型判断及转换</span><br><span class="line"></span><br><span class="line">is. X</span><br><span class="line">as. X</span><br><span class="line"></span><br><span class="line">数据变量的各种操作</span><br><span class="line"></span><br><span class="line">a=data.frame(n=LETTERS[1:10],v=1:10)</span><br><span class="line"></span><br><span class="line">rownames(a)=paste0(&#x27;row&#x27;,1:10)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="3-外部数据导入导出"><a href="#3-外部数据导入导出" class="headerlink" title="3. 外部数据导入导出"></a>3. 外部数据导入导出</h2><p>Excel表格到R语言转换<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = read.table(&#x27;&#x27;, head = T, sep = &#x27;\t&#x27;)</span><br><span class="line">b = read.table(&#x27;&#x27;, comment.char = &#x27;!&#x27;, head = T, sep = &#x27;\t&#x27;)  # 带感叹号的不读取</span><br><span class="line">write.csv(b,&#x27;.csv&#x27;)</span><br><span class="line">d = read.csv(&#x27;.csv&#x27;)</span><br><span class="line"></span><br><span class="line">read.table(&#x27;&#x27;, head = T, sep = &#x27;\t&#x27;)</span><br><span class="line">save(b,file = &#x27;b_input.Rdata&#x27;)</span><br><span class="line">load(file = &#x27;b_input.Rdata&#x27;)</span><br><span class="line">b = b[,-1]  # 取第一行</span><br><span class="line">b = log2(b)</span><br><span class="line">pheatmap::pheatmap(b[1:10,])</span><br><span class="line">pheatmap::pheatmap(raw_exprSet[1:10,c(&quot;GSM74875&quot;,&quot;GSM74876&quot;)])</span><br></pre></td></tr></table></figure><br>建议把excel转成csv来读取</p>
<p>R中的变量<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; # 数字变量</span><br><span class="line">&gt; a &lt;- 10</span><br><span class="line">&gt; a</span><br><span class="line">[1] 10</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 字符串变量</span><br><span class="line">&gt; a &lt;- &quot;abc&quot;</span><br><span class="line">&gt; a</span><br><span class="line">[1] &quot;abc&quot;</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 逻辑变量</span><br><span class="line">&gt; a &lt;- TRUE</span><br><span class="line">&gt; </span><br><span class="line">&gt; a</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; </span><br><span class="line">&gt; b &lt;- T</span><br><span class="line">&gt; </span><br><span class="line">&gt; b</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; </span><br><span class="line">&gt; d &lt;- FALSE</span><br><span class="line">&gt; </span><br><span class="line">&gt; d</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; # 向量</span><br><span class="line">&gt; </span><br><span class="line">&gt; a &lt;- vector(mode=&quot;logical&quot;, length=5)</span><br><span class="line">&gt; a</span><br><span class="line">[1] FALSE FALSE FALSE FALSE FALSE</span><br><span class="line">&gt; </span><br><span class="line">&gt; a &lt;- c(1,2,3,4)</span><br><span class="line"># 判断一个变量是不是vector</span><br><span class="line">&gt; is.vector(a)</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 矩阵</span><br><span class="line">&gt; </span><br><span class="line">&gt; a &lt;- matrix(1:20,nrow=5,ncol=4,byrow=T)</span><br><span class="line">&gt; a</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    2    3    4</span><br><span class="line">[2,]    5    6    7    8</span><br><span class="line">[3,]    9   10   11   12</span><br><span class="line">[4,]   13   14   15   16</span><br><span class="line">[5,]   17   18   19   20</span><br><span class="line">&gt; </span><br><span class="line">&gt; is.matrix(a)</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; </span><br><span class="line">&gt; dim(a) #查看或设置数组的维度向量</span><br><span class="line">[1] 5 4</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 错误的用法</span><br><span class="line">&gt; dim(a) &lt;- c(4,4)</span><br><span class="line">Error in dim(a) &lt;- c(4, 4) : dims [product 16]与对象长度[20]不匹配</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 正确的用法</span><br><span class="line">&gt; a &lt;- 1:20</span><br><span class="line">&gt; dim(a) &lt;- c(5,4) #转换向量为矩阵</span><br><span class="line">&gt; a</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    6   11   16</span><br><span class="line">[2,]    2    7   12   17</span><br><span class="line">[3,]    3    8   13   18</span><br><span class="line">[4,]    4    9   14   19</span><br><span class="line">[5,]    5   10   15   20</span><br><span class="line">&gt; </span><br><span class="line">&gt; print(paste(&quot;矩阵a的行数&quot;, nrow(a)))</span><br><span class="line">[1] &quot;矩阵a的行数 5&quot;</span><br><span class="line">&gt; print(paste(&quot;矩阵a的列数&quot;, ncol(a)))</span><br><span class="line">[1] &quot;矩阵a的列数 4&quot;</span><br><span class="line">&gt; </span><br><span class="line">&gt; #查看或设置行列名</span><br><span class="line">&gt; rownames(a)</span><br><span class="line">NULL</span><br><span class="line">&gt; rownames(a) &lt;- c(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;)</span><br><span class="line">&gt; a</span><br><span class="line">  [,1] [,2] [,3] [,4]</span><br><span class="line">a    1    6   11   16</span><br><span class="line">b    2    7   12   17</span><br><span class="line">c    3    8   13   18</span><br><span class="line">d    4    9   14   19</span><br><span class="line">e    5   10   15   20</span><br><span class="line"></span><br><span class="line"># R中获取一系列的字母</span><br><span class="line">&gt; letters[1:4]</span><br><span class="line">[1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line">&gt; colnames(a) &lt;- letters[1:4]</span><br><span class="line">&gt; a</span><br><span class="line">  a  b  c  d</span><br><span class="line">a 1  6 11 16</span><br><span class="line">b 2  7 12 17</span><br><span class="line">c 3  8 13 18</span><br><span class="line">d 4  9 14 19</span><br><span class="line">e 5 10 15 20</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"># is系列和as系列函数用来判断变量的属性和转换变量的属性</span><br><span class="line"># 矩阵转换为data.frame</span><br><span class="line">&gt; is.character(a)</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; is.numeric(a)</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; is.matrix(a)</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; is.data.frame(a)</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; is.data.frame(as.data.frame(a))</span><br><span class="line">[1] TRUE</span><br><span class="line">R中矩阵运算</span><br><span class="line"></span><br><span class="line"># 数据产生</span><br><span class="line"># rnorm(n, mean = 0, sd = 1) 正态分布的随机数</span><br><span class="line"># runif(n, min = 0, max = 1) 平均分布的随机数</span><br><span class="line"># rep(1,5) 把1重复5次</span><br><span class="line"># scale(1:5) 标准化数据</span><br><span class="line">&gt; a &lt;- c(rnorm(5), rnorm(5,1), runif(5), runif(5,-1,1), 1:5, rep(0,5), c(2,10,11,13,4), scale(1:5)[1:5])</span><br><span class="line">&gt; a</span><br><span class="line"> [1] -0.41253556  0.12192929 -0.47635888 -0.97171653  1.09162243  1.87789657</span><br><span class="line"> [7] -0.11717937  2.92953522  1.33836620 -0.03269026  0.87540920  0.13005744</span><br><span class="line">[13]  0.11900686  0.76663940  0.28407356 -0.91251181  0.17997973  0.50452258</span><br><span class="line">[19]  0.25961316 -0.58052230  1.00000000  2.00000000  3.00000000  4.00000000</span><br><span class="line">[25]  5.00000000  0.00000000  0.00000000  0.00000000  0.00000000  0.00000000</span><br><span class="line">[31]  2.00000000 10.00000000 11.00000000 13.00000000  4.00000000 -1.26491106</span><br><span class="line">[37] -0.63245553  0.00000000  0.63245553  1.26491106</span><br><span class="line">&gt; a &lt;- matrix(a, ncol=5, byrow=T)</span><br><span class="line">&gt; a</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">[3,]  0.8754092  0.1300574  0.1190069  0.7666394  0.28407356</span><br><span class="line">[4,] -0.9125118  0.1799797  0.5045226  0.2596132 -0.58052230</span><br><span class="line">[5,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">[6,]  0.0000000  0.0000000  0.0000000  0.0000000  0.00000000</span><br><span class="line">[7,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">[8,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line"></span><br><span class="line"># 求行的加和</span><br><span class="line">&gt; rowSums(a)</span><br><span class="line">[1] -0.6470593  5.9959284  2.1751865 -0.5489186 15.0000000  0.0000000 40.0000000</span><br><span class="line">[8]  0.0000000</span><br><span class="line"></span><br><span class="line">## 注意检查括号的配对</span><br><span class="line">&gt; a &lt;- a[rowSums(abs(a)!=0,]</span><br><span class="line">错误: 意外的&#x27;]&#x27; in &quot;a &lt;- a[rowSums(abs(a)!=0,]&quot;</span><br><span class="line"></span><br><span class="line"># 去除全部为0的行</span><br><span class="line">&gt; a &lt;- a[rowSums(abs(a))!=0,]</span><br><span class="line"></span><br><span class="line"># 另外一种方式去除全部为0的行</span><br><span class="line">&gt; #a[rowSums(a==0)&lt;ncol(a),]</span><br><span class="line">&gt; a</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">[3,]  0.8754092  0.1300574  0.1190069  0.7666394  0.28407356</span><br><span class="line">[4,] -0.9125118  0.1799797  0.5045226  0.2596132 -0.58052230</span><br><span class="line">[5,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">[6,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">[7,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line"></span><br><span class="line"># 矩阵运算，R默认针对整个数据进行常见运算</span><br><span class="line"></span><br><span class="line"># 所有值都乘以2</span><br><span class="line"></span><br><span class="line">&gt; a * 2</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,] -0.8250711  0.2438586 -0.9527178 -1.9434331  2.18324487</span><br><span class="line">[2,]  3.7557931 -0.2343587  5.8590704  2.6767324 -0.06538051</span><br><span class="line">[3,]  1.7508184  0.2601149  0.2380137  1.5332788  0.56814712</span><br><span class="line">[4,] -1.8250236  0.3599595  1.0090452  0.5192263 -1.16104460</span><br><span class="line">[5,]  2.0000000  4.0000000  6.0000000  8.0000000 10.00000000</span><br><span class="line">[6,]  4.0000000 20.0000000 22.0000000 26.0000000  8.00000000</span><br><span class="line">[7,] -2.5298221 -1.2649111  0.0000000  1.2649111  2.52982213</span><br><span class="line"></span><br><span class="line"># 所有值取绝对值，再取对数 （取对数前一般加一个数避免对0或负值取对数）</span><br><span class="line">&gt; log2(abs(a)+1)</span><br><span class="line">          [,1]      [,2]      [,3]      [,4]      [,5]</span><br><span class="line">[1,] 0.4982872 0.1659818 0.5620435 0.9794522 1.0646224</span><br><span class="line">[2,] 1.5250147 0.1598608 1.9743587 1.2255009 0.0464076</span><br><span class="line">[3,] 0.9072054 0.1763961 0.1622189 0.8210076 0.3607278</span><br><span class="line">[4,] 0.9354687 0.2387621 0.5893058 0.3329807 0.6604014</span><br><span class="line">[5,] 1.0000000 1.5849625 2.0000000 2.3219281 2.5849625</span><br><span class="line">[6,] 1.5849625 3.4594316 3.5849625 3.8073549 2.3219281</span><br><span class="line">[7,] 1.1794544 0.7070437 0.0000000 0.7070437 1.1794544</span><br><span class="line"></span><br><span class="line"># 取出最大值、最小值、行数、列数</span><br><span class="line">&gt; max(a)</span><br><span class="line">[1] 13</span><br><span class="line">&gt; min(a)</span><br><span class="line">[1] -1.264911</span><br><span class="line">&gt; nrow(a)</span><br><span class="line">[1] 7</span><br><span class="line">&gt; ncol(a)</span><br><span class="line">[1] 5</span><br><span class="line"></span><br><span class="line"># 增加一列或一行</span><br><span class="line"># cbind: column bind</span><br><span class="line">&gt; cbind(a, 1:7) </span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5] [,6]</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243    1</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026    2</span><br><span class="line">[3,]  0.8754092  0.1300574  0.1190069  0.7666394  0.28407356    3</span><br><span class="line">[4,] -0.9125118  0.1799797  0.5045226  0.2596132 -0.58052230    4</span><br><span class="line">[5,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000    5</span><br><span class="line">[6,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000    6</span><br><span class="line">[7,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106    7</span><br><span class="line">&gt; cbind(a, seven=1:7)</span><br><span class="line">                                                             seven</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243     1</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026     2</span><br><span class="line">[3,]  0.8754092  0.1300574  0.1190069  0.7666394  0.28407356     3</span><br><span class="line">[4,] -0.9125118  0.1799797  0.5045226  0.2596132 -0.58052230     4</span><br><span class="line">[5,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000     5</span><br><span class="line">[6,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000     6</span><br><span class="line">[7,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106     7</span><br><span class="line"></span><br><span class="line"># rbind: row bind</span><br><span class="line">&gt; rbind(a,1:5)</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">[3,]  0.8754092  0.1300574  0.1190069  0.7666394  0.28407356</span><br><span class="line">[4,] -0.9125118  0.1799797  0.5045226  0.2596132 -0.58052230</span><br><span class="line">[5,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">[6,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">[7,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line">[8,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line"></span><br><span class="line"># 计算每一行的mad (中值绝对偏差，一般认为比方差的鲁棒性更强，更少受异常值的影响，更能反映数据间的差异)</span><br><span class="line">&gt; apply(a,1,mad)</span><br><span class="line">[1] 0.7923976 2.0327283 0.2447279 0.4811672 1.4826000 4.4478000 0.9376786</span><br><span class="line"></span><br><span class="line"># 计算每一行的var (方差)</span><br><span class="line"># apply表示对数据（第一个参数）的每一行 (第二个参数赋值为1) 或每一列 (2)操作</span><br><span class="line">#      最后返回一个列表</span><br><span class="line">&gt; apply(a,1,var)</span><br><span class="line">[1]  0.6160264  1.6811161  0.1298913  0.3659391  2.5000000 22.5000000  1.0000000</span><br><span class="line"></span><br><span class="line"># 计算每一列的平均值</span><br><span class="line">&gt; apply(a,2,mean)</span><br><span class="line">[1] 0.4519068 1.6689045 2.4395294 2.7179083 1.5753421</span><br><span class="line"></span><br><span class="line"># 取出中值绝对偏差大于0.5的行</span><br><span class="line">&gt; b = a[apply(a,1,mad)&gt;0.5,]</span><br><span class="line">&gt; b</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">[3,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">[4,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">[5,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line"></span><br><span class="line"># 矩阵按照mad的大小降序排列</span><br><span class="line">&gt; c = b[order(apply(b,1,mad), decreasing=T),]</span><br><span class="line">&gt; c</span><br><span class="line">           [,1]       [,2]       [,3]       [,4]        [,5]</span><br><span class="line">[1,]  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">[2,]  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">[3,]  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">[4,] -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line">[5,] -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line"></span><br><span class="line">&gt; rownames(c) &lt;- paste(&#x27;Gene&#x27;, letters[1:5], sep=&quot;_&quot;)</span><br><span class="line">&gt; colnames(c) &lt;- toupper(letters[1:5])</span><br><span class="line">&gt; c</span><br><span class="line">                A          B          C          D           E</span><br><span class="line">Gene_a  2.0000000 10.0000000 11.0000000 13.0000000  4.00000000</span><br><span class="line">Gene_b  1.8778966 -0.1171794  2.9295352  1.3383662 -0.03269026</span><br><span class="line">Gene_c  1.0000000  2.0000000  3.0000000  4.0000000  5.00000000</span><br><span class="line">Gene_d -1.2649111 -0.6324555  0.0000000  0.6324555  1.26491106</span><br><span class="line">Gene_e -0.4125356  0.1219293 -0.4763589 -0.9717165  1.09162243</span><br><span class="line"></span><br><span class="line"># 矩阵转置</span><br><span class="line">&gt; expr = t(c)</span><br><span class="line">&gt; expr</span><br><span class="line">  Gene_a      Gene_b Gene_c     Gene_d     Gene_e</span><br><span class="line">A      2  1.87789657      1 -1.2649111 -0.4125356</span><br><span class="line">B     10 -0.11717937      2 -0.6324555  0.1219293</span><br><span class="line">C     11  2.92953522      3  0.0000000 -0.4763589</span><br><span class="line">D     13  1.33836620      4  0.6324555 -0.9717165</span><br><span class="line">E      4 -0.03269026      5  1.2649111  1.0916224</span><br><span class="line"></span><br><span class="line"># 矩阵值的替换</span><br><span class="line">&gt; expr2 = expr</span><br><span class="line">&gt; expr2[expr2&lt;0] = 0</span><br><span class="line">&gt; expr2</span><br><span class="line">  Gene_a   Gene_b Gene_c    Gene_d    Gene_e</span><br><span class="line">A      2 1.877897      1 0.0000000 0.0000000</span><br><span class="line">B     10 0.000000      2 0.0000000 0.1219293</span><br><span class="line">C     11 2.929535      3 0.0000000 0.0000000</span><br><span class="line">D     13 1.338366      4 0.6324555 0.0000000</span><br><span class="line">E      4 0.000000      5 1.2649111 1.0916224</span><br><span class="line"></span><br><span class="line"># 矩阵中只针对某一列替换</span><br><span class="line"># expr2是个矩阵不是数据框，不能使用列名字索引</span><br><span class="line">&gt; expr2[expr2$Gene_b&lt;1, &quot;Gene_b&quot;] &lt;- 1</span><br><span class="line">Error in expr2$Gene_b : $ operator is invalid for atomic vectors</span><br><span class="line"># str是一个最为常用、好用的查看变量信息的工具，尤其是对特别复杂的变量，</span><br><span class="line">#    可以看清其层级结构，便于提取数据</span><br><span class="line">&gt; str(expr2)</span><br><span class="line"> num [1:5, 1:5] 2 10 11 13 4 ...</span><br><span class="line"> - attr(*, &quot;dimnames&quot;)=List of 2</span><br><span class="line">  ..$ : chr [1:5] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ...</span><br><span class="line">  ..$ : chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ...</span><br><span class="line"></span><br><span class="line"># 转换为数据库，再进行相应的操作</span><br><span class="line">&gt; expr2 &lt;- as.data.frame(expr2)</span><br><span class="line">&gt; str(expr2)</span><br><span class="line">&#x27;data.frame&#x27;:    5 obs. of  5 variables:</span><br><span class="line"> $ Gene_a: num  2 10 11 13 4</span><br><span class="line"> $ Gene_b: num  1.88 1 2.93 1.34 1</span><br><span class="line"> $ Gene_c: num  1 2 3 4 5</span><br><span class="line"> $ Gene_d: num  0 0 0 0.632 1.265</span><br><span class="line"> $ Gene_e: num  0 0.122 0 0 1.092</span><br><span class="line">&gt; expr2[expr2$Gene_b&lt;1, &quot;Gene_b&quot;] &lt;- 1</span><br><span class="line">&gt; expr2</span><br><span class="line">&gt; expr2</span><br><span class="line">  Gene_a   Gene_b Gene_c    Gene_d    Gene_e</span><br><span class="line">A      2 1.877897      1 0.0000000 0.0000000</span><br><span class="line">B     10 1.000000      2 0.0000000 0.1219293</span><br><span class="line">C     11 2.929535      3 0.0000000 0.0000000</span><br><span class="line">D     13 1.338366      4 0.6324555 0.0000000</span><br><span class="line">E      4 1.000000      5 1.2649111 1.0916224</span><br><span class="line">R中矩阵筛选合并</span><br><span class="line"></span><br><span class="line"># 读入样品信息</span><br><span class="line">&gt; sampleInfo = &quot;Samp;Group;Genotype</span><br><span class="line">+ A;Control;WT</span><br><span class="line">+ B;Control;WT</span><br><span class="line">+ D;Treatment;Mutant</span><br><span class="line">+ C;Treatment;Mutant</span><br><span class="line">+ E;Treatment;WT</span><br><span class="line">+ F;Treatment;WT&quot;</span><br><span class="line">&gt; phenoData = read.table(text=sampleInfo,sep=&quot;;&quot;, header=T, row.names=1, quote=&quot;&quot;)</span><br><span class="line">&gt; phenoData</span><br><span class="line">      Group Genotype</span><br><span class="line">A   Control       WT</span><br><span class="line">B   Control       WT</span><br><span class="line">D Treatment   Mutant</span><br><span class="line">C Treatment   Mutant</span><br><span class="line">E Treatment       WT</span><br><span class="line">F Treatment       WT</span><br><span class="line"></span><br><span class="line"># 把样品信息按照基因表达矩阵中的样品信息排序，并只保留有基因表达信息的样品</span><br><span class="line"># match() returns a vector of the positions of (first) matches of</span><br><span class="line">          its first argument in its second.</span><br><span class="line">&gt; phenoData[match(rownames(expr), rownames(phenoData)),]</span><br><span class="line">      Group Genotype</span><br><span class="line">A   Control       WT</span><br><span class="line">B   Control       WT</span><br><span class="line">C Treatment   Mutant</span><br><span class="line">D Treatment   Mutant</span><br><span class="line">E Treatment       WT</span><br><span class="line"></span><br><span class="line"># ‘%in%’ is a more intuitive interface as a binary operator, which</span><br><span class="line">     returns a logical vector indicating if there is a match or not for</span><br><span class="line">     its left operand.</span><br><span class="line"></span><br><span class="line"># 注意顺序，%in%比match更好理解一些</span><br><span class="line">&gt; phenoData = phenoData[rownames(phenoData) %in% rownames(expr),]</span><br><span class="line">&gt; phenoData</span><br><span class="line">      Group Genotype</span><br><span class="line">A   Control       WT</span><br><span class="line">B   Control       WT</span><br><span class="line">C Treatment   Mutant</span><br><span class="line">D Treatment   Mutant</span><br><span class="line">E Treatment       WT</span><br><span class="line"></span><br><span class="line"># 合并矩阵</span><br><span class="line"># by=0 表示按照行的名字排序</span><br><span class="line"># by=columnname 表示按照共有的某一列排序</span><br><span class="line"># 合并后多出了新的一列Row.names</span><br><span class="line">&gt; merge_data = merge(expr, phenoData, by=0, all.x=T)</span><br><span class="line">&gt; merge_data</span><br><span class="line">  Row.names Gene_a      Gene_b Gene_c     Gene_d     Gene_e     Group Genotype</span><br><span class="line">1         A      2  1.87789657      1 -1.2649111 -0.4125356   Control       WT</span><br><span class="line">2         B     10 -0.11717937      2 -0.6324555  0.1219293   Control       WT</span><br><span class="line">3         C     11  2.92953522      3  0.0000000 -0.4763589 Treatment   Mutant</span><br><span class="line">4         D     13  1.33836620      4  0.6324555 -0.9717165 Treatment   Mutant</span><br><span class="line">5         E      4 -0.03269026      5  1.2649111  1.0916224 Treatment       WT</span><br><span class="line"></span><br><span class="line">&gt; rownames(merge_data) &lt;- merge_data$Row.names</span><br><span class="line">&gt; merge_data </span><br><span class="line">  Row.names Gene_a      Gene_b Gene_c     Gene_d     Gene_e     Group Genotype</span><br><span class="line">A         A      2  1.87789657      1 -1.2649111 -0.4125356   Control       WT</span><br><span class="line">B         B     10 -0.11717937      2 -0.6324555  0.1219293   Control       WT</span><br><span class="line">C         C     11  2.92953522      3  0.0000000 -0.4763589 Treatment   Mutant</span><br><span class="line">D         D     13  1.33836620      4  0.6324555 -0.9717165 Treatment   Mutant</span><br><span class="line">E         E      4 -0.03269026      5  1.2649111  1.0916224 Treatment       WT</span><br><span class="line"></span><br><span class="line"># 去除一列；-1表示去除第一列</span><br><span class="line">&gt; merge_data = merge_data[,-1]</span><br><span class="line">&gt; merge_data</span><br><span class="line">  Gene_a      Gene_b Gene_c     Gene_d     Gene_e     Group Genotype</span><br><span class="line">A      2  1.87789657      1 -1.2649111 -0.4125356   Control       WT</span><br><span class="line">B     10 -0.11717937      2 -0.6324555  0.1219293   Control       WT</span><br><span class="line">C     11  2.92953522      3  0.0000000 -0.4763589 Treatment   Mutant</span><br><span class="line">D     13  1.33836620      4  0.6324555 -0.9717165 Treatment   Mutant</span><br><span class="line">E      4 -0.03269026      5  1.2649111  1.0916224 Treatment       WT</span><br><span class="line"></span><br><span class="line"># 提取出所有的数值列</span><br><span class="line">&gt; merge_data[sapply(merge_data, is.numeric)]</span><br><span class="line">  Gene_a      Gene_b Gene_c     Gene_d     Gene_e</span><br><span class="line">A      2  1.87789657      1 -1.2649111 -0.4125356</span><br><span class="line">B     10 -0.11717937      2 -0.6324555  0.1219293</span><br><span class="line">C     11  2.92953522      3  0.0000000 -0.4763589</span><br><span class="line">D     13  1.33836620      4  0.6324555 -0.9717165</span><br><span class="line">E      4 -0.03269026      5  1.2649111  1.0916224</span><br><span class="line">str的应用</span><br><span class="line"></span><br><span class="line">str:  Compactly display the internal structure of an R object, a     diagnostic function and an alternative to ‘summary (and to some     extent, ‘dput’).  Ideally, only one line for each ‘basic’     structure is displayed.  It is especially well suited to compactly     display the (abbreviated) contents of (possibly nested) lists.     The idea is to give reasonable output for any R object.  It     calls ‘args’ for (non-primitive) function objects.</span><br><span class="line"></span><br><span class="line">str用来告诉结果的构成方式，对于不少Bioconductor的包，或者复杂的R函数的输出，都是一堆列表的嵌套，str(complex_result)会输出每个列表的名字，方便提取对应的信息。</span><br><span class="line"></span><br><span class="line"># str的一个应用例子</span><br><span class="line">&gt; str(list(a = &quot;A&quot;, L = as.list(1:100)), list.len = 9)</span><br><span class="line">List of 2</span><br><span class="line"> $ a: chr &quot;A&quot;</span><br><span class="line"> $ L:List of 100</span><br><span class="line">  ..$ : int 1</span><br><span class="line">  ..$ : int 2</span><br><span class="line">  ..$ : int 3</span><br><span class="line">  ..$ : int 4</span><br><span class="line">  ..$ : int 5</span><br><span class="line">  ..$ : int 6</span><br><span class="line">  ..$ : int 7</span><br><span class="line">  ..$ : int 8</span><br><span class="line">  ..$ : int 9</span><br><span class="line">  .. [list output truncated]</span><br><span class="line"></span><br><span class="line"># 利用str查看pca的结果，具体的PCA应用查看http://mp.weixin.qq.com/s/sRElBMkyR9rGa4TQp9KjNQ</span><br><span class="line"></span><br><span class="line">&gt; pca_result &lt;- prcomp(expr)</span><br><span class="line">&gt; pca_result</span><br><span class="line">Standard deviations:</span><br><span class="line">[1] 4.769900e+00 1.790861e+00 1.072560e+00 1.578391e-01 2.752128e-16</span><br><span class="line"></span><br><span class="line">Rotation:</span><br><span class="line">               PC1         PC2          PC3         PC4         PC5</span><br><span class="line">Gene_a  0.99422750 -0.02965529  0.078809521  0.01444655  0.06490461</span><br><span class="line">Gene_b  0.04824368 -0.44384942 -0.885305329  0.03127940  0.12619948</span><br><span class="line">Gene_c  0.08258192  0.81118590 -0.451360828  0.05440417 -0.35842886</span><br><span class="line">Gene_d -0.01936958  0.30237826 -0.079325524 -0.66399283  0.67897952</span><br><span class="line">Gene_e -0.04460135  0.22948437 -0.002097256  0.74496081  0.62480128</span><br><span class="line">&gt; str(pca_result)</span><br><span class="line">List of 5</span><br><span class="line"> $ sdev    : num [1:5] 4.77 1.79 1.07 1.58e-01 2.75e-16</span><br><span class="line"> $ rotation: num [1:5, 1:5] 0.9942 0.0482 0.0826 -0.0194 -0.0446 ...</span><br><span class="line">  ..- attr(*, &quot;dimnames&quot;)=List of 2</span><br><span class="line">  .. ..$ : chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ...</span><br><span class="line">  .. ..$ : chr [1:5] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ...</span><br><span class="line"> $ center  : Named num [1:5] 8 1.229 3 0.379 0.243</span><br><span class="line">  ..- attr(*, &quot;names&quot;)= chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ...</span><br><span class="line"> $ scale   : logi FALSE</span><br><span class="line"> $ x       : num [1:5, 1:5] -6.08 1.86 3.08 5.06 -3.93 ...</span><br><span class="line">  ..- attr(*, &quot;dimnames&quot;)=List of 2</span><br><span class="line">  .. ..$ : chr [1:5] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ...</span><br><span class="line">  .. ..$ : chr [1:5] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ...</span><br><span class="line"> - attr(*, &quot;class&quot;)= chr &quot;prcomp&quot;</span><br><span class="line"></span><br><span class="line"># 取出每个主成分解释的差异</span><br><span class="line">&gt; pca_result$sdev</span><br><span class="line">[1] 4.769900e+00 1.790861e+00 1.072560e+00 1.578391e-01 2.752128e-16</span><br><span class="line">R的包管理</span><br><span class="line"></span><br><span class="line"># 什么时候需要安装包</span><br><span class="line">&gt; library(&#x27;unExistedPackage&#x27;)</span><br><span class="line">Error in library(&quot;unExistedPackage&quot;) : </span><br><span class="line">  不存在叫‘unExistedPackage’这个名字的程辑包</span><br><span class="line"></span><br><span class="line"># 安装包</span><br><span class="line">&gt; install.packages(&quot;package_name&quot;)</span><br><span class="line"># 指定安装来源</span><br><span class="line">&gt; install.packages(&quot;package_name&quot;, repo=&quot;http://cran.us.r-project.org&quot;)</span><br><span class="line"></span><br><span class="line"># 安装Bioconductor的包</span><br><span class="line">&gt; source(&#x27;https://bioconductor.org/biocLite.R&#x27;)</span><br><span class="line">&gt; biocLite(&#x27;BiocInstaller&#x27;)</span><br><span class="line">&gt; biocLite(c(&quot;RUVSeq&quot;,&quot;pcaMethods&quot;))</span><br><span class="line"></span><br><span class="line"># 安装Github的R包</span><br><span class="line">&gt; install.packages(&quot;devtools&quot;)</span><br><span class="line">&gt; devtools::install_github(&quot;JustinaZ/pcaReduce&quot;)</span><br><span class="line"></span><br><span class="line"># 手动安装, 首先下载包的源文件（压缩版就可），然后在终端运行下面的命令。</span><br><span class="line">ct@ehbio:~$ R CMD INSTALL package.tar.gz</span><br><span class="line"></span><br><span class="line"># 移除包</span><br><span class="line">&gt;remove.packages(&quot;package_name&quot;)</span><br><span class="line"></span><br><span class="line"># 查看所有安装的包</span><br><span class="line">&gt;library()</span><br><span class="line"></span><br><span class="line"># 查看特定安装包的版本</span><br><span class="line">&gt; installed.packages()[c(&quot;DESeq2&quot;), c(&quot;Package&quot;, &quot;Version&quot;)]</span><br><span class="line"> Package  Version </span><br><span class="line">&quot;DESeq2&quot; &quot;1.14.1&quot; </span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"># 查看默认安装包的位置</span><br><span class="line">&gt;.libPaths()</span><br><span class="line"></span><br><span class="line"># 调用安装的包</span><br><span class="line">&gt;library(package_name)</span><br><span class="line"></span><br><span class="line">#devtools::install_github(&quot;hms-dbmi/scde&quot;, build_vignettes = FALSE)</span><br><span class="line">#install.packages(c(&quot;mvoutlier&quot;,&quot;ROCR&quot;))</span><br><span class="line">#biocLite(c(&quot;RUVSeq&quot;,&quot;pcaMethods&quot;,&quot;SC3&quot;,&quot;TSCAN&quot;,&quot;monocle&quot;,&quot;MultiAssayExperiment&quot;,&quot;SummarizedExperiment&quot;))</span><br><span class="line">#devtools::install_github(&quot;satijalab/seurat&quot;)</span><br></pre></td></tr></table></figure></p>
<h1 id="DNA测序"><a href="#DNA测序" class="headerlink" title="DNA测序"></a>DNA测序</h1><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>fastq-&gt;bam-&gt;vcf-&gt;maf-&gt;各种高级分析结果</p>
<h4 id="文件格式："><a href="#文件格式：" class="headerlink" title="文件格式："></a>文件格式：</h4><ul>
<li>fastq</li>
</ul>
<p>第一行：以‘@’开头，是这一条read的名字，这个字符串是根据测序时的状态信息转换过来的，中间不会有空格，它是每一条read的唯一标识符，同一份FASTQ文件中不会重复出现，甚至不同的FASTQ文件里也不会有重复；</p>
<p>第二行：测序read的序列，由A，C，G，T和N这五种字母构成，这也是我们真正关心的DNA序列，N代表的是测序时那些无法被识别出来的碱基；</p>
<p>第三行：以‘+’开头，在旧版的FASTQ文件中会直接重复第一行的信息，但现在一般什么也不加（节省存储空间）；</p>
<p>第四行：测序read的质量值，这个和第二行的碱基信息一样重要，它描述的是每个测序碱基的可靠程度，用ASCII码表示。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FCD056DACXX:3:1101:2163:1959#TCGCCGTG/1</span><br><span class="line">TCCGATAACGCTCAACCAGAGGGCTGCCAGCTCCGATCGGCAGTTGCAACCCATTGGCCGTCTGAGCCAGCAACCCCGGA</span><br><span class="line">+</span><br><span class="line">gggiiiiiiiiiiiiiiiiiiiiiiiiiigggggeeecccccc^bcbcccccccbccccc]aaccbbccc^R^^acccc_</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>bam</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FCC1L2FACXX:3:2106:15923:93264	99	1	1073	0	100M	=	1461	488 TGTGAAGGCCCCCTGCTCTGACTGTGTTAGTGTCCATTTCTCCTTTTACGGTTGTAGCAGTTGCCTTCTACATTGCGGGGATCCTGTATTGGGTGCATGT ___eceeegfggggdgiiifghii[degfhfgfdffhhhfhfghiiighiiH^`Vbgfffihhiiiihhddbdgfgccca][^bbbbbccbca[X^Y_b_ MD:Z:98A1	PG:Z:MarkDuplicatesRG:Z:SRR949625	NM:i:1	AS:i:98	XS:i:98</span><br><span class="line">FCC1L2FACXX:3:2111:13731:89147	163	1	1073	7	100M	=	1438	465 TGTGAAGGCCCCGTGCTCTGACTGTGTTAGTGTCCATTTCTCCTTTTACGGTTGTAGCAGTTGCCTTCTACATTGCGGGGATCCTGTATTGGGTGCATAT bbaeeeeefggggefhiiiihiiicgghhigdehhhiiihiieffhiihihbggdghihfgffhihihf`geed_cecac]accb]_bcccbc^a_bcbb MD:Z:12C87	PG:Z:MarkDuplicatesRG:Z:SRR949625	NM:i:1	AS:i:95	XS:i:95</span><br></pre></td></tr></table></figure>
</li>
<li><p>vcf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.什么是vcf文件</span><br><span class="line">VCF是用于描述SNP（单个碱基上的变异），INDEL（插入缺失标记）和SV（结构变异位点）结果的文本文件。在GATK软件中得到最好的支持，当然SAMtools得到的结果也是VCF格式，和GATK的CVF格式有点差别。</span><br><span class="line"></span><br><span class="line">2.VCF的主体结构</span><br><span class="line">##fileformat=VCFv4.2</span><br><span class="line">##fileDate=20090805</span><br><span class="line">##source=myImputationProgramV3.1</span><br><span class="line">##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta</span><br><span class="line">##contig=&lt;ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=&quot;Homo sapiens&quot;,taxonomy=x&gt;</span><br><span class="line">##phasing=partial</span><br><span class="line">##INFO=&lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Data&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=AA,Number=1,Type=String,Description=&quot;Ancestral Allele&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&gt;</span><br><span class="line">##FILTER=&lt;ID=q10,Description=&quot;Quality below 10&quot;&gt;</span><br><span class="line">##FILTER=&lt;ID=s50,Description=&quot;Less than 50% of samples have data&quot;&gt;</span><br><span class="line">##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;</span><br><span class="line">##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&gt;</span><br><span class="line">##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Read Depth&quot;&gt;</span><br><span class="line">##FORMAT=&lt;ID=HQ,Number=2,Type=Integer,Description=&quot;Haplotype Quality&quot;&gt;</span><br><span class="line">#CHROM POS     ID        REF    ALT     QUAL FILTER INFO                              FORMAT      NA00001        NA00002        NA00003</span><br><span class="line">    14370   rs6054257 G      A       29   PASS   NS=3;DP=14;AF=0.5;DB;H2           GT:GQ:DP:HQ 0|0:48:1:51,51 1|0:48:8:51,51 1/1:43:5:.,.</span><br><span class="line">    17330   .         T      A       3    q10    NS=3;DP=11;AF=0.017               GT:GQ:DP:HQ 0|0:49:3:58,50 0|1:3:5:65,3   0/0:41:3</span><br><span class="line">    1110696 rs6040355 A      G,T     67   PASS   NS=2;DP=10;AF=0.333,0.667;AA=T;DB GT:GQ:DP:HQ 1|2:21:6:23,27 2|1:2:0:18,2   2/2:35:4</span><br><span class="line">    1230237 .         T      .       47   PASS   NS=3;DP=13;AA=T                   GT:GQ:DP:HQ 0|0:54:7:56,60 0|0:48:4:51,51 0/0:61:2</span><br><span class="line">    1234567 microsat1 GTC    G,GTCT  50   PASS   NS=3;DP=9;AA=G                    GT:GQ:DP    0/1:35:4      </span><br></pre></td></tr></table></figure></li>
<li>maf</li>
</ul>
<p><img src="/img/bioinfo_teaching/1597303156981.png" alt="1597303156981.png"></p>
<h4 id="IGV"><a href="#IGV" class="headerlink" title="IGV"></a>IGV</h4><p><img src="/img/bioinfo_teaching/2020-08-18-18-55-58.png" alt=""></p>
<h1 id="RNAseq"><a href="#RNAseq" class="headerlink" title="RNAseq"></a>RNAseq</h1><h4 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -p ./envs -c bioconda sra-tools</span><br><span class="line">conda install fastqc</span><br><span class="line">conda install hisat2</span><br><span class="line">conda install samtools=1.9</span><br><span class="line">samtools  -help</span><br></pre></td></tr></table></figure>
<h3 id="什么是RNA-seq"><a href="#什么是RNA-seq" class="headerlink" title="什么是RNA seq"></a>什么是RNA seq</h3><h4 id="reads-Count"><a href="#reads-Count" class="headerlink" title="reads Count"></a>reads Count</h4><p>定义：高通量测序中比对到exon上的reads数。</p>
<h4 id="RPKM-FPKM"><a href="#RPKM-FPKM" class="headerlink" title="RPKM/FPKM"></a>RPKM/FPKM</h4><p>定义：RPKM: Reads Per Kilobase of exon model per Million mapped reads (每千个碱基的转录每百万映射读取的reads)；FPKM: Fragments Per Kilobase of exon model per Million mapped fragments(每千个碱基的转录每百万映射读取的fragments)<br>公式：RPKM = (ExonMappedReads <em> 10^9 ) / (TotalMappedReads </em> ExonLength)</p>
<h4 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEO 数据库</span><br><span class="line">连接：https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE52778</span><br><span class="line">了解数据</span><br><span class="line">然后熟悉如何寻找数据</span><br><span class="line">https://bigd.big.ac.cn/?lang=zh</span><br><span class="line">找到数据后下载</span><br><span class="line">sra-tools -&gt; prefetch</span><br><span class="line">prefetch --option-file  SRR_Acc_List.txt</span><br><span class="line">比对</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h1><h2 id="统计学基础"><a href="#统计学基础" class="headerlink" title="统计学基础"></a>统计学基础</h2><p><a href="https://blog.csdn.net/qq_41909309/article/details/103595682">https://blog.csdn.net/qq_41909309/article/details/103595682</a></p>
<ul>
<li>文氏图</li>
</ul>
<p><img src="/img/bioinfo_teaching/1597200341165.png" alt="1597200341165.png"></p>
<ul>
<li>热图</li>
</ul>
<p><img src="/img/bioinfo_teaching/1597200355169.png" alt="1597200355169.png"></p>
<p>图示解释：<br>聚类热图包含两个数据轴的信息，一个轴表示不同的实验处理条件/样本（如图中横轴），另一个轴表示不同的基因（如图中纵轴）根据聚类分析可以将不同样本中表达模式相同或相似的基因聚为一类。表达模式相似的基因可能具有相似的功能，共同参与同一代谢过程或存在于同一细胞通路中，因此，将表达模式相同或相近的基因聚集成类，可以用于推测未知基因的功能或已知基因的新功能。<br>红色：表示基因表达水平高；蓝色：表示基因表达水平低。<br>聚类方式：双向聚类（如上图）可以根据某一基因在不同样本中的表达水平将样本聚类，同时可以根据某一样本中不同基因的表达水平将基因进行聚类。另有横向/纵向聚类、无向聚类。</p>
<ul>
<li>hist plot</li>
</ul>
<p><img src="/img/bioinfo_teaching/1597208385052.png" alt="1597208385052.png"></p>
<ul>
<li>火山图</li>
</ul>
<p><img src="/img/bioinfo_teaching/1597200095269.png" alt="1597200095269.png"></p>
<p>火山图，是形如火山喷发的一种图形展示方法，常被用于展示差异，比如差异基因、差异微生物等等。<br>上图就是一张典型的火山图，描述了差异基因的情况。该火山图的y轴是-log10(Qvalue)，即qvalue（pvalue校正后的值）取-log10，因此数值越高说明qvalue越小即越显著。横坐标是Log2 fold change，即对fold change取log2，所以越靠两侧的点（每个点代表一个基因），其基因表达量上调或者下调幅度越大。<br>一般来说在差异基因分析过程中，我们通常认为qvalue小于0.05且foldchange的绝对值大于2为差异基因。当然在差异基因数量过多的时候，我们可以调整筛选标准以获得相对适合数量的差异基因再进行下游的富集分析，比如要求qvalue小于0.001，或者要求foldchange的绝对值大于5等等。当差异基因数量过少的时候，我们可以考虑将foldchange的绝对值变为1.5，或者考虑选择pvalue小于0.05。<br>而图中的虚线就是根据自己的筛选标准确定添加。其中两条竖线（x=-2和x=2）说明该筛选标准是要求foldchange的绝对值大于4。横线（大胆猜测是在y=2处），说明要求qvalue小于0.01。<br>当Foldchange没有那么明显的时候，我们的横轴也可以选择展示Foldchange，不取log2。</p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>请看ppt pca步骤分解</p>
<h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>请看ppt pca步骤分解</p>
<h2 id="如何使用这些方法："><a href="#如何使用这些方法：" class="headerlink" title="如何使用这些方法："></a>如何使用这些方法：</h2><p>文章案例</p>
<p>Identification of a novel biomarker, SEMA5A, for non-small cell lung carcinoma in nonsmoking women</p>
<p>相关基因：SEMA5A</p>
<p>相关疾病 ：Carcinoma, Non-Small-Cell Lung;Lung Neoplasms</p>
<p>PMID: 20802022 影响因子3.622 GEO 相关样本：120</p>
<p>文章作者使用检测了台湾地区非吸烟肺癌女性患者60对癌症和癌旁肺组织样本，利用配对T检验筛选了肿瘤组织中687个差异表达基因，并且利用逆转录PCR和免疫组化进行了验证。</p>
<p>如何将687个缩小范围呢?</p>
<p>因此我们需要判断差异基因在肺癌细胞中主要富集在哪些功能类群和代谢通路。文章作者利用IPA(Ingenuity Pathway Analysis)软件对差异基因进行了功能分析，筛选出了16条显著性代谢通路。在最显著改变的三条通路中，其中两条都和轴突导向信号通路(axon guidance)相关，作者很意外，于是就选定了轴突导向信号通路，并在其中挑选了差异表达倍数最高的SEMA5A基因作为后续的研究对象。</p>
<p>作者最后利用kaplan-Meier生存分析证明了SEMA5A基因的低表达和非吸烟女性肺癌的低生存率有关联，其可能成为非小细胞肺癌预后的一个有效的生物标志物，也可能代表台湾地区病人的性别特异性。</p>
<p>归纳一下作者的整体思路，先找差异基因，并通过功能分析进一步缩小差异基因的范围，再从中有针对性的挑选基因。</p>
<p><img src="/img/bioinfo_teaching/1597201078786.png" alt="1597201078786.png"></p>
<p>GO</p>
<p>GO是Gene ontology的缩写，GO数据库分别从功能、参与的生物途径及细胞中的定位对基因产物进行了标准化描述，即对基因产物进行简单注释，通过GO富集分析可以粗略了解差异基因富集在哪些生物学功能、途径或者细胞定位。</p>
<p>Pathway</p>
<p>Pathway指代谢通路，对差异基因进行pathway分析，可以了解实验条件下显著改变的代谢通路，在机制研究中显得尤为重要。</p>
<p>GO分析好比是将基因分门别类放入一个个功能类群的篮子，而pathway则是将基因一个个具体放到代谢网络中的指定位置。</p>
<p>文章分析结果</p>
<p>小编利用上述案例中的数据GSE19804在GCBI在线实验室首先进行差异分析(|fold change|&gt;2, P值&lt;0.001 Q值&lt;0.05)，得到了2202个差异基因。将差异基因分别进行GO(P值&lt;0.01，FDR&lt;0.01)和pathway分析(P值&lt;0.05)，富集得到351个GO term和110条pathway。结果如下图所示，表一和表二分别为部分GO富集结果和最显著的15条pathway分析结果。</p>
<p><img src="/img/bioinfo_teaching/1597201247043.png" alt="1597201247043.png"></p>
<p><img src="/img/bioinfo_teaching/1597201255312.png" alt="1597201255312.png"></p>
<p>结果怎么看呢?</p>
<p>表头各个参数的解释如下，其中，重点看三个指标， enrichment score、p值和FDR。Pathway分析主要看P值和FDR值，两者越小越好。GO分析还可看enrichment score，数值越大表示某个GO term越容易受到实验因素的影响。</p>
<p><img src="/img/bioinfo_teaching/1597201269271.png" alt="1597201269271.png"></p>
<p>GO和pathway分析结果中都得到了文章中选定的axon guidance这个结果(红框)。</p>
<p>Ps：因参数设置和文章中不同，结果仅供参考。</p>
<h2 id="5-热图"><a href="#5-热图" class="headerlink" title="5. 热图"></a>5. 热图</h2><p>为什么画个热图这么难</p>
<p>热图—不同大小的数据，代表不同颜色的深浅</p>
<p>paste(‘a1’, 1:20, sep = ‘_’)</p>
<p>跟着帮助文档的example学，边学边看</p>
<p>先看最基础的</p>
<p>看代码，慢慢理解</p>
<p>模拟数据，内置数据</p>
<p>整理好的真实数据</p>
<p>原始数据提取热图需要的数据</p>
<p>学R语言的动力</p>
<p>画热图的包有十几个</p>
<h2 id="6-选取差异明显的基因的表达量矩阵绘制热图"><a href="#6-选取差异明显的基因的表达量矩阵绘制热图" class="headerlink" title="6. 选取差异明显的基因的表达量矩阵绘制热图"></a>6. 选取差异明显的基因的表达量矩阵绘制热图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm(list = ls())   #魔幻操作，一键清空</span><br><span class="line">library(pheatmap)</span><br><span class="line">a1 = rnorm(100)</span><br><span class="line">dim(a1) = c(5,20)</span><br><span class="line">pheatmap(a1)</span><br><span class="line">a2 = rnow(100)+2</span><br><span class="line">dim(a2) = c(5,20)</span><br><span class="line">library(pheatmap)</span><br><span class="line">pheatmap(a1, cluster_rows = F, cluster_cols = F)</span><br><span class="line">pheatmap(cbind(a1,a2))</span><br><span class="line">pheatmap(cbind(a1,a2), show_rownames = F, show_colnames = F)</span><br></pre></td></tr></table></figure>
<p>拉平极差值</p>
<h2 id="7-ID转换"><a href="#7-ID转换" class="headerlink" title="7. ID转换"></a>7. ID转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学会R语言操作的高级技巧</span><br><span class="line"></span><br><span class="line">R语言批量处理</span><br><span class="line"></span><br><span class="line">找对应表格写代码转换</span><br><span class="line"></span><br><span class="line">一些函数</span><br><span class="line"></span><br><span class="line">strsplit(&#x27;&#x27;,&#x27;[.]&#x27;)  #根据点号分割</span><br><span class="line">duplicated()  #去重</span><br><span class="line"></span><br><span class="line">一些包</span><br><span class="line"></span><br><span class="line">org.Hs.eg.db    #在包里有基因注释关系</span><br></pre></td></tr></table></figure>
<h2 id="8-任意基因任意癌症表达量分组的生存分析"><a href="#8-任意基因任意癌症表达量分组的生存分析" class="headerlink" title="8. 任意基因任意癌症表达量分组的生存分析"></a>8. 任意基因任意癌症表达量分组的生存分析</h2><p>在线制作生存曲线的工具，oncolnc【<a href="http://www.oncolnc.org/】">http://www.oncolnc.org/】</a></p>
<p>学习包   survival</p>
<p>微调参数，大部分都不是自己写的</p>
<p>学会R语言基础变量结构，基础函数操作，应用高级代码</p>
<p>统计学、机器学习——数据做好，R包进，再进行理解</p>
<h2 id="9-任意基因任意癌症表达量和临床性状关联"><a href="#9-任意基因任意癌症表达量和临床性状关联" class="headerlink" title="9. 任意基因任意癌症表达量和临床性状关联"></a>9. 任意基因任意癌症表达量和临床性状关联</h2><p>某个基因在某个癌症的表达量，关联临床信息</p>
<p>Cbioportal【<a href="http://www.cbioportal.org/】">http://www.cbioportal.org/】</a></p>
<p>读取文本文件</p>
<p>尽量避免用函数名来命名</p>
<h2 id="10-表达矩阵样本的相关性"><a href="#10-表达矩阵样本的相关性" class="headerlink" title="10. 表达矩阵样本的相关性"></a>10. 表达矩阵样本的相关性</h2><p>看两个变量的相关性<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; cor(1:10,1:10)</span><br><span class="line">[1] 1</span><br><span class="line">&gt; a = rnorm(10)</span><br><span class="line">&gt; b = rnorm(10)</span><br><span class="line">&gt; cor(a,b)</span><br><span class="line">[1] -0.1555608</span><br><span class="line">&gt; a = rnorm(10)</span><br><span class="line">&gt; b = 10*a+rnorm(10)</span><br><span class="line">&gt; cor(a,b)</span><br><span class="line">[1] 0.9971822</span><br></pre></td></tr></table></figure><br>R包分类</p>
<p>数据包（加载数据）</p>
<p>view()<br>dim() #看维度</p>
<p>功能函数包</p>
<p>注释包（各种芯片、基因间转换）</p>
<p>知道代码背后的结构是啥，知道啥啥意思</p>
<h2 id="11-芯片表达矩阵下游分析流程"><a href="#11-芯片表达矩阵下游分析流程" class="headerlink" title="11. 芯片表达矩阵下游分析流程"></a>11. 芯片表达矩阵下游分析流程</h2><p>表达矩阵/分组信息</p>
<p>DEG by Lima</p>
<p>加入了回归相关的校验</p>
<p>构造比较矩阵</p>
<p>画火山图</p>
<p>挑选变化比较大大基因</p>
<p>富集分析</p>
<h2 id="12-RNA-seq表达矩阵差异分析"><a href="#12-RNA-seq表达矩阵差异分析" class="headerlink" title="12. RNA-seq表达矩阵差异分析"></a>12. RNA-seq表达矩阵差异分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">芯片的表达矩阵  exprSet = exprs(sCLLex)</span><br><span class="line">RNA-seq表达矩阵 exprSet = assay(ariway)  # assay获取表达矩阵</span><br><span class="line">#对象时一锅粥都有，用@符号表示，用$符号来取，用大的包来分析</span><br><span class="line">大部分包从基础变量开始，变量为矩阵、数据框、列表、数组、</span><br><span class="line">exprSet[1:4,1:4]</span><br><span class="line">boxplot(log(exprSet+1))  # normalization的一种方式</span><br><span class="line"></span><br><span class="line">两种写包的流派</span><br><span class="line"></span><br><span class="line">包装越好，越合适初学者用</span><br><span class="line"></span><br><span class="line">尽量不用任何高级的东西，纯粹自己写</span><br><span class="line"></span><br><span class="line">RNA-Seq  NES分析</span><br><span class="line"></span><br><span class="line">分析方法</span><br><span class="line"></span><br><span class="line">法一：DESeq2</span><br><span class="line"></span><br><span class="line">多个探针对应同一个基因取最大表达量探针极简代码【http://www.bio-info-trainee.com/3693.html】</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>Statistical Rethinking统计学反思(1章节总结)</title>
    <url>/2020/07/14/2020-07-14-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%8F%8D%E6%80%9D-00-%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近专注于贝叶斯方法的学习，发现在强化学习领域有一本入门书籍，统计学反思<br>未来时间会将这本书的学习笔记持续上传至我的博客等地方</p>
<h1 id="Statistical-Rethinking"><a href="#Statistical-Rethinking" class="headerlink" title="Statistical Rethinking"></a>Statistical Rethinking</h1><h2 id="1-布拉格魔像The-Golem-of-Prague"><a href="#1-布拉格魔像The-Golem-of-Prague" class="headerlink" title="1.布拉格魔像The Golem of Prague"></a>1.布拉格魔像The Golem of Prague</h2><h3 id="统计魔像"><a href="#统计魔像" class="headerlink" title="统计魔像"></a>统计魔像</h3><h3 id="统计反思"><a href="#统计反思" class="headerlink" title="统计反思"></a>统计反思</h3><h3 id="魔像工具"><a href="#魔像工具" class="headerlink" title="魔像工具"></a>魔像工具</h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h2 id="2-Small-Worlds-and-Large-Worlds"><a href="#2-Small-Worlds-and-Large-Worlds" class="headerlink" title="2.Small Worlds and Large Worlds"></a>2.Small Worlds and Large Worlds</h2><h3 id="分叉的数据花园"><a href="#分叉的数据花园" class="headerlink" title="分叉的数据花园"></a>分叉的数据花园</h3><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><h3 id="模型组成"><a href="#模型组成" class="headerlink" title="模型组成"></a>模型组成</h3><h3 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h3><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h2 id="3-Sampling-the-Imaginary想象中的采样"><a href="#3-Sampling-the-Imaginary想象中的采样" class="headerlink" title="3.Sampling the Imaginary想象中的采样"></a>3.Sampling the Imaginary想象中的采样</h2><h3 id="网格近似后采样Sampling-from-a-grid-approximate-posterior"><a href="#网格近似后采样Sampling-from-a-grid-approximate-posterior" class="headerlink" title="网格近似后采样Sampling from a grid-approximate posterior"></a>网格近似后采样Sampling from a grid-approximate posterior</h3><h3 id="Sampling-to-summarize采样总结"><a href="#Sampling-to-summarize采样总结" class="headerlink" title="Sampling to summarize采样总结"></a>Sampling to summarize采样总结</h3><h3 id="Sampling-to-simulate-prediction抽样模拟预测"><a href="#Sampling-to-simulate-prediction抽样模拟预测" class="headerlink" title="Sampling to simulate prediction抽样模拟预测"></a>Sampling to simulate prediction抽样模拟预测</h3><h2 id="4-Geocentric-Models地心模型"><a href="#4-Geocentric-Models地心模型" class="headerlink" title="4.Geocentric Models地心模型"></a>4.Geocentric Models地心模型</h2><h3 id="为什么分布是正态"><a href="#为什么分布是正态" class="headerlink" title="为什么分布是正态"></a>为什么分布是正态</h3><h3 id="用于描述模型的语言"><a href="#用于描述模型的语言" class="headerlink" title="用于描述模型的语言"></a>用于描述模型的语言</h3><h3 id="高斯高度模型Gaussian-model-of-height"><a href="#高斯高度模型Gaussian-model-of-height" class="headerlink" title="高斯高度模型Gaussian model of height"></a>高斯高度模型Gaussian model of height</h3><h3 id="线性预测Linear-prediction"><a href="#线性预测Linear-prediction" class="headerlink" title="线性预测Linear prediction"></a>线性预测Linear prediction</h3><h3 id="直线曲线Curves-from-lines"><a href="#直线曲线Curves-from-lines" class="headerlink" title="直线曲线Curves from lines"></a>直线曲线Curves from lines</h3><h2 id="5-众多变数和虚假的假说"><a href="#5-众多变数和虚假的假说" class="headerlink" title="5.众多变数和虚假的假说"></a>5.众多变数和虚假的假说</h2><h3 id="虚假联想Spurious-association"><a href="#虚假联想Spurious-association" class="headerlink" title="虚假联想Spurious association"></a>虚假联想Spurious association</h3><h3 id="蒙面关系Masked-relationship"><a href="#蒙面关系Masked-relationship" class="headerlink" title="蒙面关系Masked relationship"></a>蒙面关系Masked relationship</h3><h3 id="分类变量Categorical-variables"><a href="#分类变量Categorical-variables" class="headerlink" title="分类变量Categorical variables"></a>分类变量Categorical variables</h3><h2 id="6-闹鬼的DAG与因果的恐怖"><a href="#6-闹鬼的DAG与因果的恐怖" class="headerlink" title="6.闹鬼的DAG与因果的恐怖"></a>6.闹鬼的DAG与因果的恐怖</h2><h3 id="多重共线性"><a href="#多重共线性" class="headerlink" title="多重共线性"></a>多重共线性</h3><h3 id="后处理偏差"><a href="#后处理偏差" class="headerlink" title="后处理偏差"></a>后处理偏差</h3><h3 id="面对混杂"><a href="#面对混杂" class="headerlink" title="面对混杂"></a>面对混杂</h3><h2 id="7-尤利西斯的指南针"><a href="#7-尤利西斯的指南针" class="headerlink" title="7.尤利西斯的指南针"></a>7.尤利西斯的指南针</h2><h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><h3 id="商和精度"><a href="#商和精度" class="headerlink" title="商和精度"></a>商和精度</h3><h3 id="Golem驯服：正则化"><a href="#Golem驯服：正则化" class="headerlink" title="Golem驯服：正则化"></a>Golem驯服：正则化</h3><h3 id="预测预测准确性"><a href="#预测预测准确性" class="headerlink" title="预测预测准确性"></a>预测预测准确性</h3><h3 id="模型比较"><a href="#模型比较" class="headerlink" title="模型比较"></a>模型比较</h3><h2 id="8-有条件的海牛"><a href="#8-有条件的海牛" class="headerlink" title="8.有条件的海牛"></a>8.有条件的海牛</h2><h3 id="建立互动"><a href="#建立互动" class="headerlink" title="建立互动"></a>建立互动</h3><h3 id="相互作用的对称性"><a href="#相互作用的对称性" class="headerlink" title="相互作用的对称性"></a>相互作用的对称性</h3><h3 id="持续互动"><a href="#持续互动" class="headerlink" title="持续互动"></a>持续互动</h3><h2 id="9-MCMC"><a href="#9-MCMC" class="headerlink" title="9.MCMC"></a>9.MCMC</h2><h3 id="好马尔可夫国王和他的岛屿王国"><a href="#好马尔可夫国王和他的岛屿王国" class="headerlink" title="好马尔可夫国王和他的岛屿王国"></a>好马尔可夫国王和他的岛屿王国</h3><h3 id="Metropolis算法"><a href="#Metropolis算法" class="headerlink" title="Metropolis算法"></a>Metropolis算法</h3><h3 id="哈密尔顿蒙特卡洛"><a href="#哈密尔顿蒙特卡洛" class="headerlink" title="哈密尔顿蒙特卡洛"></a>哈密尔顿蒙特卡洛</h3><h3 id="简易HMC：乌拉姆"><a href="#简易HMC：乌拉姆" class="headerlink" title="简易HMC：乌拉姆"></a>简易HMC：乌拉姆</h3><h3 id="保养和喂养您的马尔可夫链"><a href="#保养和喂养您的马尔可夫链" class="headerlink" title="保养和喂养您的马尔可夫链"></a>保养和喂养您的马尔可夫链</h3><h2 id="10-大熵和广义线性模型的最大熵"><a href="#10-大熵和广义线性模型的最大熵" class="headerlink" title="10.大熵和广义线性模型的最大熵"></a>10.大熵和广义线性模型的最大熵</h2><h3 id="最大熵"><a href="#最大熵" class="headerlink" title="最大熵"></a>最大熵</h3><h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><h3 id="最大熵先验"><a href="#最大熵先验" class="headerlink" title="最大熵先验"></a>最大熵先验</h3><h2 id="11-上帝刺破整数"><a href="#11-上帝刺破整数" class="headerlink" title="11.上帝刺破整数"></a>11.上帝刺破整数</h2><h3 id="二项式回归"><a href="#二项式回归" class="headerlink" title="二项式回归"></a>二项式回归</h3><h3 id="泊松回归"><a href="#泊松回归" class="headerlink" title="泊松回归"></a>泊松回归</h3><h3 id="多项模型和分类模型"><a href="#多项模型和分类模型" class="headerlink" title="多项模型和分类模型"></a>多项模型和分类模型</h3><h2 id="12-怪物和混合物"><a href="#12-怪物和混合物" class="headerlink" title="12.怪物和混合物"></a>12.怪物和混合物</h2><h3 id="过度分散计数"><a href="#过度分散计数" class="headerlink" title="过度分散计数"></a>过度分散计数</h3><h3 id="零膨胀结果"><a href="#零膨胀结果" class="headerlink" title="零膨胀结果"></a>零膨胀结果</h3><h3 id="有序分类结果"><a href="#有序分类结果" class="headerlink" title="有序分类结果"></a>有序分类结果</h3><h3 id="有序的分类预测变量"><a href="#有序的分类预测变量" class="headerlink" title="有序的分类预测变量"></a>有序的分类预测变量</h3><h2 id="13-带内存的模型"><a href="#13-带内存的模型" class="headerlink" title="13.带内存的模型"></a>13.带内存的模型</h2><h3 id="示例：多级t"><a href="#示例：多级t" class="headerlink" title="示例：多级t"></a>示例：多级t</h3><h3 id="变化的影响和欠拟合-过拟合的折衷"><a href="#变化的影响和欠拟合-过拟合的折衷" class="headerlink" title="变化的影响和欠拟合/过拟合的折衷"></a>变化的影响和欠拟合/过拟合的折衷</h3><h3 id="集群不止一种"><a href="#集群不止一种" class="headerlink" title="集群不止一种"></a>集群不止一种</h3><h3 id="发散过渡和非中心先验"><a href="#发散过渡和非中心先验" class="headerlink" title="发散过渡和非中心先验"></a>发散过渡和非中心先验</h3><h3 id="多层次后验预测"><a href="#多层次后验预测" class="headerlink" title="多层次后验预测"></a>多层次后验预测</h3><h2 id="14-协方差冒险"><a href="#14-协方差冒险" class="headerlink" title="14.协方差冒险"></a>14.协方差冒险</h2><h3 id="因建筑而异的坡度"><a href="#因建筑而异的坡度" class="headerlink" title="因建筑而异的坡度"></a>因建筑而异的坡度</h3><h3 id="先进的变化坡度"><a href="#先进的变化坡度" class="headerlink" title="先进的变化坡度"></a>先进的变化坡度</h3><h3 id="仪器和因果设计"><a href="#仪器和因果设计" class="headerlink" title="仪器和因果设计"></a>仪器和因果设计</h3><h3 id="社会关系的相关变化影响"><a href="#社会关系的相关变化影响" class="headerlink" title="社会关系的相关变化影响"></a>社会关系的相关变化影响</h3><h3 id="连续类别和高斯过程"><a href="#连续类别和高斯过程" class="headerlink" title="连续类别和高斯过程"></a>连续类别和高斯过程</h3><h2 id="15-丢失数据和其他机会"><a href="#15-丢失数据和其他机会" class="headerlink" title="15.丢失数据和其他机会"></a>15.丢失数据和其他机会</h2><h3 id="测量误差"><a href="#测量误差" class="headerlink" title="测量误差"></a>测量误差</h3><h3 id="缺少数据"><a href="#缺少数据" class="headerlink" title="缺少数据"></a>缺少数据</h3><h3 id="分类错误和离散缺勤"><a href="#分类错误和离散缺勤" class="headerlink" title="分类错误和离散缺勤"></a>分类错误和离散缺勤</h3><h2 id="16-广义线性疯狂"><a href="#16-广义线性疯狂" class="headerlink" title="16.广义线性疯狂"></a>16.广义线性疯狂</h2><h3 id="几何人物"><a href="#几何人物" class="headerlink" title="几何人物"></a>几何人物</h3><h3 id="隐藏的思想和观察到的行为"><a href="#隐藏的思想和观察到的行为" class="headerlink" title="隐藏的思想和观察到的行为"></a>隐藏的思想和观察到的行为</h3><h3 id="普通差速器螺母开裂"><a href="#普通差速器螺母开裂" class="headerlink" title="普通差速器螺母开裂"></a>普通差速器螺母开裂</h3><h3 id="人口动态"><a href="#人口动态" class="headerlink" title="人口动态"></a>人口动态</h3><p><img src="/img/stat/1600487777220-Statistical Rethinking.png" alt="1600487777220-Statistical Rethinking.png"></p>
]]></content>
      <tags>
        <tag>统计学反思</tag>
      </tags>
  </entry>
  <entry>
    <title>体细胞calling 算法综述</title>
    <url>/2020/07/14/2020-08-11-%E4%BD%93%E7%BB%86%E8%83%9Ecalling%20%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="体细胞calling-算法综述-somatic-single-nucleotide-variant-calling-algorithms"><a href="#体细胞calling-算法综述-somatic-single-nucleotide-variant-calling-algorithms" class="headerlink" title="体细胞calling 算法综述 somatic single nucleotide variant calling algorithms"></a>体细胞calling 算法综述 somatic single nucleotide variant calling algorithms</h1><h2 id="paper基本信息"><a href="#paper基本信息" class="headerlink" title="paper基本信息"></a>paper基本信息</h2><p>paper name：<br>A review of somatic single nucleotide variant calling algorithms for next-generation sequencing data<br>doi :10.1016/j.csbj.2018.01.003</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call 变异的主要步骤为 mapping -&gt; call 变异<br>mapping 的DNA工具主要为BWA RNA 工具为star<br>本文着重介绍了目前市面上的call变异的工具的原理<br>算法可以归纳为四类: 匹配肿瘤正常变异、单样本变异、基于 umi 的变异和 RNA-seq 变异</p>
<h2 id="详细介绍一些算法"><a href="#详细介绍一些算法" class="headerlink" title="详细介绍一些算法"></a>详细介绍一些算法</h2><ul>
<li>1.预处理</li>
</ul>
<p>预处理的主要目的是防止低质量的读取进入不同的评价过程。读取质量通常是通过平均基础质量得分、mapping质量得分和参考基因组的错配次数等来衡量的</p>
<p>gatkindelrealigner 和 BQSR (基准质量得分重新校准)</p>
<p>-提高识别插入的准确性<br>samtools 与 picard </p>
<p>-去除PCR重复(但在基于 pcr 的扩增序列测序应用中，不推荐使用这种方法，因为不同的 DNA 片段可以共享相同的基因组坐标。此步骤中还包括降采样，在此期间随机选择读取的子集以继续进行下一步。如果在特定区域进行降采样，则可以节省计算时间并提高覆盖的一致性，但也会使结果不确定。)</p>
<ul>
<li>2.call 变异</li>
</ul>
<p>各种软件使用各自的算法call 变异</p>
<ul>
<li>3.后期筛选处理</li>
</ul>
<p>测序有些情况会欺骗统计模型将它们作为真正的变异传递。大多数变量调用方应用阈值来识别这些位置，从而提高特异性。例如，链偏置过滤，捕获只有或主要观察到一条链的读数，在 Illumina 公司的一个常见错误读，链偏好过滤器依赖于fisher，以确定不平衡的链分布。许多过滤器集中于重复区域，如homopolymer, microsatellite, or low complexity regions，这些区域已知会由于排列和排序错误而导致错误。硬过滤器用于大多数变异调用者，要么完全拒绝某些区域的变异，要么依赖于经验硬阈值。</p>
<ul>
<li>4.匹配正常肿瘤来call 变异</li>
</ul>
<h2 id="下面介绍一下文章中介绍的各个软件的原理"><a href="#下面介绍一下文章中介绍的各个软件的原理" class="headerlink" title="下面介绍一下文章中介绍的各个软件的原理"></a>下面介绍一下文章中介绍的各个软件的原理</h2><p>其基本思想是利用肿瘤鉴定潜在的变异，并利用匹配的正常样本区分体细胞变异和germline变异丢失(LOH)。<br>VarScan2、 qSNP、 Shimmer、 RADIA、 SOAPsnv 和 VarDict<br>对于一个潜在的 SNV，VarScan2需要至少两个支持读操作和8% 的 VAF (可由用户调整)。其他call 变异软件在他们的算法中有类似的阈值，这些阈值通常设置在一般 NGS 数据的噪声水平之上，并且期望过滤掉低水平的人为影响。接下来，在匹配的正常情况下分析潜在的 SNV 位点，以过滤掉非体细胞变异。2，Shimmer，SOAPsnv，和 VarDict 应用 Fisher 的精确测试22列联表的读数(参考值、非参考值和肿瘤值、正常值)。一个小的 p 值表明非参考读数不成比例地分布在两个样本中，因此提示体细胞变异。qSNP 和 RADIA 应用一系列启发式规则来标记在肿瘤中被充分观察到但在正常情况下弱或未被观察到的体细胞变异体。如果同一患者的 RNA-seq 数据可用，RADIA 将在综合分析中包括基因表达数据，以进一步减少假阳性。</p>
<p>联合基因型分析，SomaticSniper，FaSD-somatic，SAMtools，JointSNVMix2，Virmid，SNVSniffer，Seurat，和 CaVEMan 采用这种方式,假设肿瘤和正常的二倍体，并评估关节的可能性。突变calling是基因推理的必然结果。这些算法的核心是联合基因型的后验概率，由贝叶斯规则计算，即,</p>
<p><img src="/img/calling_mutation/1597125904751.png" alt="1597125904751.png"></p>
<p>其中GT、 GN 为肿瘤基因型，DT 为正常基因型，DN 为肿瘤和正常基因型。先验基因型概率 p (GT，GN)可能依赖于全基因组 SNP 率、体细胞突变率、 Ti-Tv 比值等。数据的联合似然 p (DT，DN | GT，GN)可以通过二项式概率计算，将覆盖一个站点的基地视为独立的伯努利试验，其成功概率取决于基因型和排序错误率。一旦连接基因型被推断出来，体细胞的变异就自然而然地发生了。突变和体细胞突变用“评分”概括了突变的证据，这实质上是肿瘤与正常人具有相同基因型的对数转化概率。其中GT∈{ AA，AC，AG，AT，CC，CG，CT，GG，GT，TT }。体细胞分数较高的部位在肿瘤和正常组织中更可能有不同的基因型，并被鉴定为可能的体细胞变异体。<br>SAMtools 采用了同样的策略，但没有使用后验概率，而是使用对数似然比作为变体评分。<br>JointSNVMix2，Virmid 和 SNVSniffer 将这10个外显基因型分解为 AA，AB 和 BB (a 为参考基因，b 为非参考基因) ，因此将联合基因型分解为33表。体细胞变异调用等价于计算 p (Somatic) = p (AA，AB) + p (AA，BB) ，肿瘤中正常和杂合或纯合非参照的纯合参照概率。具体来说，JointSNVMix2应用一个分层贝叶斯模型来估计联合基因型概率。<br>Virmid 将肿瘤视为正常组织和体细胞突变的混合物，提供了肿瘤中正常组织的联合基因型和比例的联合估计。<br>SNVsniffer 采用启发式和联合基因型分析的混合方法。启发式分析中的高可信体细胞变异被直接报道，低可信变异需要进一步的联合基因型概率估计检验。<br>CaVEMan 应用期望最大化算法估计基因型概率。</p>
<hr>
<p>由于肿瘤样本中存在罕见的异质亚克隆，二倍体假设可能过于简单。为了发现复杂肿瘤基因组中的变异，尤其是罕见亚克隆中的变异体，一些人放弃了二倍体假设和模型联合等位基因频率(fT，fN) ，而代之以联合基因型(GT，GN)。等位基因频率分析方法由斯 MuTect、 LoFreq、 EBCall、 deepSNV、 lololopicker 和 MuSE 使用。</p>
<p>MuTect 将体细胞变异调用定义为两个模型选择问题。在肿瘤方面，对两种模型进行了评价和比较: 野生型模型 M0和突变型模型 Mf，前者假定所有非参考读数均来自技术伪造，后者假定变异等位基因以未知频率存在。通过计算对数似然比(LOD score)来选择更好的拟合模型。潜在突变位点(高 LOD 值) ，另一个模型选择正常进行比较广型模型 M0和杂合子模型 M0.5。如果 M0强烈优于 M0.5，则该变异被标记为躯体变异。LoFreq、 EBCall、 deepSNV 和 lolololopicker 将调用的变量表示为一个假设检验问题，其中零假设是野生型的，替代假设是变异的，检验统计量是观察到的非参考读数 nT。</p>
<p>LoFreq 将每个基地视为一个独立的 Bernoulli 试验，具有不同的“成功”概率，其中成功被定义为非参考，而成功的概率由质量得分决定。在这种情况下，nT 服从泊松-二项分布，p 值可以作为观察到比 nT 更多的非参考读数的概率来计算。</p>
<p>由于已知体细胞变异在某些热点、序列上下文和非编码区域富集，所以 EBCall、 deepSNV 和 LoLoPicker 可以估计特定位点的错误率，因此可以在每个位点设置明确和更准确的检测限。尤其是，deepSNV 和 lololopicker 被设计用于调用具有目标测序数据的低频变异。和 deepSNV 并不依赖于质量分数来推断出错误率，而是假设在每个目标位置，错误率是一个随机变量，遵循一个 Β分布。在无效假设下，nT 遵循一个 β-二项式分布，并相应地计算 p 值。在 EBCall 中，Β分布参数是从其他独立控制样本的序列中获得的。在 deepSNV 中，利用肿瘤样本和正常样本进行参数估计。</p>
<p>LoLoPicker 也采用了类似的策略，但对站点特定的错误率假定为固定值进行了重要修改。对于福尔马林固定和石蜡包埋(FFPE)等低质量样品的变异调用，特定地点的错误率特别有用，因为与新鲜样品相比，这些地点之间的错误率更高，更不平衡。然而，估计特定地点的错误率需要对大量样本进行排序，这并不总是可行的。</p>
<p>MuSE 将体细胞 SNVs 视为 DNA 的结果，并用状态空间为 a，t，g，c 的连续时间马尔可夫过程建模。非参考等位基因的平衡频率比较样本特定的阈值从独立的公共数据集。</p>
<hr>
<p>基于单体类型的策略(相对于主流的基于位置的策略)被结构变异calling软件广泛采用，这些calling 软件需要将读取的内容组合起来以重建长变异。这也是Platypus、 HapMuC、 LocHap、 FreeBayes 和 mutett2使用的检测 SNV 的强大策略。这些算法在局部集合读取一个区域并生成候选单体类型，这些候选单体类型可以用 de Bruijn-like 图表示。每个单体类型的可能性是通过将每个读到的单体类型对齐并计算读支持度来估计的。基于单倍型的变异调用方在变异密集区域具有优势，因为它们不依赖于局部对齐，而局部对齐在困难区域是容易出错的。基于单倍型的调用方还提供了关于变体共存的额外信息。对于基于单体类型的调用方，indel 重新对齐不再有效，因为原始的本地对齐信息被丢弃，读操作被组装和重新对齐。</p>
<hr>
<p>机器学习方法在分类方面发展迅速，而变异调用本质上是一个分类问题。变异 seq，SomaticSeq，snoop 和 BAYSIC 是应用机器学习方法的典型变异调用方。变异 seq 提取每个站点的相关特征，并基于这些特征和一组“基本事实”的体细胞变体训练4个分类器(随机森林、贝叶斯自适应回归树、支持向量机和 Logit模型)。然后在测试数据集上测试训练后的分类器。</p>
<p>SNooPer 训练一个随机森林分类器，用于处理低覆盖率数据。</p>
<p>SomaticSeq 遵循相同的有监督的训练测试过程，但在两个方面不同于 MutationSeq 或 snoop。首先，采用自适应 boosting 算法进行分类。其次，它是一个集成变量调用程序，需要将来自其他软件(MuTect、 SomaticSniper、 VarScan2、 JointSNVMix2和 VarDict)的变量调用联合起来作为起点，然后应用自己的分类器去除假阳性。</p>
<p>BAYSIC 也是一个集合变量调用程序，它使用一个无监督的潜在类模型来组合多个调用。</p>
<div data-largeobj="" data-largeobj-link-rid="largeobj_idm139960369037184" class="xtable"><table frame="hsides" rules="groups" class="rendered small default_table"><thead><tr><th align="left" rowspan="1" colspan="1">Variant caller</th><th align="left" rowspan="1" colspan="1">Type of variant</th><th align="left" rowspan="1" colspan="1">Single-sample mode</th><th align="left" rowspan="1" colspan="1">Type of core algorithm</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">BAYSIC&nbsp;<a href="/pmc/articles/PMC5852328/#bb0240" rid="bb0240" class=" bibr" target="mainwindow">[48]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Machine learning (ensemble caller)</td></tr><tr><td align="left" rowspan="1" colspan="1">CaVEMan&nbsp;<a href="/pmc/articles/PMC5852328/#bb0170" rid="bb0170" class=" bibr" target="mainwindow">[34]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">deepSNV&nbsp;<a href="/pmc/articles/PMC5852328/#bb0190" rid="bb0190" class=" bibr" target="mainwindow">[38]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">EBCall&nbsp;<a href="/pmc/articles/PMC5852328/#bb0185" rid="bb0185" class=" bibr" target="mainwindow">[37]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">FaSD-somatic&nbsp;<a href="/pmc/articles/PMC5852328/#bb0155" rid="bb0155" class=" bibr" target="mainwindow">[31]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">FreeBayes&nbsp;<a href="/pmc/articles/PMC5852328/#bb0220" rid="bb0220" class=" bibr" target="mainwindow">[44]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Haplotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">HapMuC&nbsp;<a href="/pmc/articles/PMC5852328/#bb0210" rid="bb0210" class=" bibr" target="mainwindow">[42]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Haplotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">JointSNVMix2&nbsp;<a href="/pmc/articles/PMC5852328/#bb0150" rid="bb0150" class=" bibr" target="mainwindow">[30]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">LocHap&nbsp;<a href="/pmc/articles/PMC5852328/#bb0215" rid="bb0215" class=" bibr" target="mainwindow">[43]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Haplotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">LoFreq&nbsp;<a href="/pmc/articles/PMC5852328/#bb0180" rid="bb0180" class=" bibr" target="mainwindow">[36]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">LoLoPicker&nbsp;<a href="/pmc/articles/PMC5852328/#bb0195" rid="bb0195" class=" bibr" target="mainwindow">[39]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">MutationSeq&nbsp;<a href="/pmc/articles/PMC5852328/#bb0225" rid="bb0225" class=" bibr" target="mainwindow">[45]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Machine learning</td></tr><tr><td align="left" rowspan="1" colspan="1">MuSE&nbsp;<a href="/pmc/articles/PMC5852328/#bb0200" rid="bb0200" class=" bibr" target="mainwindow">[40]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Markov chain model</td></tr><tr><td align="left" rowspan="1" colspan="1">MuTect&nbsp;<a href="/pmc/articles/PMC5852328/#bb0175" rid="bb0175" class=" bibr" target="mainwindow">[35]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">SAMtools&nbsp;<a href="/pmc/articles/PMC5852328/#bb0040" rid="bb0040" class=" bibr" target="mainwindow">[8]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">Platypus&nbsp;<a href="/pmc/articles/PMC5852328/#bb0205" rid="bb0205" class=" bibr" target="mainwindow">[41]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel, SV</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Haplotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">qSNP&nbsp;<a href="/pmc/articles/PMC5852328/#bb0120" rid="bb0120" class=" bibr" target="mainwindow">[24]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">RADIA&nbsp;<a href="/pmc/articles/PMC5852328/#bb0130" rid="bb0130" class=" bibr" target="mainwindow">[26]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">Seurat&nbsp;<a href="/pmc/articles/PMC5852328/#bb0165" rid="bb0165" class=" bibr" target="mainwindow">[33]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel, SV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">Shimmer&nbsp;<a href="/pmc/articles/PMC5852328/#bb0125" rid="bb0125" class=" bibr" target="mainwindow">[25]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">SNooPer&nbsp;<a href="/pmc/articles/PMC5852328/#bb0235" rid="bb0235" class=" bibr" target="mainwindow">[47]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Machine learning</td></tr><tr><td align="left" rowspan="1" colspan="1">SNVSniffer&nbsp;<a href="/pmc/articles/PMC5852328/#bb0160" rid="bb0160" class=" bibr" target="mainwindow">[32]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">SOAPsnv&nbsp;<a href="/pmc/articles/PMC5852328/#bb0135" rid="bb0135" class=" bibr" target="mainwindow">[27]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">SomaticSeq&nbsp;<a href="/pmc/articles/PMC5852328/#bb0230" rid="bb0230" class=" bibr" target="mainwindow">[46]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Machine learning (ensemble caller)</td></tr><tr><td align="left" rowspan="1" colspan="1">SomaticSniper&nbsp;<a href="/pmc/articles/PMC5852328/#bb0140" rid="bb0140" class=" bibr" target="mainwindow">[28]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">Strelka&nbsp;<a href="/pmc/articles/PMC5852328/#bb0085" rid="bb0085" class=" bibr" target="mainwindow">[17]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Allele frequency analysis</td></tr><tr><td align="left" rowspan="1" colspan="1">TVC&nbsp;<a href="/pmc/articles/PMC5852328/#bb0485" rid="bb0485" class=" bibr" target="mainwindow">[97]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel, SV</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Ion Torrent specific</td></tr><tr><td align="left" rowspan="1" colspan="1">VarDict&nbsp;<a href="/pmc/articles/PMC5852328/#bb0090" rid="bb0090" class=" bibr" target="mainwindow">[18]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel, SV</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">VarScan2&nbsp;<a href="/pmc/articles/PMC5852328/#bb0045" rid="bb0045" class=" bibr" target="mainwindow">[9]</a></td><td align="left" rowspan="1" colspan="1">SNV, indel</td><td align="left" rowspan="1" colspan="1">Yes</td><td align="left" rowspan="1" colspan="1">Heuristic threshold</td></tr><tr><td align="left" rowspan="1" colspan="1">Virmid&nbsp;<a href="/pmc/articles/PMC5852328/#bb0145" rid="bb0145" class=" bibr" target="mainwindow">[29]</a></td><td align="left" rowspan="1" colspan="1">SNV</td><td align="left" rowspan="1" colspan="1">No</td><td align="left" rowspan="1" colspan="1">Joint genotype analysis</td></tr></tbody></table></div>]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学反思-01-贝叶斯建模</title>
    <url>/2021/02/05/2021-10-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-01-MDPs/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="强化学习入门基础-马尔达夫决策过程（MDP）"><a href="#强化学习入门基础-马尔达夫决策过程（MDP）" class="headerlink" title="强化学习入门基础-马尔达夫决策过程（MDP）"></a>强化学习入门基础-马尔达夫决策过程（MDP）</h1><blockquote>
<p>作者：YJLAugus  博客： <a href="https://www.cnblogs.com/yjlaugus">https://www.cnblogs.com/yjlaugus</a> 项目地址：<a href="https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star">https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star</a>。</p>
</blockquote>
<h2 id="MDP背景介绍"><a href="#MDP背景介绍" class="headerlink" title="MDP背景介绍"></a>MDP背景介绍</h2><h3 id="Random-Variable"><a href="#Random-Variable" class="headerlink" title="Random Variable"></a>Random Variable</h3><p><strong>随机变量（Random Variable）</strong>，通常用大写字母来表示一个随机事件。比如看下面的例子：</p>
<p>$X$: 河水是咸的</p>
<p>$Y$: 井水是甜的</p>
<p>很显然，$X$, $Y$两个随机事件是没有关系的。也就是说$X$和$Y$之间<strong>是相互独立</strong>的。记作：</p>
<script type="math/tex; mode=display">
\large
X \bot Y</script><h3 id="Stochastic-Process"><a href="#Stochastic-Process" class="headerlink" title="Stochastic Process"></a>Stochastic Process</h3><p>对于一类随机变量来说，它们之间存在着某种关系。比如：</p>
<p>$S<em>{t}$：表示在 $t$ 时刻某支股票的价格，那么 $S</em>{t+1}$ 和 $S_t$ 之间一定是有关系的，至于具体什么样的关系，这里原先不做深究，但有一点可以确定，两者之间一定存在的一种关系。随着时间 $t$ 的变化，可以写出下面的形式：</p>
<script type="math/tex; mode=display">
\large
...S_t, S_{t+1},S_{t+2}...</script><p>这样就生成了一组随机变量，它们之间存在着一种相当复杂的关系，也就是说，各个随机变量之间存在着关系，即不相互独立。由此，我们会把按照某个时间或者次序上的一组不相互独立的随机变量的这样一个整体作为研究对象。这样的话，也就引出了另外的一个概念：<strong>随机过程（Stochastic Process）</strong>。也就是说随机过程的研究对象不在是单个的随机变量，而是一组随机变量，并且这一组随机变量之间存在着一种非常紧密的关系（不相互独立）。记作：</p>
<script type="math/tex; mode=display">
\large
\lbrace S_t \rbrace ^\infty_{t=1}</script><h3 id="Markov-Chain-Process"><a href="#Markov-Chain-Process" class="headerlink" title="Markov Chain/Process"></a>Markov Chain/Process</h3><p><strong>马尔科夫链（Markov Chain）</strong>即马尔可夫过程，是一种特殊的随机过程——具备马尔可夫性的随机过程。</p>
<ul>
<li>马尔可夫性：（Markov Property）: 还是上面股票的例子，如果满足 $P(S<em>{t+1} \mid S_t,S</em>{t-1}…S<em>1) = P(S</em>{t+1}\mid S<em>t)$，即具备了马尔可夫性。简单来说，$S</em>{t+1}$ 和$S_t$之间存在关系，和以前的时刻的没有关系，即只和“最近的状态” 有关系。</li>
<li>现实例子：下一个时刻仅依赖于当前时刻，跟过去无关。比如：一个老师讲课，明天的讲课状态一定和今天的状态最有关系，和过去十年的状态基本就没关系了。</li>
<li>最主要考量：为了简化计算。$P(S<em>{t+1} \mid S_t,S</em>{t-1}…S<em>1) = P(S</em>{t+1}\mid S<em>t)$ 如果 $S</em>{t+1}$ 和 $S<em>t,S</em>{t-1}…S_1$ 都有关系的话，计算的话就会爆炸了。</li>
</ul>
<p>马尔可夫链/过程 即满足马尔可夫性质的随机过程，记作：</p>
<script type="math/tex; mode=display">
\large P(S_{t+1}) \mid S_t,S_{t-1}...S_1) = P(S_{t+1}\mid S_t)</script><h3 id="State-Space-Model"><a href="#State-Space-Model" class="headerlink" title="State Space Model"></a>State Space Model</h3><p><strong>状态空间模型（State Space Model）</strong>，常应用于 HMM,Kalman Filterm Particle Filter，关于这几种这里不做讨论。在这里就是指马尔可夫链 + 观测变量，即<code>Markov Chain + Obervation</code></p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/spm.svg" alt="spm"></p>
<p>如上图所示，s1-s2-s3为马尔可夫链，a1, a2, a3为观测变量，以a2为例，a2只和s2有关和s1, s3无关。状态空间模型可以说是由马尔可夫链演化而来的模型。记作：</p>
<center>Markov Chain + Obervation</center>

<h3 id="Markov-Reward-Process"><a href="#Markov-Reward-Process" class="headerlink" title="Markov Reward Process"></a>Markov Reward Process</h3><p><strong>马尔可夫奖励过程（Markov Reward Process）</strong>，即马尔可夫链+奖励，即：<code>Markov Chain + Reward</code>。如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/reward.svg" alt="图片描述"></p>
<p>举个例子，比如说你买了一支股票，然后你每天就会有“收益”，当然了这里的收益是泛化的概念，收益有可能是正的，也有可能是负的，有可能多，有可能少，总之从今天的状态$S<em>t$ 到明天的状态 $S</em>{s+1}$  ，会有一个<code>reward</code>。记作：</p>
<center>Markov Chain + Reward</center>

<h3 id="Markov-Decision-Process"><a href="#Markov-Decision-Process" class="headerlink" title="Markov Decision Process"></a>Markov Decision Process</h3><p><strong>马尔可夫决策过程（Markov Decision Process）</strong>，即马尔可夫奖励过程的基础上加上<code>action</code>，即：<code>Markov Chain + Reward + action</code>。如果还用刚才的股票为例子的话，我们只能每天看到股票价格的上涨或者下降，然后看到自己的收益，但是无法操作股票的价格的，只有看到份，只是一个“小散户”。这里的马尔可夫决策过程相当于政策的制定者，相当于一个操盘手，可以根据不同的状态而指定一些政策，也就相当于 action。</p>
<p>在马尔可夫决策过程中，所有的<strong>状态</strong>是我们看成离散的，有限的集合。所有的<strong>行为</strong>也是离散有限的集合。记作：</p>
<script type="math/tex; mode=display">
\large
\enclose{box}{
\it S: \quad state \quad set \quad \quad \quad\quad\quad\quad\quad\quad\quad\quad S_t \\
\it A: \quad action \quad set ,\quad \quad \forall s \in S,A_{(s)} \quad\quad A_t\\
\it R: \quad reward \quad set \quad\quad\quad\quad\quad\quad\quad\quad\quad R_t, R_{(t+1)} \\
}</script><p>对于上述公式简单说明，$S<em>t$ 用来表示某一个时刻的状态。$A</em>{(s)}$ 表示在<strong>某一个状态</strong>时候的行为 ，这个行为一定是基于某个状态而言的，假设在$t$ 时刻的状态为$S$ 此时的<code>action</code>记作 $A<em>t$ 。$R_t 和 R</em>{(t+1)}$ 只是记法不同，比如下面的例子：从$S<em>t$状态经过 $A_t$ 到$S</em>{t+1}$状态，获得的奖励一般记作$R<em>{(t+1)}$。 也就是说$S_t$， $A_t$ ，$R</em>{(t+1)}$ 是配对使用的。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/coupleR.svg" alt=""></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/sum01.png" alt=""></p>
<h2 id="MDP动态特性"><a href="#MDP动态特性" class="headerlink" title="MDP动态特性"></a>MDP动态特性</h2><h3 id="Markov-Chain"><a href="#Markov-Chain" class="headerlink" title="Markov Chain"></a>Markov Chain</h3><p>马尔可夫链只有一个量——<strong>状态</strong>。比如 $S\in(s<em>1,s_2,s_3,s_4,s_5,s_6,s_7,s_8,s_9,s</em>{10})$ ，在状态集合中一共有十个状态，每个状态之间可以互相转化，即可以从一个状态转移到另外一个状态，当然，“另外的状态” 也有可能是当前状态本身。如下图所示，s1状态到可以转移到s2状态，s1状态也可以转移到自己当前的状态，当然s1也有可能转移到s3，s4，s5，状态，下图中没有给出。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/recg.svg" alt=""></p>
<p>根据上面的例子，我们可以把所有的状态写成矩阵的形式，就成了<strong>状态转移矩阵</strong>。用状态转移矩阵来描述马尔可夫链的<strong>动态特性</strong>。以上面的状态集合$S\in(s<em>1,s_2,s_3,s_4,s_5,s_6,s_7,s_8,s_9,s</em>{10})$ 为例，可得一个 $10\times10$ 的矩阵。如下图所示：</p>
<script type="math/tex; mode=display">
\large
\begin{bmatrix}
    s_1s_1 &... & s_1s_{10} \\
    \vdots & \vdots & \vdots \\

    s_{10}s_1  & ... & s_{10}s_{10}\\
\end{bmatrix}</script><p>由上面的例子可知，在状态转移的过程中，对于下一个状态转移是有概率的，比如说s1转移到到s1状态的概率可能是0.5，s1有0.3的概率转移到s2状态。⻢尔科夫过程是⼀个⼆元组（S， P） ， 且满⾜： <strong>S是有限状态集合， P是状态转移概率。</strong>   可得：</p>
<script type="math/tex; mode=display">
\large
P=
\begin{bmatrix}
    P_{11} &... & P_{1n} \\
    \vdots & \vdots & \vdots \\

    P_{n1}  & ... & P_{nn}\\
\end{bmatrix}</script><p>一个简单的例子：如图2.2所⽰为⼀个学⽣的7种状态{娱乐， 课程1， 课程2， 课程3， 考过， 睡觉， 论⽂}， 每种状态之间的转换概率如图所⽰。 则该⽣从课程 1 开始⼀天可能的状态序列为：  </p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201127124916367.png" alt="image-20201127124916367"></p>
<h3 id="MRP"><a href="#MRP" class="headerlink" title="MRP"></a>MRP</h3><p>在 MPR 中，打个比喻，更像是随波逐流的小船，没有人为的干预，小船可以在大海中随波逐流。</p>
<h3 id="MDP"><a href="#MDP" class="headerlink" title="MDP"></a>MDP</h3><p>在MDP中，打个比喻，更像是有人划的小船，这里相比较MRP中的小船来说，多了“人划船桨”的概念，可以认为控制船的走向。这里我们看下面的图：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/dymic1.svg" alt=""></p>
<p>s1状态到s2状态的过程，agent从s1发出action A1，使得s1状态转移到s2状态，并从s2状态得到一个R2的奖励。其实就是下图所示的一个过程。这是一个<strong>动态的过程</strong>，由此，引出<strong>动态函数</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201127132127738.png" alt="image-20201127132127738"></p>
<ul>
<li><p><strong>动态函数：</strong> The function $p$ defines the dynamics of the MDP.  这是书上的原话，也就说，这个动态函数定义了MDP的<code>动态特性</code>，动态函数如下：</p>
<script type="math/tex; mode=display">
\large
p(s',r\mid s,a) \dot{=} Pr\lbrace S_{t+1}=s',R_{t+1} = r \mid S_{t} =s,A_{t}=a \rbrace</script></li>
<li><p><strong>状态转移函数：</strong> 我们去掉 $r$ ，也就是<code>reward</code>，动态函数也就成了状态转移函数。</p>
</li>
</ul>
<script type="math/tex; mode=display">
\large{
p(s'\mid s,a) \dot{=} Pr\lbrace S_{t+1}=s',\mid S_{t} =s,A_{t}=a \rbrace \\
  p(s'\mid s,a) = \sum_{r\in R} p(s'\mid s,a)
  }</script><ul>
<li><strong><code>reward</code>的动态性：</strong> 在 s 和 a 选定后，r 也有可能是不同的，即 r 也是随机变量。但是，大多数情况在 s 和 a 选定后 r 是相同的，这里只做简单的介绍。</li>
</ul>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201127135356269.png" alt="image-20201127135356269"></p>
<h2 id="MDP价值函数"><a href="#MDP价值函数" class="headerlink" title="MDP价值函数"></a>MDP价值函数</h2><h3 id="策略的定义"><a href="#策略的定义" class="headerlink" title="策略的定义"></a>策略的定义</h3><p>在MDP中，即马尔可夫决策过程，最重要的当然是<strong>策略（Policy）</strong>，<strong>用 $\pi$ 来表示</strong>。在策略中其主要作用的就是<code>action</code>，也即 $A_t$，需要指出的一定是，action 一定是基于某一状态 S 时。看下面的例子：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/policy.svg" alt=""></p>
<p>即，当 $S_t = S$ 状态时，无论 $t$ 取何值，只要遇到 $S$ 状态就 选定 $a_1$ 这个 action ，这就是一种策略，并且是确定性策略。</p>
<h3 id="策略的分类"><a href="#策略的分类" class="headerlink" title="策略的分类"></a>策略的分类</h3><ul>
<li><p><strong>确定性策略：</strong>也就是说和时间 $t$ 已经没有关系了，只和这个状态有关，只要遇到这个状态，就做出这样的选择。</p>
</li>
<li><p><strong>随机性策略：</strong>与确定性策略相对，当遇到 $S$ 状态时，可能选择 $a_1$ ，可能选择 $a_2$，也可能选择 $a_3$。只是选择action的概率不同。如下图，就是<strong>两种不同</strong>的策略:</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/p1.svg" alt=""></p>
<p>从上面两天图中，因为一个策略是基于一个状态而言的，在 $S$ 状态，可能选择 $a_1$ ，可能选择 $a_2$，也可能选择 $a_3$，故三个 <code>action</code> 之间是<strong>或</strong>的关系，所以说以上是两个策略，而不要误以为是6个策略。</p>
</li>
</ul>
<p>故策略可分为确定性策略和随机性策略两种。</p>
<script type="math/tex; mode=display">
\large
Policy= \begin{cases} 确定性策略, & \text {a $\dot{=}\pi(s)$} \\ 随机性策略, & \text { $\pi(a\mid s) \dot{=} P \lbrace A_t=a \mid S_t = s \rbrace$} \end{cases}</script><p>对于随机性策略而言，给定一个 $s$ ，选择<strong>一个 $a$</strong> ，也就是条件概率了。</p>
<blockquote>
<p>确定性策略可以看作是一种特殊的随机性策略，以上表-Policy1为例，选择a1的概率为1，选择a2，a3的概率都为0。</p>
</blockquote>
<h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>在所有的策略中一定存在至少一个<strong>最优策略</strong>，而且在强化学习中，<code>reward</code>的获得有<strong>延迟性（delay）</strong>，举雅达利游戏中，很多游戏只有到结束的时候才会知道是否赢了或者输了，才会得到反馈，也就是<code>reward</code>，所以这就是奖励获得延迟。当选定一个状态 $S<em>t$ 时，选定action $A_t$ ，因为奖励延迟的原因可能对后续的 $S</em>{t+1}$  等状态都会产生影响。这样，就不能用当前的reward来衡量策略的好坏、优劣。这里引入了回报和价值函数的概念。</p>
<h4 id="回报（-G-t-）"><a href="#回报（-G-t-）" class="headerlink" title="回报（$G_t$）"></a>回报（$G_t$）</h4><p>而是后续多个reward的加和，也就是<strong>回报</strong>，用 $G_t$ 表示 $t$ 时刻的回报。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/optimp.svg" alt=""></p>
<p>如上图所示，此时的“回报”可以表示为：$G<em>t = R</em>{t+1} + R_{t+2}+ \ …\ +R_T$</p>
<p>值得注意的是，$T$ 可能是有限的，也有可能是无限的。</p>
<p>举例：张三对李四做了行为，对李四造成了伤害，李四在当天就能感受到伤害，而且，这个伤害明天，后头都还是有的，但是，时间是最好的良药，随着时间的推移，李四对于张三对自己造成的伤害感觉没有那么大了，会有一个wei折扣，用 $\gamma$ 来表示。故<strong>真正的回报</strong>表示为：</p>
<script type="math/tex; mode=display">
\large
G_t = R_{t+1} + \gamma R_{t+2}+\gamma^2 R_{t+3} \ ...\ +\gamma^{T-t-1}R_T = \sum_{i=0}^{\infty}\gamma^i R_{t+i+1} \quad \quad \gamma\in[0,1],\quad (T\rightarrow\infty)</script><p><strong>用 $G_t$ 来衡量一个策略的好坏，$G_t$ 大的策略就好，反之。</strong></p>
<p>但是使用 $G_t$ 也不能很好的衡量策略的好坏，比如一个最大的问题是，在给定一个状态后，选择一个确定的action后（这里还是在随机策略的角度），进入的下一个状态也是随机的。如下图所示：把左侧的过程放大，只给出a3下的随机状态，a1，a2也是有同样的情况，这里胜率。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/Gtlim.svg" alt=""></p>
<p>举个例子，就像我们给一盆花浇水，水是多了还是少了，对于这盆花来说我们是不得知的，可能会少，也可能会多。这个花的状态变化也就是随机的了。从上面的例子得知，如果还是用 $G_t$ 来对一个策略来进行评估的话，至少有9中情况（随机策略，3个action选一种）。</p>
<p>$G_t$ 只能评估的是一个“分叉”而已（图中<code>绿色分支</code>）。而不能更好的进行评估。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/merch.svg" alt=""></p>
<p>因为回报不能很好的对策略进行一个评估，由此引入了另外一个概念——价值函数。</p>
<h4 id="价值函数（Value-Function-）"><a href="#价值函数（Value-Function-）" class="headerlink" title="价值函数（Value Function ）"></a>价值函数（Value Function ）</h4><p>在指定一个状态 $s$ ，采取一个<code>随机策略</code>$\pi$ ，然后加权平均，以上图为例，把9 个分叉($G_t$)加权平均。也就是<strong>期望</strong> $E$。故得出价值函数：</p>
<script type="math/tex; mode=display">
\large
V_\pi(s) = E_\pi[G_t\mid S_t = s]</script><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201128110205095.png" alt="image-20201128110205095"></p>
<h2 id="MDP贝尔曼期望方程"><a href="#MDP贝尔曼期望方程" class="headerlink" title="MDP贝尔曼期望方程"></a>MDP贝尔曼期望方程</h2><h3 id="价值函数分类"><a href="#价值函数分类" class="headerlink" title="价值函数分类"></a>价值函数分类</h3><p>上面提到的的价值函数其实是其中的一种，确切的可以称为 <code>状态价值函数</code>，<strong>用$v_\pi(s)$ 来表示</strong>只和状态有关系。初次之外还有另外一种价值函数，那就是<code>状态动作价值函数</code>，用$q_\pi(s,a)$这里引入的<code>action</code>。故价值函数可以分为下面的两种:</p>
<script type="math/tex; mode=display">
Value \quad Function = \begin{cases} v_\pi(s) = E_\pi[G_t\mid S_t = s], & \text {only $s$ is independent variable} \\ q_\pi(s,a) = E_\pi[G_t\mid S_t = s,A_t = a], & \text{Both $s$ and a are independent variable} \end{cases}</script><p>从上面的公式中，我们可以得知，在 $v<em>\pi(s)$ 中，只有 $s$ 是自变量，一个 $\pi$ 其实就是一个状态$s$ 和一个action的一个映射。故，只要$\pi$ 确定了，那么$s,a$ 也就确定了，即此时的 $\pi$ 对状态 $s$ 是有限制作用的。但是，在 $q</em>\pi(s,a)$ 中，子变量为$s,a$ 两个，这两个自变量之间是没有特定的关系的。也就是说，$s$和$a$ 都在变，无法确定一个映射(策略) $\pi$ ,那么也就是说在 $q_\pi$ 中的$\pi$ 对于$s$ 是没有约束的。</p>
<h3 id="两种价值函数之间的关系"><a href="#两种价值函数之间的关系" class="headerlink" title="两种价值函数之间的关系"></a>两种价值函数之间的关系</h3><h4 id="v-pi-s-和-q-pi-s-a-之间的关系"><a href="#v-pi-s-和-q-pi-s-a-之间的关系" class="headerlink" title="$v\pi(s)$ 和 $q\pi(s,a)$ 之间的关系"></a>$v<em>\pi(s)$ 和 $q</em>\pi(s,a)$ 之间的关系</h4><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/Gtlim.svg" alt=""></p>
<p>还是以上图为例，对于 s 状态，在随机策略中有三种 action 选择，分别是 $\pi(a<em>1 \mid s)$，$\pi(a_1 \mid s)$，$\pi(a_1 \mid s)$，三种action(行为)对应的价值函数（此时为动作价值函数）为 $q</em>\pi(s,a<em>1)$， $q</em>\pi(s,a<em>2)$， $q</em>\pi(s,a<em>3)$。那么此时的 $v</em>\pi(s)$ 就等于各个action的动作状态价值函数的加和，即：</p>
<script type="math/tex; mode=display">
v_\pi(s) = \pi(a_1 \mid s)·q_\pi(s,a_1) +  \pi(a_2 \mid s)·q_\pi(s,a_2) +  \pi(a_3 \mid s)·q_\pi(s,a_3)</script><p>这样一来我们就得出了 <strong>$v<em>\pi(s)$ 和 $q</em>\pi(s,a)$ 之间的关系</strong>，若条件已知，就可以直接计算出 $v_\pi$。</p>
<script type="math/tex; mode=display">
\large
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) ·q_\pi(s,a)</script><p>对于某个状态 $s$ 来说，$v<em>\pi \leq \underset{a}{max}\ q</em>\pi(s,a)$ ，$v<em>\pi(s)$ 是一个加权平均，实际上就是一个平均值，当然要小于等于$\ q</em>\pi(s,a)$的最大值。$v_\pi(s)$只有全部是最大值的时候，两者才有可能相等。比如 5，5，5，平均值是5，最大值也是5；3，4，5而言，平均值为4，但是最大值为5。注意的是，4是乘上权值后的值，换句话说也就是乘了一个概率（$\pi(a\mid s)$）。</p>
<h4 id="q-pi-s-a-和-v-pi-s’-之间的关系"><a href="#q-pi-s-a-和-v-pi-s’-之间的关系" class="headerlink" title="$q\pi(s,a)$ 和 $v\pi(s’)$  之间的关系"></a>$q<em>\pi(s,a)$ 和 $v</em>\pi(s’)$  之间的关系</h4><p>从下面图中可得，在 $q<em>\pi(s,a)$ 位置，（一个action）状态转移只能向“箭头”方向转移，而不能向上。如果想从下面的状态转移到上面的状态，那必须还要另外一个action。情况是一样的，就按下图来说明，经过a3后到达状态s’，此时的状态函数就是 $v</em>\pi(s’）$。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss01.svg" alt="image-20201128134834753"></p>
<p>上面的图可知： 在确定了s 后，由随机策略action，引起“分叉”，同理，以a3为例，因为系统状态转移的随机性，也会引起分叉，也就是 s’ 的状态也是不确定的。还有一点 r 也又不确定性，如下图蓝色虚线部分。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss02.svg" alt="image-20201128135658979"></p>
<p>由我们前面提到的公式也可得知：s’ 和 r 都是随机的。比如说s，a ，s’ 都是给定的，r也是不确定的。</p>
<script type="math/tex; mode=display">
\large p(s',r\mid s,a) \dot{=} Pr\lbrace S_{t+1}=s',R_{t+1} = r \mid S_{t} =s,A_{t}=a \rbrace</script><p>这样一来，可得<strong>一条蓝色通路的回报</strong>：</p>
<script type="math/tex; mode=display">
\large
q_\pi(s,a) = r + \gamma v_\pi(s')  \quad\quad\quad (1)</script><p>(1)式是怎么来的呢？以上图为例，在 $q<em>\pi(s,a)$ 处往下走，选定一个 r ，再往下到达一个状态s’， 此时在往下还是同样的状态，就是俄罗斯套娃，以此类推。关于其中的 $\gamma v</em>\pi(s’) $ ，来自于 $G_t$。看下面的式子：</p>
<script type="math/tex; mode=display">
\large{
G_t = R_{t+1} + \gamma R_{t+2}+\gamma^2 R_{t+3} \ ...\ +\gamma^{T-t-1}R_T \quad\quad  \gamma\in[0,1],\quad (T\rightarrow\infty) \\
G_t = R_{t+1} + \gamma(R_{t+2}+\gamma R_{t+3}+\gamma^2 R_{t+4}+ ...)
}</script><p>因为 $v_\pi(s)$ 来自 $G_t$ ，故类比得（1）式。</p>
<p>因为走每条蓝色的通路也都是由概率的，故我们需要乘上概率，同时累加求和，一个是多条蓝色通路另一个是多个s’。故得：<strong>$q<em>\pi(s,a)$ 和 $v</em>\pi(s’)$ 之间的关系</strong> 如下：</p>
<script type="math/tex; mode=display">
\large
q_\pi(s,a) =\sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad\quad (2)</script><h3 id="贝尔曼期望等式（方程）"><a href="#贝尔曼期望等式（方程）" class="headerlink" title="贝尔曼期望等式（方程）"></a>贝尔曼期望等式（方程）</h3><p>这样我们得到两个式子：</p>
<script type="math/tex; mode=display">
\large{
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) ·q_\pi(s,a)  \quad\quad\quad\quad\quad\quad\quad\quad\ (3) \\

q_\pi(s,a) =\sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad\quad (4)
}</script><p>（4）式带入（3）得：</p>
<script type="math/tex; mode=display">
\large
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad\quad\quad\quad\quad (5)</script><p>（3）式带入（4）得：</p>
<script type="math/tex; mode=display">
\large
q_\pi(s,a) =\sum_{s',r}P[s',r \mid s,a](r+ \gamma \sum_{a'\in A} \pi(a'\mid s')  ·q_\pi(s',a') ) \quad\quad (6)</script><p>关于（6）式可以看下图，更容易理解：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss03.svg" alt=""></p>
<p>（5）式和（6）式 被称为<strong>贝尔曼期望方程</strong>。</p>
<ul>
<li><p>一个实例：</p>
<p>例子是一个学生学习考试的MDP。里面实心圆位置是<strong>起点</strong>，方框那个位置是<strong>终点</strong>。上面的动作有study, Pub, Facebook, Quit, Sleep，每个状态动作对应的即时奖励R已经标出来了。我们的目标是找到最优的状态动作价值函数或者状态价值函数，进而找出最优的策略。</p>
<p><a href="&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images">&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images</a> src=”<a href="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129160656460.png">https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129160656460.png</a>“ alt=”image-20201129160656460” style=”zoom:50%;” /&gt;</p>
<p>为了方便，我们假设衰减因子 $\gamma =1, \pi(a|s) = 0.5$ 。对于终点方框位置，由于其没有下一个状态，也没有当前状态的动作，因此其状态价值函数为0，对于其他的状态（圆圈）按照从上到下，从左到右的顺序定义其状态价值函数分别是 $v_1,v_2,v_3,v_4$ ，根据（5）式 :</p>
<script type="math/tex; mode=display">
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad\quad\quad\quad\quad (5)</script><p>对于$v_1$位置，我们有：$v_1 = 0.5<em>(-1+v_1) +0.5</em>(0+v_2)$</p>
<p>对于$v_2$位置，我们有：$v_2 = 0.5<em>(-1+v_1) +0.5</em>(-2+v_3)$</p>
<p>对于$v_3$位置，我们有：$v_3 = 0.5<em>(0+0) +0.5</em>(-2+v_4)$</p>
<p>对于$v_4$位置，我们有：$v_4 = 0.5<em>(10+0) +0.5</em>(1+0.2<em>v_2+0.4</em>v_3+0.4*v_4)$</p>
<p>解出这个方程组可以得到 $v_1=-2.3, v_2=-1.3, v_3=2.7, v_4=7.4$, 即每个状态的价值函数如下图：</p>
</li>
</ul>
<p><a href="&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images">&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images</a> src=”<a href="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129162749453.png">https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129162749453.png</a>“ alt=”image-20201129162749453” style=”zoom:50%;” /&gt;</p>
<blockquote>
<p>从上面可以看出，针对一个特定状体，状态价值函数计算都是基于下一个状态而言的，通俗的讲，按照“出箭头”的方向计算当前状态的价值函数。</p>
</blockquote>
<h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201128152843746.png" alt="image-20201128152843746"></p>
<h2 id="MDP贝尔曼最优方程"><a href="#MDP贝尔曼最优方程" class="headerlink" title="MDP贝尔曼最优方程"></a>MDP贝尔曼最优方程</h2><h3 id="最优价值函数"><a href="#最优价值函数" class="headerlink" title="最优价值函数"></a>最优价值函数</h3><p>能够使得 $v$ 达到最大值的那个 $\pi$ ，这个  $\pi$ 被成为最优策略，进而得到<strong>最优状态价值函数</strong>。同理得到最<strong>优状态动作价值函数</strong>。</p>
<script type="math/tex; mode=display">
\large
\begin{cases} v_*(s)\ \dot{=}\ \ \underset{\pi}{max} \ v_\pi(s) & \text{} \\
q_*(s,a)\ \dot{=}\ \ \underset{\pi}{max} \ q_\pi(s,a) & \text{} & \text {} \end{cases}</script><p>记 $\pi<em>* = \underset{\pi}{argmax} \ v</em>\pi(s) = \underset{\pi}{argmax} \ q<em>\pi(s,a)$，含义是 $\pi</em><em>$ 可以使得 $ v_</em>(s)$达到最大值，同样的，也可以使得</p>
<p>$q_\pi(s,a)$ 达到最大值。</p>
<p>由以上公式得：</p>
<script type="math/tex; mode=display">
\large
\begin{cases}v_*(s)=\underset{\pi}{max}\ v_\pi(s)= v_{\pi_*}(s) & \text{(7)} \\
q_*(s,a)=\underset{\pi}{max}\ q_\pi(s,a)= q_{\pi_*}(s,a) & \text{} & \text {(8)} \end{cases}</script><blockquote>
<p>值得注意的一点是$ v<em>*(s)$ 强调的是，不管你采用的是什么策略，只要状态价值函数达到最大值，而 $v</em>{\pi_*}(s)$ 则更为强调的是 $\pi$ ，达到最大的状态价值函数所采取的最优的那个 $\pi$</p>
</blockquote>
<p>此时，我们再探讨一下$v<em>{\pi</em><em>}(s)$ 和 $q<em>{\pi</em></em>}(s,a)$ 的关系。在贝尔曼期望方程中，我们提到过 $v<em>\pi(s) \leq \underset{a}{max}\ q</em>\pi(s,a)$ ，那么在这里是不是也由类似的关系$v<em>{\pi</em><em>}(s)\leq \underset{a}{max}\ q<em>\pi(s,a)$  成立？我们知道 $v</em>{\pi_</em>}(s)$ 是一种策略，并且是最优的策略，$q<em>{\pi</em><em>}(s,a)$ 是代表一个“分支”，因为 $v<em>{\pi</em></em>}(s)$ 是一个加权平均值，但同样的，和$v<em>\pi(s)$ 不同的是，$v</em>{\pi_*}(s)$ 是最优策略的加权平均，那么是不是可以把小于号去掉，写成下面的形式：</p>
<script type="math/tex; mode=display">
\large
v_{\pi_*}(s)= \underset{a}{max}\ q_\pi(s,a)</script><p>假定 $v<em>{\pi</em><em>}(s)\leq \underset{a}{max}\ q<em>\pi(s,a)$ 中的 $\pi</em></em>$ 还是一个普通的策略，那么一定满足  $v<em>{\pi</em><em>}(s)\leq \underset{a}{max}\ q<em>\pi(s,a)$ ，这一点我们已经提到过，如果说 $v</em>{\pi_</em>}(s)&lt; \underset{a}{max}\ q<em>\pi(s,a)$ ，说明$v</em>{\pi<em>*}(s)$ 还有提高的空间，并不是最优策略，这和条件矛盾了。所以这个小于不成立，得证：$v</em>{\pi<em>*}(s)= \underset{a}{max}\ q</em>\pi(s,a)$</p>
<p>详细证明过程如下：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129190023306.png" alt="image-20201129190023306"></p>
<p>其实，上面的式子是由  (3)式</p>
<script type="math/tex; mode=display">
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) ·q_\pi(s,a)  \quad\quad (3)</script><p>演变而来的。$v<em>{\pi</em>*}(s)$ 直接取最大值时候和 $\underset{a}{max}\ q<em>\pi(s,a)$ 的最大值是相等的。也就是此时不用加权平均了，直接是 $v</em>\pi(a) = q_\pi(s,a)$ 。那么从原先的(4)式能不能也得出相似</p>
<script type="math/tex; mode=display">
q_\pi(s,a) =\sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad (4)</script><p>的结论，把求和符号去掉，直接等于最大值呢？答案是否定的，因为$v<em>{\pi</em>*}(s)= \underset{a}{max}\ q_\pi(s,a)$  是作用在<code>action</code>上的，在公式中也可以看出，换句话说，我们对于下图的a1，a2，a3这里是可以控制的。但是对于下图中的蓝色虚线部分，系统状态转移是无法控制的。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss02.svg" alt="image-20201128135658979"></p>
<p>所以，原先的两组公式（3）、（4）并 结合（7）、（8）</p>
<script type="math/tex; mode=display">
\large{
v_\pi(s) = \sum_{a\in A} \pi(a\mid s) ·q_\pi(s,a)  \quad\quad\quad\quad\quad\quad\quad\quad\ (3) \\

q_\pi(s,a) =\sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad\quad\quad (4)
}</script><p>并进行一个推导，得出另外的两组公式（9）、（10）如下：</p>
<script type="math/tex; mode=display">
\large{
v_*(s)=\underset{a}{max}\ q_*(s,a) \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (9) \\
q_*(s,a)= \sum_{s',r}P[s',r \mid s,a](r+\gamma v_*(s')) \quad\quad\quad (10)
}</script><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>（10）式带入（9）式得：</p>
<script type="math/tex; mode=display">
\large{
v_*(s)=\underset{a}{max}\sum_{s',r}P[s',r \mid s,a](r+\gamma v_\pi(s')) \quad\quad(11) \\

}</script><p>（9）式带入（10）式得：</p>
<script type="math/tex; mode=display">
\large
q_*(s,a)= \sum_{s',r}P[s',r \mid s,a](r+\gamma \underset{a'}{max}\ q_*(s',a') ) \quad\quad (12)</script><p>（11）、（12）被称为<strong>贝尔曼最优方程</strong>。</p>
<ul>
<li><p>一个实例：还是以上面的例子讲解，我们这次以动作价值函数 $q<em>*(s,a)$ 为例来求解 $v</em><em>(s),q_</em>(s,a) $</p>
<p><a href="&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images">&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images</a> src=”<a href="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129160656460.png">https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129160656460.png</a>“ alt=”image-20201129160656460” style=”zoom:50%;” /&gt;</p>
</li>
</ul>
<p>根据（12）式</p>
<script type="math/tex; mode=display">
\large
q_*(s,a)= \sum_{s',r}P[s',r \mid s,a](r+\gamma \underset{a'}{max}\ q_*(s',a') ) \quad\quad (12)</script><p>可得方程组如下：</p>
<script type="math/tex; mode=display">
\large{\begin{align}
q_*(s_4, study) & = 10 \\
q_*(s_4, pub) & = 1 + 0.2 * \underset{a'}{max}q_*(s_2, a') + 0.4 * max_{a'}q_*(s_3, a') + 0.4 * \underset{a'}{max}q_*(s_4, a') \\
q_*(s_3, sleep) & = 0  \\
q_*(s_3, study) & = -2 + \underset{a'}{max}q_*(s_4, a') \\
q_*(s_2, study) & = -2 + \underset{a'}{max}q_*(s_3, a') \\
q_*(s_2, facebook) & = -1 + \underset{a'}{max}q_*(s_1, a') \\
q_*(s_1, facebook) & = -1 + \underset{a'}{max}q_*(s_1, a') \\
q_*(s_1, quit) & = 0 + \underset{a'}{max}q_*(s_2, a')
\end{align}}</script><p>然后求出所有的 $q<em>*(s,a)$，然后再利用 $v</em><em>(s) = \underset{a’}{max}q_</em>(s,a)$，就可以求出所有的  $v_*(s)$，最终结果如下图所示：</p>
<p><a href="&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images">&lt;https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images</a> src=”<a href="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201130141108720.png">https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201130141108720.png</a>“ alt=”image-20201130141108720” style=”zoom: 67%;” /&gt;</p>
<p>详细的计算过程可以看下视频 的简单分析。<a href="https://www.bilibili.com/video/BV1Fi4y157vR/">https://www.bilibili.com/video/BV1Fi4y157vR/</a></p>
<h3 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201129210325397.png" alt="image-20201129210325397"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.bilibili.com/video/BV1RA411q7wt">https://www.bilibili.com/video/BV1RA411q7wt</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/9426283.html">https://www.cnblogs.com/pinard/p/9426283.html</a></p>
<p><a href="https://www.davidsilver.uk/wp-content/uploads/2020/03/MDP.pdf">https://www.davidsilver.uk/wp-content/uploads/2020/03/MDP.pdf</a></p>
<p><a href="https://www.cnblogs.com/jsfantasy/p/jsfantasy.html">https://www.cnblogs.com/jsfantasy/p/jsfantasy.html</a></p>
]]></content>
      <tags>
        <tag>统计学反思</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习-动态规划-DP</title>
    <url>/2021/10/02/2021-10-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-02-DP/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="强化学习-动态规划-DP"><a href="#强化学习-动态规划-DP" class="headerlink" title="强化学习-动态规划-DP"></a>强化学习-动态规划-DP</h1><blockquote>
<p>作者：YJLAugus  博客： <a href="https://www.cnblogs.com/yjlaugus">https://www.cnblogs.com/yjlaugus</a> 项目地址：<a href="https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star">https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star</a>。</p>
</blockquote>
<p>这里讲动态规划，主要是用动态规划来解决MDP的中最优的策略，并得出最优的价值函数。这节主要介绍两中动态规划的方法，一个是<strong>策略迭代</strong>方法，另一个是<strong>价值迭代</strong>方法。</p>
<h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><p>策略迭代主要分两个，一个是<strong>策略评估</strong>，一个是<strong>策略改进</strong>。定义比较简单，分别如下：</p>
<p><strong>策略评估</strong>：给定任意的一个 $\pi$ ，求出 状态价值函数 $v<em>\pi(s)$ 或者状态动作价值函数 $q</em>\pi(s,a)$。<br><strong>策略改进</strong>：依据策略评估得出来的 $v<em>\pi(s)$ 或者 $q</em>\pi(s,a)$，从其中构造出一个新的 $\pi’$ ，使得 $\pi’ \geq \pi $ ，这样就完成了一次迭代。</p>
<ul>
<li>换句话说，就是在每个状态下根据$v<em>\pi(s)$ 或者 $q</em>\pi(s,a)$选择一个最优的策略，这个策略就是 $\pi’$ 。</li>
<li>这种根据<code>原策略的价值函数</code>执行贪心算法，来构造一个更好策略的过程，我们称为策略改进。<br><strong>策略迭代</strong>： 就是递归以上两个过程，以上面的例子，得到$\pi’$的价值函数，然后再以$\pi’$的价值函数构造一个新的$\pi’’$ ，不断迭代。</li>
</ul>
<h3 id="策略评估-解析解"><a href="#策略评估-解析解" class="headerlink" title="策略评估-解析解"></a>策略评估-解析解</h3><p>策略评估，就是已知 MDP，“已知MDP”的意思是知道其动态特性，也就是 $p(s’,r \mid s,a)$，给定$\pi$ ，求$v_\pi(s)$。</p>
<p>已知$(\forall s\in S)$ ，即有多少个$s$ 就会有多少$v_\pi(s)$，可得列向量如下：</p>
<script type="math/tex; mode=display">
\large
v_\pi(s)= \begin{pmatrix}
v_\pi(s_1)\\
v_\pi(s_2)\\
\vdots    \\
v_\pi(s_{\lvert S \rvert})

\end{pmatrix} _{\lvert S \rvert \times 1}</script><p>上节课我们得到价值函数的公式，并进一步推导得到贝尔曼期望方程：</p>
<script type="math/tex; mode=display">
\large
{\begin{align}  
v_\pi(s) =& E_\pi[G_t \mid S_t = s] \\
=& E_\pi[R_{t+1} + \gamma v_\pi(S_{t+1} \mid S_t=s)]\\
=& v_\pi(s) = \sum_{a\in A} \pi(a\mid s) \sum_{s',r}p[s',r \mid s,a](r+ \gamma v_\pi(s'))
\end{align}
}</script><p>从上面的列向量中得知，如果我们想要求整个的$v<em>\pi(s)$ ，就是把$v</em>\pi(s<em>1),v</em>\pi(s<em>2),v</em>\pi(s_3)…$ 等所有的价值函数都要求出来。我们这节的目的就是把公式中的累加符号去掉，得到另一个更为简单的式子。接下来我们对下面的式子进行化简如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

v_\pi(s) =& \sum_{a\in A} \pi(a\mid s) \sum_{s',r}p[s',r \mid s,a](r+ \gamma v_\pi(s'))\\
= & \underbrace {\sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot r }_{①}
+
\underbrace{\gamma \sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot v_\pi(s')}_{②}

\end{align}
}</script><p><strong>分解①式</strong>：对于①式而言，$s’$ 只出现在函数$p(s’,r \mid s,a)$ 中，是可以积分积掉的。故由①得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

\sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot r  \\
=& \sum_{a\in A}  \pi(a\mid s) \underbrace {\sum_{r}  r\cdot p(r \mid s,a)}_{E_\pi[R_{t+1}  \mid S_t=s,A_t=a]} \quad\quad (1)  \\

\end{align}
}</script><p>（1）式正好是期望，此时我们也定义一个函数（记号） $r(s,a) \dot{=} E<em>\pi[R</em>{t+1}  \mid S_t=s,A_t=a]$ 。表示$s,a$ 这个二元组的收益。故我们的推导变成如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

\sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot r  \\
=& \sum_{a\in A} \pi(a\mid s) \underbrace {\sum_{r}  r\cdot p(r \mid s,a)}_{r(s,a) \dot{=}E_\pi[R_{t+1}  \mid S_t=s,A_t=a]} \quad\quad (1)  \\
=& \sum_{a\in A} \pi(a\mid s) \cdot r(s,a) \quad\quad\quad\quad \quad\quad \quad\quad\ (2)

\end{align}
}</script><p>（2）式中，如果把 $a$ 都积分掉，那么（2）式就和$a$ 就没关系了，只和$s$ 有关，这里我们再次引入一个记号$r_\pi(s)$用来表示这个新的关系如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

\sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot r  \\
=& \sum_{a\in A} \pi(a\mid s) \underbrace {\sum_{r}  r\cdot p(r \mid s,a)}_{r(s,a) \dot{=}E_\pi[R_{t+1}  \mid S_t=s,A_t=a]} \quad\quad (1)  \\
=& \sum_{a\in A} \pi(a\mid s) \cdot r(s,a) \quad\quad\quad\quad \quad\quad \quad\quad\ (2) \\
\dot{=}&r_\pi(s)  \quad\quad\quad\quad \quad\quad \quad\quad\quad \quad\quad\ \quad\quad \quad\quad\ (3)

\end{align}
}</script><p>此时，①式化简至此，需要提到的一点是，$r<em>\pi(s)$ 应该由多少个呢？在一开始我们就提到过 “$S$中有多少个$s$ 就会有多少$v</em>\pi(s)$，” ，显然 $r_\pi(s)$ 的数量也是 $\lvert S \rvert$ 个。故可得列向量如下:</p>
<script type="math/tex; mode=display">
\large
r_\pi(s)= \begin{pmatrix}
r_\pi(s_1)\\
r_\pi(s_2)\\
\vdots    \\
r_\pi(s_{\lvert S \rvert})

\end{pmatrix} _{\lvert S \rvert \times 1}</script><p><strong>分解②式</strong>：在 $p(s’,r \mid s,a) \cdot v_\pi(s’)$ 中，我们发现 $s’$ 在式子中都存在，但是$r$ 只存在于函数 $p(s’,r \mid s,a)$ 中，故积分可以积掉，则②式可以进一步写成：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

\gamma \sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot v_\pi(s')
=& \gamma \sum_{a\in A} \pi(a\mid s) \sum_{s'}\underbrace{p(s' \mid s,a)}_{状态转移函数} \cdot v_\pi(s') \quad\quad (4)

\end{align}
}</script><p>在（4）式中，可以发现在两个累加号中都有 $a$（注：虽然也都有 $s$，但是累加号下面是$a$ ，故积分只能积掉 $a$），积分可以积掉，但是一定和 $s,s’$ 有关，故引出一个记号 $P_\pi(s,s’)$ 来表示。 故继续推导如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}

\gamma \sum_{a\in A} \pi(a\mid s) \sum_{s',r}p(s',r \mid s,a) \cdot v_\pi(s')
=& \gamma \sum_{a\in A} \pi(a\mid s) \sum_{s'}\underbrace{p(s' \mid s,a)}_{状态转移函数} \cdot v_\pi(s') \quad\quad (4) \\

=& \gamma \sum_{s'} \underbrace{\sum_{a\in A} \pi(a\mid s) p(s' \mid s,a)}_{P_\pi(s,s')} \cdot v_\pi(s') \quad\quad (5) \\

=&  \gamma \sum_{s'} P_\pi(s,s') \cdot v_\pi(s') \quad\quad (6)\\

\end{align}
}</script><p>由（6）式可知，对于 $P<em>\pi(s,s’)$ 来说，一共由多少个值呢？很显然，$s$ 和 $s’$ 分别由 $\lvert S \rvert $ 个值，故 $P</em>\pi(s,s’)$ 会有 $\lvert S \rvert \times \lvert S \rvert  $  个。故可得矩阵如下：</p>
<script type="math/tex; mode=display">
\large
P_\pi(s,s')= \begin{pmatrix}
P_\pi(s_1,s'_1) & \cdots & P_\pi(s_1,s'_{\lvert S \rvert})\\
\vdots & \ddots & \vdots \\
P_\pi(s_{\lvert S \rvert},s'_1) & \cdots & P_\pi(s_{\lvert S \rvert},s'_{\lvert S \rvert})\\

\end{pmatrix} _{\lvert S \rvert \times \lvert S \rvert}</script><p>于是，结合（3）和（6）式得：</p>
<script type="math/tex; mode=display">
\large{
v_\pi(s) = r_\pi(s) + \gamma \sum_{s'} P_\pi(s,s') \cdot v_\pi(s') \quad\quad\quad (7)
}</script><p>令$s_i\dot{=s},s_j \dot{=} s’$ ，则（7） 式得：</p>
<script type="math/tex; mode=display">
\large{
v_\pi(s) = r_\pi(s) + \gamma \underbrace{\sum_{j=1}^{\lvert S \rvert} P_\pi(s_i,s_j) }_{①}\cdot v_\pi(s') \quad\quad\quad (7)
}</script><p>由（7）式中的①式可得，正好是矩阵$P<em>\pi(s,s’)$ ，其中的 $P</em>\pi(s<em>i,s_j)$正是矩阵的一行。（7）式中$v</em>\pi(s)，r<em>\pi(s)，①，v</em>\pi(s’)$ 式（$v<em>\pi(s’)$本质是和$v</em>\pi(s)$是一样的），都分别对应一个矩阵，也即：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
v_\pi(s_1)\\
v_\pi(s_2)\\
\vdots    \\
v_\pi(s_{\lvert S \rvert})
\end{pmatrix}_{\lvert S \rvert \times 1}
=

\begin{pmatrix}
r_\pi(s_1)\\
r_\pi(s_2)\\
\vdots    \\
r_\pi(s_{\lvert S \rvert})
\end{pmatrix} _{\lvert S \rvert \times 1}
* \gamma

\begin{pmatrix}
P_\pi(s_1,s'_1) & \cdots & P_\pi(s_1,s'_{\lvert S \rvert})\\
\vdots & \ddots & \vdots \\
P_\pi(s_{\lvert S \rvert},s'_1) & \cdots & P_\pi(s_{\lvert S \rvert},s'_{\lvert S \rvert})\\
\end{pmatrix} _{\lvert S \rvert \times \lvert S \rvert}
\cdot

\begin{pmatrix}
v_\pi(s_1)\\
v_\pi(s_2)\\
\vdots    \\
v_\pi(s_{\lvert S \rvert})
\end{pmatrix} _{\lvert S \rvert \times 1}</script><p>最终化简到矩阵的运算。故，由（7）式进一步得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) =& r_\pi(s) + \gamma P_\pi(s,s') \cdot v_\pi(s') \quad\quad\quad \\
v_\pi=& r_\pi + \gamma P_\pi \cdot v_\pi \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\qquad (8)\\
(I-P_\pi)v_\pi =& r_\pi \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\qquad\quad\quad\quad\quad\quad\ (9) \\
v_\pi =& (I-P_\pi)^{-1} r_\pi \qquad\qquad\qquad\qquad\qquad\qquad(10)
\end{align}
}</script><p>经过以上推导，得出（10）式。其中在（8）式中$v<em>\pi(s’)$ 其实是 $v</em>\pi(s)$ 的迭代，所以直接用 $v_\pi(s)$ 替换，在（9）式中$\gamma$ 是个常数，也可忽略。从向量中可以得出复杂度$O({\lvert S \rvert}^3)$</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203135011156.png" alt="image-20201203135011156"></p>
<h3 id="策略评估-迭代解"><a href="#策略评估-迭代解" class="headerlink" title="策略评估-迭代解"></a>策略评估-迭代解</h3><p>首先，我们来看如何使用动态规划来求解强化学习的<strong>预测问题</strong>，即求解给定策略的状态价值函数的问题。这个问题的求解过程我们通常叫做策略评估(Policy Evaluation)。</p>
<p>策略评估的基本思路是从<strong>任意一个状态价值函数开始</strong>，依据给定的策略，结合贝尔曼期望方程、状态转移概率和奖励同步迭代更新状态价值函数，直至其<strong>收敛</strong>，得到该策略下最终的状态价值函数。</p>
<p>假设我们在第$k$轮迭代已经计算出了所有的状态的状态价值，那么在第$k+1$轮我们可以利用第$k$轮计算出的<strong>状态价值</strong>计算出第$k+1$轮的状态价值。这是通过贝尔曼方程来完成的，即：</p>
<script type="math/tex; mode=display">
\large{
v_{k+1}(s) = \sum\limits_{a \in A} \pi(a|s)(R_s^a + \gamma \sum\limits_{s' \in S}P_{ss'}^av_{k}(s'))
 \\

 v_{k+1}(s) \dot{=}\sum_{a\in A} \pi(a\mid s) \sum_{s',r}p[s',r \mid s,a](r+ \gamma v_k(s'))
}</script><p>和上一节的式子唯一的区别是由于我们的策略$\pi$已经给定，我们不再写出，对应加上了迭代轮数的下标。我们每一轮可以对计算得到的新的状态价值函数再次进行迭代，直至状态价值的值改变<strong>很小(收敛)</strong>，那么我们就得出了预测问题的解，即给定策略的状态价值函数$v_\pi$。</p>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203183436771.png" alt="image-20201203183436771"></p>
<h3 id="策略评估-（迭代解）应用"><a href="#策略评估-（迭代解）应用" class="headerlink" title="策略评估-（迭代解）应用"></a>策略评估-（迭代解）应用</h3><p>下面我们用一个具体的例子来说明策略评估的过程。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203142402216.png" alt="image-20201203142402216"></p>
<p>这是一个经典的Grid World的例子。我们有一个<code>4x4</code>的16宫格。只有左上和右下的格子是终止格子。该位置的价值固定为0，个体如果到达了该2个格子，则停止移动，此后每轮奖励都是0。个体在16宫格其他格的每次移动，得到的即时奖励R都是-1。注意个体每次只能移动一个格子，且只能上下左右4种移动选择，不能斜着走, 如果在边界格往外走，则会直接移动回到之前的边界格。衰减因子我们定义为$\gamma =1$。由于这里每次移动，下一格都是固定的，因此所有可行的的状态转化概率$P =1$。这里给定的策略是随机策略，即每个格子里有25%的概率向周围的4个格子移动。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203142716568.png" alt="image-20201203142716568"></p>
<p>首先我们初始化所有格子的状态价值为0，如上图$k=0$的时候。现在我们开始策略迭代了。由于终止格子的价值固定为0，我们可以不将其加入迭代过程。</p>
<p><strong>在$k=1$时</strong>，我们利用上面的贝尔曼方程先计算第二行第一个格子的价值：</p>
<script type="math/tex; mode=display">
v_1^{(21)} = \frac{1}{4}[(-1+0) +(-1+0)+(-1+0)+(-1+0)] = -1</script><p>第二行第二个格子的价值是：</p>
<script type="math/tex; mode=display">
v_1^{(22)} = \frac{1}{4}[(-1+0) +(-1+0)+(-1+0)+(-1+0)] = -1</script><p>其他的格子都是类似的，第一轮的状态价值迭代的结果如上图$k=1$的时候。现在我们第一轮迭代完了。</p>
<p><strong>在$k=1$时</strong>，还是看第二行第一个格子的价值：</p>
<script type="math/tex; mode=display">
v_2^{(21)} = \frac{1}{4}[(-1+0) +(-1-1)+(-1-1)+(-1-1)] = -1.75</script><p>第二行第二个格子的价值是：</p>
<script type="math/tex; mode=display">
v_2^{(22)} = \frac{1}{4}[(-1-1) +(-1-1)+(-1-1)+(-1-1)] = -2</script><p>最终得到的结果是上图$k=2$的时候，第二轮迭代完毕。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203142745214.png" alt="image-20201203142745214"></p>
<p><strong>在$k=3$时</strong>：</p>
<script type="math/tex; mode=display">
v_3^{(21)} = \frac{1}{4}[(-1+0)+(-1-1.7) +(-1-2)+(-1-2)] = -2.425 \\
v_3^{(22)} = \frac{1}{4}[(-1-1.7) +(-1-1.7)+(-1-2)+(-1-2)] = -2.85</script><blockquote>
<p>计算加和的过程 就是 上、下、左、右四个方向，其中无论哪次迭代，都有 $v_k^{11} = 0$。</p>
</blockquote>
<p>最终得到的结果是上图$k=3$的时候。就这样一直迭代下去，直到每个格子的策略价值改变很小（收敛）为止。这时我们就得到了所有格子的基于随机策略的状态价值。</p>
<p>可以看到，动态规划的策略评估计算过程并不复杂，但是如果我们的问题是一个非常复杂的模型的话，这个计算量还是非常大的。</p>
<h3 id="策略改进-策略改进定理"><a href="#策略改进-策略改进定理" class="headerlink" title="策略改进-策略改进定理"></a>策略改进-策略改进定理</h3><p>现在出现了这样一个问题，如果给定一个 $\pi$ 和 $\pi’$ ，我们如何判断哪一策略更好呢？采用我们以前提到的方法，就是分别计算各自对应的价值函数，然后通过判断两个价值函数的大小来判断策略的好坏。虽然能够得出结论，但是这个计算的过程也是会占用 “资源”的，能否有另外一种方式可以实现相应的功能呢？有，那就是<strong>策略改进定理。</strong></p>
<p><strong>策略改进定理：</strong> <strong>给定$\pi，\pi’$，如果$\forall(s) \in S,q<em>\pi(s,\pi’(s)) \geq v</em>\pi(s)$，那么，则有 $\forall s\in S,v<em>{\pi’}(s) \geq v</em>\pi(s)$。</strong></p>
<p>通过上面的定理可得，$q<em>\pi(s,a)$ 只要算出来了，那么 $v</em>\pi(s)$ 自然也会得出（$v<em>\pi(s)$ 是$q</em>\pi(s,a)$的加权平均），此时我们不再需要再求得 $v<em>{\pi’}(s)$，而是直接把$\pi’(s)$ 带入到 $q</em>\pi(s,a)$ 中的a中即可。</p>
<p>下面进行定理的一个证明：</p>
<p>在 $q<em>\pi(s,\pi’(s)) \geq v</em>\pi(s)$ 中，里面的 $q<em>\pi(s,a)$ 和 $v</em>\pi(s’)$ 有如下关系，我们在第一张MDP已经证明过：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
q_\pi(s,a) =& \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \\
=&E_\pi[R_{t+1} + \gamma v_\pi(s_{t+1}) \mid S_t = s, A_t=a]
\end{align}
}</script><p>其实，这里需要说明一点，上式中 $E<em>\pi$ 中的$\pi$ 严格意义上是不能带着的，对于$R</em>{t+1}$ ， 不是$\pi$ 控制的，详情看下图的蓝色虚线（在第一章中，我们称其未系统之间的状态转移），</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss02.svg" alt="image-20201128135658979"></p>
<p>当然了，对于 $R<em>{t+2}, R</em>{t+3}$ 等是需要 $\pi$ 控制的，在公式中的体现就是$v_\pi$。故，这里准确写法应该如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
q_\pi(s,a) =& \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=a]
\end{align}
}</script><p><strong>证明：</strong>$\forall(s) \in S,q<em>\pi(s,\pi’(s)) \geq v</em>\pi(s)$，把 $a=\pi’(s)$ 带入得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad (2)

\end{align}
}</script><p>上面式子中，在（2）式中，我们把 $\pi’$那个策略定义到 $R<em>{t+1}$ 上，其余的还是采取 $\pi$ 的策略。在（2）式中出现了 $v</em>\pi(s<em>{t+1})$ ，再带入$v</em>\pi(s) \leq q_\pi(s,\pi’(s))$  得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad\ (2) \\

\leq & E_{\pi'}[R_{t+1} + \gamma q_\pi(S_{t+1},\pi'(S_{t+1})) \mid S_t = s] \quad\quad\quad\quad\quad\ (3)

\end{align}
}</script><p>再把$q<em>\pi(s</em>{t+1},\pi’(s_{t+1}))$ 带入（2）式得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad\ (2) \\

\leq & E_{\pi'}[R_{t+1} + \gamma q_\pi(S_{t+1},\pi'(S_{t+1})) \mid S_t = s] \quad\quad\quad\quad\quad\ (3) \\

=&E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} + \gamma v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (4)

\end{align}
}</script><p>有一点注意，在（4）式中 $S<em>{t+1}$ 没有写成等于多少的形式，这里只是对于$S</em>{t+2}$ 的前提条件，表明其不能独立出现。然后再对（4）展开得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad\ (2) \\

\leq & E_{\pi'}[R_{t+1} + \gamma q_\pi(S_{t+1},\pi'(S_{t+1})) \mid S_t = s] \quad\quad\quad\quad\quad\ (3) \\

=&E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} + \gamma v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (4) \\

=&E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} \mid S_{t+1}] + \gamma^2 E_{\pi'}[v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (5)

\end{align}
}</script><p>对于（5）式，出现了“期望套期望”，期望的期望还是期望，并且都是 $E{\pi’}$，故（5）式可以进一步化简得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad\ (2) \\

\leq & E_{\pi'}[R_{t+1} + \gamma q_\pi(S_{t+1},\pi'(S_{t+1})) \mid S_t = s] \quad\quad\quad\quad\quad\ (3) \\

=&E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} + \gamma v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (4) \\

=&E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} \mid S_{t+1}] + \gamma^2 E_{\pi'}[v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (5) \\

=&E_{\pi'}[R_{t+1} + \gamma R_{t+2}  + \gamma^2v_\pi(S_{t+2}) \mid S_t=s ]\quad\quad\ (6)

\end{align}
}</script><p>到这里，只走了两步，可以看到，由 $\pi’$ 一开始的只控制 $R<em>{t+1}$ ，走完两步后，$R</em>{t+2}$ 也属于 $\pi’$ 控制，接下来继续走的话，$\pi’$ 控制的 $R$ 会越来越多，$\pi$ 控制的 $R$ 越来越少。</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_\pi(s) \leq & q_\pi(s,\pi'(s)) \\
=& E[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s, A_t=\pi'(s)] \quad\quad\quad(1) \\
=& E_{\pi'}[R_{t+1} + \gamma v_\pi(S_{t+1}) \mid S_t = s] \quad\quad\quad\quad\quad\quad\quad\quad\ (2) \\

\leq & E_{\pi'}[R_{t+1} + \gamma q_\pi(S_{t+1},\pi'(S_{t+1})) \mid S_t = s] \quad\quad\quad\quad\quad\ (3) \\

=& E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} + \gamma v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (4) \\

=& E_{\pi'}[R_{t+1} + \gamma E_{\pi'}[R_{t+2} \mid S_{t+1}] + \gamma^2 E_{\pi'}[v_\pi(S_{t+2}) \mid S_{t+1}] \mid S_t=s ]\quad\quad\ (5) \\

=& E_{\pi'}[R_{t+1} + \gamma R_{t+2}  + \gamma^2v_\pi(S_{t+2}) \mid S_t=s ]\quad\quad\ (6)\\

\leq & E_{\pi'}[R_{t+1} + \gamma R_{t+2}  +\gamma^2 R_{t+3} + \gamma^3v_\pi(S_{t+3}) \mid S_t=s ]\quad\quad\quad (7)\\

\vdots \\

\leq & E_{\pi'} \underbrace{[R_{t+1} + \gamma R_{t+2}  +\gamma^2 R_{t+3} + \gamma^4 R_{t+4} + \cdots}_{G_t} \mid S_t=s ] \quad\quad\ (8)\\

=& v_{\pi'}(s)

\end{align}
}</script><p>故得到：$v<em>\pi’(s) \geq v</em>\pi(s)$， 得证。</p>
<h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201203210853298.png" alt="image-20201203210853298"></p>
<h3 id="策略改进-贪心策略"><a href="#策略改进-贪心策略" class="headerlink" title="策略改进-贪心策略"></a>策略改进-贪心策略</h3><p>这节就是利用策略改进定理提出一种策略改进的方法——<strong>贪心策略</strong>（Greedy Policy）。对于 $\forall s \in S$，定义如下公式：</p>
<script type="math/tex; mode=display">
\large{
\pi'(s) = \underset{a}{argmax}\ q_\pi(s,a) \quad\quad (1)
}</script><p>上面式子的意识是说，根据我们上节课所说的，从一个策略$\pi$，经过策略评估得到一些 $\pi’$ ，如下图所示。并从这些 $\pi’$ 中选择一个最大的$q_\pi(s,a)$。$\underset{a}{argmax}$ 表示能够使得表达式的值最大化的 $a$。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/pe.svg" alt=""></p>
<p>由在第一章讲到的 $v<em>\pi(s)$ 和 $q</em>\pi(s,a)$ 的 关系得：$v<em>\pi(s) \leq \underset{a}max \ q</em>\pi(s,a)$ 。又因由（1）式可得， $q<em>\pi(s,\pi’(s)) = \underset{a}max \ q</em>\pi(s,a)$ 故得：</p>
<script type="math/tex; mode=display">
\large{
v_\pi(s) \leq \underset{a}max \ q_\pi(s,a) =q_\pi(s,\pi'(s)) \\
v_\pi(s) \leq q_\pi(s,\pi'(s)) \quad\quad\quad \quad \qquad\quad\quad \qquad\quad\quad
(2)
}</script><p>（2）式正好满足上节我们说的策略改进定理。<strong>故由策略定理得知：对于 $\forall s \in S$，$v<em>{\pi’}(s) \geq v</em>\pi(s)$。</strong></p>
<p>如果在某一个时刻，一直迭代，如果出现了 $ v<em>\pi(s)=v</em>{\pi’}(s)$ ，这种情况，也就是说明 $v<em>\pi(s)$ 此时已经不能再好了，并且此时$ v</em>\pi(s)=v<em>{\pi’}(s) =v</em>*$。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/veq.svg" alt=""></p>
<blockquote>
<p><strong>证明</strong>：如果$v<em>{\pi’}=v</em>\pi$ 那么，$ v<em>\pi(s)=v</em>{\pi’}(s) =v_*$</p>
</blockquote>
<p>证：由 $v<em>{\pi’}=v</em>\pi$， 可以得出 $q<em>{\pi’}=q</em>\pi。$$\forall s\in S$，由$v<em>\pi(s) = \sum</em>{a\in A} \pi(a\mid s) ·q_\pi(s,a) $可得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_{\pi'}(s) =& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi'}(s,a)\\
=& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi}(s,a) \quad\quad\quad\ (3) \\  

\end{align}
}</script><p>因为前面说的 $\pi’$ 都是选择一个最优的策略，也就是<strong>确定性策略</strong>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss02.svg" alt="image-20201128135658979"></p>
<p>假如我们选择<code>a3</code>这个策略为 $\pi’$ 。故在（3）式中的加和可以去掉了，因为是确定性策略，那么选择<code>a2</code> 和 <code>a1</code>的概率就是0，例缩当然加和后只剩下<code>a3</code> 这个策略$\pi’$，故继续推导得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_{\pi'}(s) =& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi'}(s,a)\\
=& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi}(s,a) \quad\quad\quad\ (3) \\
=& q_\pi(s,\pi'(s)) \quad\quad\quad\quad\quad\quad\quad\quad\ (4)  \\

\end{align}
}</script><p>由（4）式和（2）中$\underset{a}max \ q<em>\pi(s,a) =q</em>\pi(s,\pi’(s))$ 得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_{\pi'}(s) =& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi'}(s,a)\\
=& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi}(s,a) \quad\quad\quad\ (3) \\
=& q_\pi(s,\pi'(s)) \quad\quad\quad\quad\quad\quad\quad\quad\quad (4)  \\
=& \underset{a}max \ q_\pi(s,a) \qquad\quad\quad\quad\quad\quad\quad\ (5)\\

\end{align}
}</script><p>（5）式再由$q<em>\pi(s,a) =\sum</em>{s’,r}P<a href="r+ \gamma v_\pi(s&#39;">s’,r \mid s,a</a>) $ 可得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_{\pi'}(s) =& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi'}(s,a)\\
=& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi}(s,a) \quad\quad\quad\ (3) \\
=& q_\pi(s,\pi'(s)) \quad\quad\quad\quad\quad\quad\quad\quad\quad (4)  \\
=& \underset{a}max \ q_\pi(s,a) \qquad\quad\quad\quad\quad\quad\quad\ (5)\\
=& \underset{a}max \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad (6) \\
\end{align}
}</script><p>在（6）式中，又因为题设中，$v<em>{\pi’}=v</em>\pi$ 故带入得：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
v_{\pi'}(s) =& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi'}(s,a)\\
=& \sum_{a\in A} {\pi'}(a\mid s) ·q_{\pi}(s,a) \quad\quad\quad\ (3) \\
=& q_\pi(s,\pi'(s)) \quad\quad\quad\quad\quad\quad\quad\quad\quad (4)  \\
=& \underset{a}max \ q_\pi(s,a) \qquad\quad\quad\quad\quad\quad\quad\ (5)\\
=& \underset{a}max \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_\pi(s')) \quad (6) \\
=& \underset{a}max \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_{\pi’}(s')) \quad (7)
\end{align}
}</script><p>故此时我们得到：</p>
<script type="math/tex; mode=display">
\large
v_{\pi'}(s) = \underset{a}max \sum_{s',r}P[s',r \mid s,a](r+ \gamma v_{\pi’}(s')) \quad(8)</script><p>并且我们由贝尔曼最优方程得：</p>
<script type="math/tex; mode=display">
\large{
v_*(s)=\underset{a}{max}\sum_{s',r}P[s',r \mid s,a](r+\gamma v_\pi(s')) \quad\quad(9) \\

}</script><p>故由（8）式和（9）式，以及题设$v<em>{\pi’}=v</em>\pi$ 得证：</p>
<script type="math/tex; mode=display">
 \large
 v_\pi(s)=v_{\pi'}(s) =v_*</script><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201205145118572.png" alt="image-20201205145118572"></p>
<h2 id="价值迭代"><a href="#价值迭代" class="headerlink" title="价值迭代"></a>价值迭代</h2><h3 id="策略迭代的缺点"><a href="#策略迭代的缺点" class="headerlink" title="策略迭代的缺点"></a>策略迭代的缺点</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201205150228362.png" alt="image-20201205150228362"></p>
<p>从上图可以发现，在策略迭代中， 其实进行了两次策略循环，第一层是在策略评估中，第二层是策略迭代这一层。故，如果迭代次数过多的化，其实是很低效率的。<strong>策略评估的一个缺点是每一次迭代过程中都涉及了策略评估。</strong></p>
<h3 id="价值迭代-1"><a href="#价值迭代-1" class="headerlink" title="价值迭代"></a>价值迭代</h3><p>根据以上， 这里我们讨论一种极端的情况，只计算第一次的价值函数 $v_1(s)$， 从此进行截断，后续不在计算，也即是说，只对 $v_1(s)$ 进行策略评估，并把这个算法称为<strong>价值迭代</strong>。如图：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/jieduan1.svg" alt=""></p>
<p>如下图所示，价值迭代只计算 从状态$s$ 到$s’$的一条分支（$v<em>1(s)$），假定以最右侧分支为例，这是策略评估的<strong>一步</strong>，加上策略改进后，其实只走了“半步”，也就是从$s$ 状态走到a3（假定选择了action a3），此时利用策略改进算法即可用a3处的$q</em>\pi(s,a)$ ，并得到$v<em>\pi(s)$ 和 $v</em>{\pi’}(s)$的大小关系，以下图为例，假设a3为$v<em>\pi(s)$，则a2或者a1就是$v</em>{\pi’}(s)$。</p>
<p>也即：如果按照策略迭代的方法，需要计算完所有v1（选择a1的$v<em>\pi(s)-&gt;v</em>{\pi’}(s)$），v2，v3，如上图所示。但是依据价值迭代 + 策略改进，只需要计算v1的“半步”即可，因为根据策略改进定理，只需要计算出$q<em>\pi(s,a)$，即可得出$v</em>\pi(s)$ 和 $v_{\pi’}(s)$的大小关系。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/hss02.svg" alt="image-20201128135658979"></p>
<p>从 <strong>策略评估-（迭代解）应用</strong>小节 中可以知道，这个会有多个v1（注意：v1指的是多个状态，比如$v1^{21}$是第一次迭代中第二行第一个格子的状态，这里的“1”其实指的是迭代次数，并不一个状态）, 在这里选一个最大$v_\pi$作为$v<em>$ 。即完成了一次迭代。下面的公式，其是正是贝尔曼最优方程（求$v</em>$ ，$q<em>$）的 求$v</em>$的过程，同时也是价值迭代的算法公式：</p>
<script type="math/tex; mode=display">
\large{
 v_{k+1}(s) \dot{=}\underset{a}{max} \sum_{s',r}p(s',r \mid s,a)[r+ \gamma v_k(s') \quad\quad(1)
}</script><p>从上面（1）式中，从贝尔曼最优方程的较多来说，这里变成<strong>了一条更新规则</strong>，还是以<strong>策略评估-（迭代解）应用</strong>小节的例子举例，只计算v1，把“每个格子”的数据更新了一次（第一次迭代得到v1），而不需要在根据v1的数据j计算v2，再进行更新了。</p>
<p>除此之外，可以把（1）式和 “<strong>策略评估-迭代解</strong>”的更新策略$ v<em>{k+1}(s) \dot{=}\sum</em>{a\in A} \pi(a\mid s) \sum_{s’,r}p<a href="r+ \gamma v_k(s&#39;">s’,r \mid s,a</a>)$比较，唯一不同的是，在策略评估-迭代解中，对于 $s$状态的下一步<code>action</code> 需要根据概率求得，而在价值迭代中，直接在v1中选择最大的<code>action</code>，故概率此时为1。即：<strong>价值迭代是极端情况下的策略迭代</strong>。</p>
<p>根据上面描述的极端情况，其实就是价值迭代，总结如下：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201205213726436.png" alt="image-20201205213726436"></p>
<h3 id="异步动态规划"><a href="#异步动态规划" class="headerlink" title="异步动态规划"></a>异步动态规划</h3><p>异步动态规划，也叫就地迭代，它是基于价值迭代的一种算法。在样本空间比较大的情况下，即使只进行一次迭代，也会花费很长的时间，还是以<strong>策略评估-（迭代解）应用</strong> 小节的例子，比如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201205220225280.png" alt="image-20201205220225280"></p>
<p>如果，格子的数量及其多，即使只计算v1，（更新一次），迭代一次，花费时间也是巨大的。所以就出现了一种算法，这种算法，只随机找到“其中的一个格子” 进行更新，这就是<strong>异步动态规划</strong>。然而，为了收敛，异步算法必须不断的更新所有状态的值。</p>
<h2 id="广义策略迭代"><a href="#广义策略迭代" class="headerlink" title="广义策略迭代"></a>广义策略迭代</h2><p>广义策略迭代，其实就包含了前面所说的一般的策略迭代，价值迭代，还有就地迭代。如下面的图，如果都走到“顶”，那就是一般的策略迭代。如果走不到“顶”就可能是其他的迭代。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20201205221614255.png" alt="image-20201205221614255"></p>
<p>按照下面的例子和类比，就很容易理解了，可以把这个广义策略迭代类比买房：</p>
<p><strong>策略迭代</strong>：全款买房，以旧换新。</p>
<p><strong>价值迭代</strong>：首付，以旧换新。</p>
<p><strong>就地策略迭代</strong>：几乎0首付，以旧换新。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/pinard/p/9463815.html">https://www.cnblogs.com/pinard/p/9463815.html</a></p>
<p><a href="https://www.bilibili.com/video/BV1nV411k7ve?t=1738">https://www.bilibili.com/video/BV1nV411k7ve?t=1738</a></p>
<p><a href="https://www.davidsilver.uk/wp-content/uploads/2020/03/DP.pdf">https://www.davidsilver.uk/wp-content/uploads/2020/03/DP.pdf</a></p>
<p><a href="http://www.incompleteideas.net/book/the-book.html">http://www.incompleteideas.net/book/the-book.html</a></p>
]]></content>
      <tags>
        <tag>method</tag>
      </tags>
  </entry>
  <entry>
    <title>蒙特卡洛（Markov Chain &amp; Monte Carlo, MCMC）方法</title>
    <url>/2021/10/02/2021-10-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-03-MCMC/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="蒙特卡洛（Markov-Chain-amp-Monte-Carlo-MCMC）方法"><a href="#蒙特卡洛（Markov-Chain-amp-Monte-Carlo-MCMC）方法" class="headerlink" title="蒙特卡洛（Markov Chain &amp; Monte Carlo, MCMC）方法"></a>蒙特卡洛（Markov Chain &amp; Monte Carlo, MCMC）方法</h1><blockquote>
<p>作者：YJLAugus  博客： <a href="https://www.cnblogs.com/yjlaugus">https://www.cnblogs.com/yjlaugus</a> 项目地址：<a href="https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star">https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star</a>。</p>
</blockquote>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>20世纪40年代，在John von Neumann，Stanislaw Ulam 和 Nicholas Metropolis 在洛斯阿拉莫斯国家实验室为核武器计划工作时，发明了蒙特卡罗方法。因为Ulam的叔叔经常在蒙特卡洛赌场输钱得名，而蒙特卡罗方法正是以概率为基础的方法。</p>
<p>蒙特卡洛是摩纳哥的一个小城，蒙特卡洛是<a href="https://baike.baidu.com/item/摩纳哥/127488">摩纳哥</a>公国的一座城市，位于欧洲<a href="https://baike.baidu.com/item/地中海/11515">地中海</a>之滨、<a href="https://baike.baidu.com/item/法国/1173384">法国</a>的东南方，属于一个版图很小的国家<a href="https://baike.baidu.com/item/摩纳哥公国/4428850">摩纳哥公国</a>，世人称之为“赌博之国”、“袖珍之国”、“邮票小国” ， 很漂亮的一座小城。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/MonteCarlo.jpg" alt=""></p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li><p>不是 “蒙特卡洛” 发明的，“蒙特卡洛”仅仅是一个城市的名字。由冯·诺依曼、乌拉姆等人发明。这是基于概率的方法的一个统称。</p>
</li>
<li><p>常于拉斯维加斯（Las Vegas）方法比较。两种方法各有侧重点：</p>
<p>蒙特卡洛（Monte Carlo）：民意调查——抽样，并估算到最优解。采样越多，越近似最优解。</p>
<p>拉斯维加斯（Las Vegas）：找人——必须要精确到找到那个人。采样越多，越有机会找到最优解。</p>
</li>
<li><p>相关算法：</p>
<p>蒙特卡洛算法、蒙特卡洛模拟、蒙特卡洛过程、蒙特卡洛搜索树（AlphaGo就是基于此算法）</p>
</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>不断抽样（近似采样），逐渐逼近最优解。</p>
<h3 id="为什么要采样（采样动机）？"><a href="#为什么要采样（采样动机）？" class="headerlink" title="为什么要采样（采样动机）？"></a>为什么要采样（采样动机）？</h3><ul>
<li>采样本身就是常见的任务：机器学习中，产生一堆样本，然后进行采样分析。</li>
<li><code>求和</code>或者是<code>求积分</code>的运算（比如下面的例子）。</li>
</ul>
<h3 id="假定已经采样完毕，那么什么是好的样本？"><a href="#假定已经采样完毕，那么什么是好的样本？" class="headerlink" title="假定已经采样完毕，那么什么是好的样本？"></a>假定已经采样完毕，那么什么是好的样本？</h3><ul>
<li>样本趋向于高概率区域（同时兼顾其他区域）：红色球区域</li>
<li>样本与样本之间相互独立： 也就是说 在下图红色球最密集区域的球不能有相互联系，不然依然是采样失败的，不能算好的样本。</li>
</ul>
<p>如下图的概率密度函数图所示，只有样本落在高概率的区域，越集中的样本才算是好的样本（红色球），相反的，绿色球样本就不算是好的样本</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/mtclpf.svg" alt=""></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>利用蒙特卡洛方法计算圆周率<code>pi</code> 。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/pi.png" style="zoom: 67%;" /></p>
<p>从上面可得，扇形的面积$S<em>扇 = \pi·1^2·1 ·\frac{1}{4}=\frac{\pi}{4}$。正方形的面积为$S</em>方 = 1$ ，可得：一个关系如下：</p>
<script type="math/tex; mode=display">
\frac {扇形面积}{正方形面积} = \frac{\pi}{4}</script><p>接下来，如果在下面的图中随机<strong>打点</strong>，那么点落在绿色扇形区域的概率就是$P = \frac {扇形面积}{正方形面积} = \frac{\pi}{4}$ ，并最终得到 $\pi = 4P$</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201208140817233.png" alt="image-20201208140817233"></p>
<p>在程序中实现我们的算法：可以发现，随着样本空间的增加，利用蒙特卡洛算法得到$\pi$ 的值越接近真实的$\pi$ 值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">total = <span class="number">1000000</span></span><br><span class="line">in_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">    x = random.random()</span><br><span class="line">    y = random.random()</span><br><span class="line"></span><br><span class="line">    dis = (x ** <span class="number">2</span> + y ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dis &lt;= <span class="number">1</span>:</span><br><span class="line">        in_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Π是:&#x27;</span>, <span class="number">4</span>*in_count/total)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PI = 概率 * 4</span></span><br><span class="line"><span class="comment"># 5       Π是: 4.0</span></span><br><span class="line"><span class="comment"># 100     Π是: 3.28</span></span><br><span class="line"><span class="comment"># 1000    Π是: 3.244</span></span><br><span class="line"><span class="comment"># 10000   Π是: 3.1524</span></span><br><span class="line"><span class="comment"># 100000  Π是: 3.15212</span></span><br><span class="line"><span class="comment"># 1000000 Π是: 3.141696</span></span><br></pre></td></tr></table></figure>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>现在进行一个简单的应用，对于上面的规则形状，我们可以很方便的计算出图像的面积，但是对于不规则的图形，就不是那么容易求得了，这里就用蒙特卡洛方法进行计算不规则图形的面积。如下图，如果我们计算图中白色区域的面积，该如何去求得呢？</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201208192324680.png" alt="image-20201208192324680"></p>
<p>根据，蒙特卡洛方法，我们还是采用“打点”的方式，总点数为 <code>total_count</code> ，在白色区域的点数为<code>in_count</code>。那么点落在白色区域的概率就是 <code>in_count/total_count</code>，最后用这个概率乘以整张图的面积，就可以大概的估算出白色区域的面积，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span>  Image</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;panda.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取像素的颜色</span></span><br><span class="line">total_count = <span class="number">1000000</span></span><br><span class="line">in_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_count):</span><br><span class="line">    x = random.randint(<span class="number">0</span>, img.width-<span class="number">1</span>)</span><br><span class="line">    y = random.randint(<span class="number">0</span>, img.height-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># color = img.getpixel((x, y))</span></span><br><span class="line">    <span class="comment"># print(color)</span></span><br><span class="line">    <span class="keyword">if</span> img.getpixel((x, y)) == (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>):</span><br><span class="line">        in_count += <span class="number">1</span></span><br><span class="line">p = in_count/total_count</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(img.width*img.height * p))</span><br><span class="line"><span class="comment"># 20        132240</span></span><br><span class="line"><span class="comment"># 100       143811</span></span><br><span class="line"><span class="comment"># 1000      131744</span></span><br><span class="line"><span class="comment"># 10000     130388</span></span><br><span class="line"><span class="comment"># 100000    130739</span></span><br><span class="line"><span class="comment"># 1000000   130699</span></span><br><span class="line"><span class="comment"># 1.图片读取</span></span><br></pre></td></tr></table></figure>
<p>接下来进行一个准确的遍历。也就是白色区域的真正的面积值，可以发现，和上面的几乎一致，利用蒙特卡洛算法得到的是 130699，准确的数据是130686， 相差无几。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># right: 130686</span></span><br><span class="line"><span class="comment"># 1.图片读取</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span>  Image</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;panda.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取像素的颜色</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(img.height):</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) == img.getpixel((x,y)):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.bilibili.com/video/BV1Gs411g7EJ?t=1690">https://www.bilibili.com/video/BV1Gs411g7EJ?t=1690</a></p>
]]></content>
      <tags>
        <tag>统计学反思</tag>
      </tags>
  </entry>
  <entry>
    <title>FACETS Testing CNV</title>
    <url>/2020/06/09/2020-06-09-CNV-Facets%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8Bcnv/</url>
    <content><![CDATA[<h1 id="FACETS"><a href="#FACETS" class="headerlink" title="FACETS"></a>FACETS</h1><p>facets is CNV detection software with using the ascn principle </p>
<h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>first Let’s look at the test data given </p>
<p><img src="/img/facets/1591690799039.png" alt="1591690799039"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chromosome Chromosome of the SNP</span><br><span class="line">Position Position of the SNP</span><br><span class="line">File1R Read depth supporting the REF allele in normal sample</span><br><span class="line">File1A Read depth supporting the ALT allele in normal sample</span><br><span class="line">File2R Read depth supporting the REF allele in tumour sample</span><br><span class="line">File2A Read depth supporting the ALT allele in tumour sample</span><br></pre></td></tr></table></figure>
<p>The software comes with a comparison program, as shown in IGV</p>
<p><img src="/img/facets/1591691071264.png" alt="1591691071264.png"><br>unlike other software ,facets calulates the depth of snp in each bin ,normal CNV software only calculates the depth of each bin then using CBS process.</p>
<h3 id="next-it-Count-whether-the-sum-of-ref-and-alt-of-each-snp-is-heterozygous"><a href="#next-it-Count-whether-the-sum-of-ref-and-alt-of-each-snp-is-heterozygous" class="headerlink" title="next it Count whether the sum of ref and alt of each snp is heterozygous"></a>next it Count whether the sum of ref and alt of each snp is heterozygous</h3><p><img src="/img/facets/1591691653200.png" alt="1591691653200.png"></p>
<h3 id="the-result-is"><a href="#the-result-is" class="headerlink" title="the result is"></a>the result is</h3><p><img src="/img/facets/1591691763518.png" alt="1591691763518.png"></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>$1R = REF-N$</p>
<p>$1A = ALT-N$</p>
<p>$2R = REF-T$</p>
<p>$2A = ALT-T$</p>
<h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><p>$1R=countN=N-RD$</p>
<p>$2R=countT=T-RD$</p>
<p>$N-DP=1R+1A$</p>
<p>$T-DP=2R+2A$</p>
<p>$varT=\frac {T-RD} {T-DP}$</p>
<p>$varN=\frac {N-RD} {N-DP}$</p>
<h3 id="as-the-picture-shows"><a href="#as-the-picture-shows" class="headerlink" title="as the picture shows"></a>as the picture shows</h3><p><img src="/img/facets/1591692248504.png" alt="1591692248504.png"></p>
<p>Then the software starts to calculate logR and logOR and gcbias<br>the gcbias plaes look this blog <a href="http://www.zxzyl.com/archives/988">http://www.zxzyl.com/archives/988</a></p>
<p>the logR is<br>    $ncount &lt;- tapply(rCountN, gcpct, sum)$</p>
<pre><code>$tcount &lt;- tapply(rCountT, gcpct, sum)$

$tsc1=\frac &#123;sum(ncount)&#125; &#123;sum(tcount)&#125;$

$log2(1+rCountT*tscl) - log2(1+rCountN) - gcbias$
</code></pre><p>the logOR is<br>    $1 = varT x countT$</p>
<pre><code>$2 = (1-varT) x countT $

$3 = varN x countN$

$4 = (1-varN) x countN$

than 
## log-odds-ratio (Haldane correction)

$logOR = log(1+0.5)-log(2+0.5)-log(3+0.5)+log(4+0.5) $
## variance of log-odds-ratio (Haldane; Gart &amp; Zweifel Biometrika 1967)

$logOR = (\frac &#123;1&#125; &#123;( [,1]+0.5)&#125; + \frac &#123;1&#125; &#123;( [,2]+0.5)&#125; + \frac &#123;1&#125; &#123;( [,3]+0.5)&#125; + \frac &#123;1&#125; &#123;( [,4]+0.5))&#125;$
</code></pre><h3 id="The-following-steps-are-the-EM-algorithm-here-they-use-Bayesian-in-step-E-to-get-the-posterior-probability"><a href="#The-following-steps-are-the-EM-algorithm-here-they-use-Bayesian-in-step-E-to-get-the-posterior-probability" class="headerlink" title="The following steps are the EM algorithm, here they use Bayesian in step E to get the posterior probability,"></a>The following steps are the EM algorithm, here they use Bayesian in step E to get the posterior probability,</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">####LogR mixture model parameter####</span><br><span class="line">    gamma=2</span><br><span class="line">    phi=2*(1-rho)+gamma*rho</span><br><span class="line">    mu=log2(2*(1-rhov)+matrix(rhov,ncol=1)%*%t)-log2(phi)</span><br><span class="line"></span><br><span class="line">    ####LogOR mixture model parameter####</span><br><span class="line">    #allelic ratio</span><br><span class="line">    k=(matrix(rhov,ncol=1)%*%major+1-rhov)/(matrix(rhov,ncol=1)%*%minor+1-rhov)</span><br><span class="line">    logk=log(k)</span><br><span class="line">    logk2=logk^2</span><br><span class="line"></span><br><span class="line">    #posterior probability matrix</span><br><span class="line">    #pmatrix=NULL</span><br><span class="line">    pmatrix=matrix(NA,nrow=nrow(jointseg),ncol=ng)</span><br><span class="line">    loglik=0</span><br><span class="line"></span><br><span class="line">    clust=rep(segclust,nmark)</span><br><span class="line">    segc=sort(unique(segclust[chr&lt;=nX]))</span><br><span class="line">    for(s in segc)&#123;</span><br><span class="line">      idx=which(clust==s)</span><br><span class="line">      x1ij=logR.adj[idx]</span><br><span class="line">      upper=quantile(x1ij,0.95)</span><br><span class="line">      lower=quantile(x1ij,0.05)</span><br><span class="line">      x1ij[x1ij&gt;upper]=NA</span><br><span class="line">      x1ij[x1ij&lt;lower]=NA</span><br><span class="line">      mus=rep(mu[s,],each=length(idx))</span><br><span class="line">      sd=sigma[s]</span><br><span class="line">      if(rhov[s]&lt;0.4)&#123;</span><br><span class="line">        x1ij=rep(cnlr.median.clust[s]-dipLogR,length(idx))</span><br><span class="line">        sd=0.1</span><br><span class="line">        &#125;</span><br><span class="line">      #density for logR.adj (centered logR)</span><br><span class="line">      d1=dnorm(x1ij,mean=mus,sd=sd)</span><br><span class="line">      d1[d1==Inf]=NA</span><br><span class="line"></span><br><span class="line">      #density for logOR, non-central chi-square</span><br><span class="line">      nu=rep(logk2[s,],each=length(idx))</span><br><span class="line">      lambda=nu/rep(logORvar[idx],ng)</span><br><span class="line">      x2ij=logOR2var[idx]</span><br><span class="line">      if(rhov[s]&lt;0.4)&#123;</span><br><span class="line">        x2ij=rep(mafR.clust[s]/logORvar.clust[s],length(idx))</span><br><span class="line">        lambda=nu/logORvar.clust[s]</span><br><span class="line">        &#125;</span><br><span class="line">      #d2=dchisq(x2ij+1,df=1,ncp=lambda)</span><br><span class="line">      d2=dchisq(x2ij,df=1,ncp=lambda)</span><br><span class="line">      d2=1/(abs(x2ij-lambda)+1e-6)</span><br><span class="line">      d2[d2==Inf]=NA</span><br><span class="line"></span><br><span class="line">      #likelihood</span><br><span class="line">      d=d1*d2</span><br><span class="line">      hetsum=d[rep(het[idx]==1,ng)]</span><br><span class="line">      homsum=d1[rep(het[idx]==0,ng)]</span><br><span class="line">      d=sum(hetsum[hetsum&lt;Inf],na.rm=T)+sum(homsum[homsum&lt;Inf],na.rm=T)</span><br><span class="line">      if(!is.na(d)&amp;d&gt;0&amp;d&lt;Inf)&#123;loglik=loglik+log(d)&#125;</span><br><span class="line"></span><br><span class="line">      #heterozygous positions contribute to logR and logOR</span><br><span class="line">      numerator1=matrix(d1*d2,nrow=length(idx),ncol=ng,byrow=F)</span><br><span class="line">      numerator1=sweep(numerator1,MARGIN=2,prior[s,],`*`)</span><br><span class="line"></span><br><span class="line">      #homozygous positions contribute to logR only</span><br><span class="line">      numerator0=matrix(d1,nrow=length(idx),ncol=ng,byrow=F)</span><br><span class="line">      numerator0=sweep(numerator0,MARGIN=2,prior[s,],`*`)</span><br><span class="line"></span><br><span class="line">      numerator=numerator1</span><br><span class="line">      numerator[het[idx]==0,]=numerator0[het[idx]==0,]</span><br><span class="line"></span><br><span class="line">      tmp=apply(numerator,1,function(x)x/(sum(x,na.rm=T)+1e-5))</span><br><span class="line">      #pmatrix=rbind(pmatrix,t(tmp))</span><br><span class="line">      pmatrix[idx,]=t(tmp)</span><br><span class="line"></span><br><span class="line">      #update prior</span><br><span class="line">      prior[s,]=apply(t(tmp),2,function(x)mean(x,na.rm=T))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/facets/1591695237945.png" alt="1591695237945.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###  the M step is </span><br><span class="line">#get CF per segments, pick mode close to 1 (favor high purity low cn solution)</span><br><span class="line">    rhom=gammam=matrix(NA,nrow=nclust,ncol=ng)</span><br><span class="line">    geno=matrix(0,nrow=nclust,ncol=ng)</span><br><span class="line">    which.geno=posterior=rep(NA,nclust)</span><br><span class="line">    for(i in segc)&#123;</span><br><span class="line"></span><br><span class="line">      idx=which(clust==i)</span><br><span class="line">      idxhet=which(clust==i&amp;het==1)</span><br><span class="line">      sump=apply(pmatrix[idx,,drop=F],2,function(x)sum(x,na.rm=T))</span><br><span class="line"></span><br><span class="line">      #if probability is too small (highly uncertain), use lsd estimates for stability </span><br><span class="line">      if(all(is.na(prior[i,])))&#123;</span><br><span class="line">        prior[i,]=prior.old[i,]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        if(sum(prior[i,],na.rm=T)==0)prior[i,]=prior.old[i,]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      if(max(prior[i,],na.rm=T)&gt;0.05)&#123;   </span><br><span class="line"></span><br><span class="line">      ##calculate rho for the most likely genotype(s) for segment i</span><br><span class="line">      ##if there more more than one likely candidates save two and pick one with higher CF</span><br><span class="line">      #top2=sort(prior[i,],decreasing=T)[1:2]</span><br><span class="line">      #if(top2[2]&gt;0.05&amp;abs(diff(top2))&lt;0.0001)&#123;</span><br><span class="line">      #    sump[prior[i,]&lt;quantile(prior[i,],(ng-2)/ng)]=NA</span><br><span class="line">      # &#125;else&#123;</span><br><span class="line">      #    sump[prior[i,]&lt;max(prior[i,])]=NA</span><br><span class="line">      # &#125;</span><br><span class="line"></span><br><span class="line">      sump[prior[i,]&lt;max(prior[i,])]=NA</span><br><span class="line"></span><br><span class="line">        ##update k</span><br><span class="line">        tmphet=pmatrix[idxhet,,drop=F]</span><br><span class="line">        v1=as.vector((logOR[idxhet]^2-logORvar[idxhet])/logORvar[idxhet])</span><br><span class="line">        v2=as.vector(1/logORvar[idxhet])</span><br><span class="line">        sumdphet=apply(sweep(tmphet,MARGIN=1, v1, `*`), 2,function(x)sum(x,na.rm=T))</span><br><span class="line">        sumphet=apply(sweep(tmphet,MARGIN=1,v2,`*`), 2,function(x)sum(x,na.rm=T))</span><br><span class="line">        sumphet[is.na(sump)]=NA</span><br><span class="line"></span><br><span class="line">        #CF from logOR    </span><br><span class="line">        logk2hat=pmax(0,sumdphet/sumphet) #can be negative when k=1 logk=0 set to 0</span><br><span class="line">        khat=exp(sqrt(logk2hat))</span><br><span class="line">        a=(1-khat)/(khat*(minor-1)-(major-1))</span><br><span class="line">        a[abs(a)==Inf]=NA</span><br><span class="line">        a[a&lt;=0]=NA</span><br><span class="line">        a[a&gt;1]=1</span><br><span class="line">        if(all(nhet[segclust==i]&lt;min.nhet))a=rep(NA,ng)</span><br><span class="line"></span><br><span class="line">        #CF from logR</span><br><span class="line">        tmp=pmatrix[idx,,drop=F]</span><br><span class="line">        v=as.vector(logR.adj[idx])</span><br><span class="line">        sumdp=apply(sweep(tmp,MARGIN=1,v,`*`),2,function(x)sum(x,na.rm=T))   </span><br><span class="line">        mu.hat=sumdp/sump #mu.hat</span><br><span class="line">        aa=2*(2^mu.hat-1)/(t-2)</span><br><span class="line">        aa[abs(aa)==Inf]=NA</span><br><span class="line">        aa[aa&lt;=0]=NA</span><br><span class="line">        aa[aa&gt;1]=1</span><br><span class="line"></span><br><span class="line">        aaa=pmax(a,aa,na.rm=T)</span><br><span class="line">        #degenerate cases</span><br><span class="line">        #homozygous deletion (0) and balanced gain (AABB, AAABBB), maf=0.5, purity information comes from logr only</span><br><span class="line">        aaa[c(1,8,13)]=aa[c(1,8,13)]  </span><br><span class="line"></span><br><span class="line">        #set upper bound at sample rho</span><br><span class="line">        aaa=pmin(aaa,rho)</span><br><span class="line"></span><br><span class="line">        #uniparental disomy (AA) CF information comes from logOR only.</span><br><span class="line"></span><br><span class="line">        ##if there are two likely genotype, choose one with higher purity (e.g.,AAB 80% or AAAB 50%)</span><br><span class="line">        ##if the higher CF exceeds sample purity, then the lower CF is the right one</span><br><span class="line">        #if(all(is.na(aaa)))&#123;which.geno[i]=which.max(prior[i,])&#125;else&#123;</span><br><span class="line">        #  which.geno[i]=ifelse(max(aaa,na.rm=T)&lt;rho,which.max(aaa),which.min(aaa))</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        which.geno[i]=which.max(prior[i,])</span><br><span class="line"></span><br><span class="line">        postprob=pmatrix[idx,which.geno[i]]</span><br><span class="line">        posterior[i]=mean(postprob[postprob&gt;0],na.rm=T)</span><br><span class="line"></span><br><span class="line">        #update sigma</span><br><span class="line">        y=as.vector(logR.adj[idx])*pmatrix[idx,,drop=F]</span><br><span class="line">        r=y-mu[i,]*pmatrix[idx,,drop=F]</span><br><span class="line">        ss=sqrt(sum(r[,which.geno[i]]^2,na.rm=T)/sum(pmatrix[idx,which.geno[i]])) </span><br><span class="line">        sigma[i]=ifelse(is.na(ss),0.5,ss)</span><br><span class="line"></span><br><span class="line">        aaa[setdiff(1:ng,which.geno[i])]=NA  </span><br><span class="line"></span><br><span class="line">        #het dip (AB) seg has no information, set CF at a high value less than 1</span><br><span class="line">        #if(any(which(!is.na(sump))==4))&#123;aaa[4]=0.9&#125;</span><br><span class="line"></span><br><span class="line">        rhom[i,]=aaa </span><br><span class="line"></span><br><span class="line">      &#125; #max prior</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/facets/1591695253756.png" alt="1591695253756.png"></p>
<h3 id="Loop-until-it-converges"><a href="#Loop-until-it-converges" class="headerlink" title="Loop until it converges"></a>Loop until it converges</h3><h2 id="Or-simpler-also-use-the-CBS-algorithm-instead-it"><a href="#Or-simpler-also-use-the-CBS-algorithm-instead-it" class="headerlink" title="Or simpler, also use the CBS algorithm instead it"></a>Or simpler, also use the CBS algorithm instead it</h2><h1 id="picard方式计算CNV"><a href="#picard方式计算CNV" class="headerlink" title="picard方式计算CNV"></a>picard方式计算CNV</h1><p>探针长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrom   start   end     length  </span><br><span class="line">chr1    12080   12251   172 </span><br><span class="line">chr1    12595   12802   208</span><br></pre></td></tr></table></figure>
<p>normalized_coverage : for each target interval, the read depth (unique read starts) that correspond to a particular target interval is divided by the average number of read starts in all of the target intervals.</p>
<h4 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrom   start   end     length   normalized_coverage    gene</span><br><span class="line">chr1    12080   12251   172        0                    DDX11L1</span><br><span class="line">chr1    12595   12802   208        0.002957             DDX11L1</span><br></pre></td></tr></table></figure>
<h4 id="tumor"><a href="#tumor" class="headerlink" title="tumor"></a>tumor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrom   start   end     length   normalized_coverage   gene</span><br><span class="line">chr1    12080   12251   172        0                   DDX11L1</span><br><span class="line">chr1    12595   12802   208        0.011583            DDX11L1</span><br></pre></td></tr></table></figure>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>例如gene  EGFR</p>
<p>片段长度</p>
<p>$length = L1 L2  L3  L4  L5$</p>
<p>归一化覆盖:</p>
<p>$Tn = Tn<em>{1}\ Tn</em>{2}\ Tn<em>{3}\ Tn</em>{4}\ Tn_{5}$</p>
<p>$Nn = Nn<em>{1}\ Nn</em>{2}\ Nn<em>{3}\ Nn</em>{4}\ Nn_{5}$</p>
<p>计算 :<br>$\frac {(L1(\frac {Tn<em>{1}} {Nn</em>{1}})+L2(\frac {Tn<em>{2}} {Nn</em>{2}})+·····)} {L1+···L5} =copy\ number\ ratio$</p>
]]></content>
      <tags>
        <tag>生信</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学反思-01-贝叶斯建模</title>
    <url>/2021/02/05/2021-02-05-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%8F%8D%E6%80%9D-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <tags>
        <tag>统计学反思</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习—免模型预测</title>
    <url>/2021/10/02/2021-10-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-04-%E5%85%8D%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="强化学习—免模型预测"><a href="#强化学习—免模型预测" class="headerlink" title="强化学习—免模型预测"></a>强化学习—免模型预测</h1><blockquote>
<p>作者：YJLAugus  博客： <a href="https://www.cnblogs.com/yjlaugus">https://www.cnblogs.com/yjlaugus</a> 项目地址：<a href="https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star">https://github.com/YJLAugus/Reinforcement-Learning-Notes，如果感觉对您有所帮助，烦请点个⭐Star</a>。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第二章<a href="https://www.yuque.com/yjlaugus/reinforcement-learning-notes/wfea35">强化学习-动态规划-DP</a>中，我们讨论了用动态规划来求解强化学习预测问题和控制问题的方法。但是由于动态规划法需要在每一次回溯更新某一个状态的价值时，回溯到该状态的所有可能的后续状态。导致对于复杂问题计算量很大。同时很多时候，我们连环境的<strong>动态特性</strong> $P$ 都无法知道，这时动态规划法根本没法使用。这时候我们如何求解强化学习问题呢？</p>
<p>从本章开始将花连续两讲的时间讨论解决一个可以被认为是MDP、但却不掌握MDP具体细节的问题，也就是讲述<strong>如何直接从Agent与环境的交互来得得到一个估计的最优价值函数和最优策略</strong>。这部分内容同样分为两部分，第一部分也就是本章的内容，聚焦于策略评估，也就是预测，直白的说就是在给定的策略同时不清楚MDP细节的情况下，估计Agent会得到怎样的最终奖励。下一讲将利用本章的主要观念来进行控制进而找出最优策略，最大化Agent的奖励。</p>
<p>本章内容分为三个小部分，分别是<strong>蒙特卡洛强化学习</strong>、<strong>时序差分强化学</strong>习和介于两者之间的<strong>λ时序差分强化学习</strong>。相信读者在阅读本讲内容后会对这三类学习算法有一定的理解。</p>
<p>其中在第三章<a href="https://www.yuque.com/yjlaugus/reinforcement-learning-notes/gw7d7v"><strong>蒙特卡洛（Markov Chain &amp; Monte Carlo, MCMC）方法</strong></a> 对蒙特卡洛方法进行了一个简单的介绍，这样对于这一章节问题的解决会有很多帮助。</p>
<h2 id="免模型的强化学习问题定义"><a href="#免模型的强化学习问题定义" class="headerlink" title="免模型的强化学习问题定义"></a>免模型的强化学习问题定义</h2><p>在动态规划法中，强化学习的两个问题是这样定义的：</p>
<ul>
<li><p>预测问题，即给定强化学习的6个要素：状态集 $S$, 动作集 $A$, 模型状态转化概率矩阵$P$, 即时奖励 $R$，衰减因子$\gamma$, 给定策略 $\pi$，求解该策略的状态价值函数 $v_{π}$。</p>
</li>
<li><p>控制问题，也就是求解最优的价值函数和策略。给定强化学习的5个要素：状态集 $S$, 动作集 $A$, 模型状态转化概率矩阵$P$, 即时奖励 $R$，衰减因子$\gamma$, 给定策略 $\pi$， 求解最优的状态价值函数$v<em>*$和最优策略$\pi</em>*$</p>
</li>
</ul>
<p>可见，<strong>模型状态转化概率矩阵$P$始终是已知的，即MDP已知</strong>，对于这样的强化学习问题，我们一般称为<strong>基于模型的强化学习问题</strong>。</p>
<p>不过有很多强化学习问题，我们没有办法事先得到模型状态转化概率矩阵$P$，这时如果仍然需要我们求解强化学习问题，那么这就是不基于模型的强化学习问题了——<strong>免模型的强化学习</strong>。它的两个问题一般的定义是：</p>
<ul>
<li><p>预测问题，即给定强化学习的5个要素：状态集$S$, 动作集$A$ 即时奖励$R$，衰减因子$\gamma$，给定策略$\pi$， 求解该策略的状态价值函数$v_\pi$</p>
</li>
<li><p>控制问题，也就是求解最优价值函数和策略。给定强化学习的5个要素：状态集$S$, 动作集$A$, 即时奖励$R$，衰减因子$\gamma$, <strong>探索率 $\epsilon$</strong> , 求解最优的动作价值函数$q<em>*$和最优策略$\pi</em>*$</p>
</li>
</ul>
<p>本章节要讨论的蒙特卡洛方法就是上述免模型的强化学习问题。</p>
<h2 id="蒙特卡洛强化学习-Monte-Carlo-Reinforcement-Learning"><a href="#蒙特卡洛强化学习-Monte-Carlo-Reinforcement-Learning" class="headerlink" title="蒙特卡洛强化学习 (Monte-Carlo Reinforcement Learning)"></a>蒙特卡洛强化学习 (Monte-Carlo Reinforcement Learning)</h2><h3 id="蒙特卡洛强化学习概念"><a href="#蒙特卡洛强化学习概念" class="headerlink" title="蒙特卡洛强化学习概念"></a>蒙特卡洛强化学习概念</h3><p>蒙特卡洛强化学习：是在不清楚MDP状态转移及即时奖励的情况下，直接从经历完整的<code>Episode</code>来学习状态价值，通常情况下某状态的价值等于在多个Episode中以该状态算得到的所有收获的平均。</p>
<blockquote>
<p>Episode ：agent根据某个策略执行一系列action到结束就是一个episode。</p>
</blockquote>
<p>注：<strong>收获</strong>不是针对Episode的，它存在于Episode内，针对于Episode中某一个状态。从这个状态开始经历完Episode时得到的有衰减的即时奖励的总和。从一个Episode中，我们可以得到该Episode内所有状态的收获。当一个状态在Episode内出现多次，该状态的收获有不同的计算方法，下文会讲到。</p>
<p><strong>完整的Episode</strong> 指必须从某一个状态开始，Agent与Environment交互直到<strong>终止状态</strong>，环境给出终止状态的即时收获为止。</p>
<h3 id="蒙特卡洛强化学习特点"><a href="#蒙特卡洛强化学习特点" class="headerlink" title="蒙特卡洛强化学习特点"></a>蒙特卡洛强化学习特点</h3><p>蒙特卡洛强化学习有如下特点：不基于模型本身，直接从经历过的Episode中学习，必须是<strong>完整的Episode</strong>，使用的思想就是用平均收获值代替价值。理论上Episode越多，结果越准确。</p>
<p>蒙特卡罗法通过采样若干经历完整的<code>状态序列(episode)</code>来估计状态的真实价值。所谓的经历完整，就是这个序列必须是达到终点的。比如下棋问题分出输赢，驾车问题成功到达终点或者失败。有了很多组这样经历完整的状态序列，我们就可以来近似的估计状态价值，进而求解预测和控制问题了。</p>
<h3 id="蒙特卡洛策略评估-Monte-Carlo-Policy-Evaluation"><a href="#蒙特卡洛策略评估-Monte-Carlo-Policy-Evaluation" class="headerlink" title="蒙特卡洛策略评估 (Monte-Carlo Policy Evaluation)"></a>蒙特卡洛策略评估 (Monte-Carlo Policy Evaluation)</h3><blockquote>
<p><strong>目标：</strong>在给定策略下，从一系列的完整Episode经历中学习,最后求得到该策略下的状态价值函数。</p>
</blockquote>
<p>在解决问题过程中主要使用的信息是一系列完整Episode。其包含的信息有：状态的转移、使用的行为序列、中间状态获得的即时奖励以及到达终止状态时获得的即时奖励。其特点是使用有限的、完整Episode产生的这些经验性信息经验性地推导出每个状态的平均收获，以此来替代收获的期望，而后者就是状态价值。通常需要掌握完整的MDP信息才能准确计算得到。</p>
<p>数学描述如下：</p>
<p>基于特定策略 $\pi$ 的一个Episode信息可以表示为如下的一个序列：</p>
<script type="math/tex; mode=display">
\large S_1,A_1,R_2,...,S_k\backsim\pi</script><p>$t$ 时刻，$S_t$ 的收获：</p>
<script type="math/tex; mode=display">
\large G_t = R_{t+1}+\gamma R_{t+2}+...+\gamma ^{T-1}R_T</script><p>其中，$T$ 为终止时刻。</p>
<p>该策略下某一状态 $s$ 的价值：</p>
<script type="math/tex; mode=display">
\large v_\pi(s) = E_\pi[G_t \rvert S_t = s]</script><blockquote>
<p>注： $R_{t+1}$ 表示的是 $t$时刻agent在状态 $S_t$ 获得的即时奖励，下文都使用这种下标来表示即时奖励。更准确的表述为：个体在状态 $S_t$ 执行一个行为$a$ 后离开该状态获得的即时奖励。</p>
</blockquote>
<p>很多时候，即时奖励只出现在Episode结束状态时，但不能否认在中间状态也可能有即时奖励。公式里的 $R_t$ 指的是<strong>任何状态</strong>得到的即时奖励，这一点尤其要注意。</p>
<p>在状态转移过程中，可能发生一个状态经过一定的转移后又一次或多次返回该状态，此时在一个Episode里如何计算这个状态发生的次数和计算该Episode的收获呢？可以有如下两种方法：</p>
<h4 id="首次访问蒙特卡洛策略评估"><a href="#首次访问蒙特卡洛策略评估" class="headerlink" title="首次访问蒙特卡洛策略评估"></a>首次访问蒙特卡洛策略评估</h4><p>在给定一个策略，使用一系列完整Episode评估某一个状态s时，对于每一个Episode，仅当该状态<strong>第一次</strong>出现在一个 episode中时：</p>
<ul>
<li>状态出现的次数加1 ：$N(s) \leftarrow N(s) + 1$</li>
<li>总的收获更新：$S(s) \leftarrow S(s) + G_t$</li>
<li>状态 s 的价值：$V(s) = S(s)/N(s)$</li>
</ul>
<p>当 $N(s) \rightarrow \infty$ 时，$V(s)\rightarrow v_\pi(s)$</p>
<h4 id="每次访问蒙特卡洛策略评估"><a href="#每次访问蒙特卡洛策略评估" class="headerlink" title="每次访问蒙特卡洛策略评估"></a>每次访问蒙特卡洛策略评估</h4><p>在给定一个策略，使用一系列完整Episode评估某一个状态s时，对于每一个Episode，状态 s <strong>每次</strong>出现在一个epospde中时：</p>
<ul>
<li>状态出现的次数加1 ：$N(s) \leftarrow N(s) + 1$</li>
<li>总的收获更新：$S(s) \leftarrow S(s) + G_t$</li>
<li>状态 s 的价值：$V(s) = S(s)/N(s)$</li>
</ul>
<p>当 $N(s) \rightarrow \infty$ 时，$V(s)\rightarrow v_\pi(s)$。计算的公式与 <strong>首次访问蒙特卡洛策略评估</strong> 的公式相同，但是具体的意义却不同，下一以一个简单的例子进行说明。</p>
<p><strong>二十一点</strong> 二十一点又名黑杰克（Blackjack），是一种流行于赌场的游戏，其目标是使得你的扑克牌点数之和不超过21的情况下越大越好。K、Q、J和10牌都算作10点（一般记作T，即ten之意）；A 牌（ace）既可算作1点也可算作11点，由玩家自己决定（当玩家停牌时，点数一律视为最大而尽量不爆，如A+9为20，A+4+8为13，A+3+A视为15）。游戏开始时，会给玩家和庄家各发两张牌。庄家的牌一张正面朝上，一张背面朝上，玩家两张都是明牌（都正面朝上）如果玩家的两张牌分别是一张A，一张10点（可能是10，J， Q，K），这种情况称为<strong>天和</strong>，玩家直接获胜。除非庄家也是天和，那就是平局。如果玩家不是天和，那么他可以一张一张地继续要牌，直到他主动停止（停牌）或者牌的点数和超过21点（爆牌）。如果玩家选择停牌，就轮到庄家行动。庄家根据一个固定的策略进行游戏：他一直要牌，直到点数等于或超过17时停牌。如果庄家爆牌，那么玩家获胜，否则根据谁的点数更靠近21决定胜负或者平局。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/blackj.jpg" alt=""></p>
<p>根据以上游戏规则，我们得到如下信息：</p>
<p><strong>状态空间：</strong> （多达200种，根据对状态的定义可以有不同的状态空间，这里采用的定义是牌的分数，不包括牌型）</p>
<ul>
<li>当前牌的分数（12 - 21），低于12时，你可以安全的再叫牌，所以没意义。</li>
<li>庄家出示的牌（A - 10），庄家会显示一张牌面给玩家，另一张为暗牌。</li>
<li>我有“useable” ace吗？（是或否）A既可以当1点也可以当11点。</li>
</ul>
<p><strong>行为空间：</strong></p>
<ul>
<li>停止要牌 stick</li>
<li>继续要牌 twist</li>
</ul>
<p><strong>奖励（停止要牌）：</strong></p>
<ul>
<li>+1：如果你的牌分数大于庄家分数</li>
<li>0： 如果两者分数相同</li>
<li>-1：如果你的牌分数小于庄家分数</li>
</ul>
<p><strong>奖励（继续要牌）：</strong></p>
<ul>
<li>-1：如果牌的分数&gt;21，并且进入终止状态</li>
<li>0：其它情况</li>
</ul>
<p><strong>状态转换（Transitions）</strong>：如果牌分小于12时，自动要牌</p>
<p><strong>当前策略</strong>：牌分只要小于20就继续要牌。</p>
<p><strong>求解问题：</strong>评估该策略的好坏。</p>
<p><strong>求解过程：</strong>使用庄家显示的牌面值、玩家当前牌面总分值来确定一个二维状态空间，区分手中有无A分别处理。统计每一牌局下决定状态的庄家和玩家牌面的状态数据，同时计算其最终收获。通过模拟多次牌局，计算每一个状态下的平均值，得到如下图示。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201231132127235.png" alt="image-20201231132127235"></p>
<p><strong>最终结果：</strong>无论玩家手中是否有A牌，该策略在绝大多数情况下各状态价值都较低，只有在玩家拿到21分时状态价值有一个明显的提升。</p>
<p>这个例子只是使读者对蒙特卡洛策略评估方法有一个直观的认识。</p>
<p>为了尽可能使读者对MC方法有一个直接的认识，我们尝试模拟多个二十一点游戏牌局信息，假设我们仅研究初始状态下庄家一张明牌为4，玩家手中前两张牌和为15的情形，不考虑A牌。在给定策略下，玩家势必继续要牌，根据蒙特卡洛策略评估则可能会出现如下多种情形：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>庄家总序列</th>
<th>玩家最终序列</th>
<th>玩家获得奖励</th>
<th>当前估计的状态价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>4，10，3 （17点）</td>
<td>Q，5，5（20点）</td>
<td>+1</td>
<td>+1</td>
</tr>
<tr>
<td>4，J，7（21点）</td>
<td>9，6，8（23点，爆牌）</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>4，10，2，8（24点，爆牌）</td>
<td>7，8，6（21点）</td>
<td>+1</td>
<td>0.333</td>
</tr>
<tr>
<td>4，4，2，7（17点）</td>
<td>J，5，Q（15点）</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>4，9（13点）</td>
<td>5，K，4，8（27点，爆牌）</td>
<td>-1</td>
<td>-0.2</td>
</tr>
<tr>
<td>4，3，K（17点）</td>
<td>8，7，5（20点）</td>
<td>+1</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>以上状态价值由 以下公式得出：</p>
<ul>
<li>状态出现的次数加1 ：$N(s) \leftarrow N(s) + 1$</li>
<li>总的收获更新：$S(s) \leftarrow S(s) + G_t$</li>
<li>状态 s 的价值：$V(s) = S(s)/N(s)$</li>
</ul>
<p>以前三个序列为例</p>
<ol>
<li>序列一： N = 1， S = 1，V = 1 / 1 = 1;</li>
<li>序列二： N = 2， S = 1 - 1 = 0，V = 0 / 2 = 0;</li>
<li>序列三： N = 3， S = 0 + 1 = 1，V = 1 / 3 = 0.333</li>
</ol>
<p>可以看到，使用只有当牌不小于20的时候才停止叫牌这个策略（注：庄家不需要遵从这个策略），<strong>前6次平均价值为0</strong>，如果玩的牌局足够多，按照这样的方法可以针对每一个状态（庄家第一张明牌，玩家手中前两张牌分值合计）都可以制作这样一张表，进而计算玩家奖励的平均值。通过结果，可以发现这个策略并不能带来很高的玩家奖励。</p>
<p>这里给出表中第一个对局对应的信息序列（Episode）：</p>
<script type="math/tex; mode=display">
\large S_0<4,15>, A_0<要牌>,R_1<0>,S_1<4,20>,A_1<停止要牌>，R_2<+1></script><p>可以看出，这个完整的Episode中包含两个状态，其中第一个状态的即时奖励为0，后一个状态是终止状态，根据规则，玩家赢得对局，获得终止状态的即时奖励+1。读者可以加深对即时奖励、完整Episode的理解。</p>
<p>通过上面的例子，我们使用蒙特卡洛方法求解的是<strong>平均收获</strong>，根据上面的例子，可以很清楚的知道这点。通常计算平均值就需要预先存储所有的数据，最后加和取平均，这样真的在计算机中计算时，会浪费很多空间。下面介绍一种更简单的方法——<strong>累进更新平均值（Incremental Mean）</strong></p>
<h3 id="累进更新平均值（Incremental-Mean）"><a href="#累进更新平均值（Incremental-Mean）" class="headerlink" title="累进更新平均值（Incremental Mean）"></a>累进更新平均值（Incremental Mean）</h3><p>这里提到了在实际操作时常用的一个实时更新均值的办法，使得在计算平均收获时不需要存储所有既往收获，而是每得到一次收获，就计算其平均收获。</p>
<p>理论公式如下：</p>
<script type="math/tex; mode=display">
\large{
\begin{align}
\mu_k =& \frac{1}{k}\sum_{j=1}^k x_j \\
=& \frac{1}{k}\left(x_k + \sum_{j=1}^{k-1} x_j \right) \\
=& \frac{1}{k}(x_k+(k-1)\mu_{k-1}) \\
=& \frac{1}{k}x_k+(1-\frac{1}{k})\mu_{k-1}\\
=& \mu_{k-1} + \frac{1}{k}(x_k-\mu_{k-1})

\end{align}
}</script><p>这个公式比较简单。把这个方法应用于蒙特卡洛策略评估，就得到下面的蒙特卡洛累进更新。</p>
<h3 id="蒙特卡洛累进更新"><a href="#蒙特卡洛累进更新" class="headerlink" title="蒙特卡洛累进更新"></a>蒙特卡洛累进更新</h3><p>对于一些列 Episodes中的每一个： $ S_1,A_1,R_2,…,S_k\backsim\pi $，对于Episode里的每一个状态$S_t$ ，有一个收获$G_t$，每碰到一次$S_t$ ，使用下面的公式计算状态的平均价值$V(S_t)$：</p>
<script type="math/tex; mode=display">
\large V(S_t) \leftarrow V(S_t)  + \frac{1}{N(S_t)}(G_t -  V(S_t) )</script><p>其中：</p>
<script type="math/tex; mode=display">
\large N(S_t) = N(S_t)  +1</script><p>这样我们无论数据量是多还是少，算法需要的内存基本是固定的 。</p>
<p>有时候，尤其是海量数据做分布式迭代的时候，我们可能无法准确计算当前的次数$N(S_t)$，这时我们可以用一个系数$\alpha$来代替，即：</p>
<script type="math/tex; mode=display">
\large V(S_t) = V(S_t)  + \alpha(G_t -  V(S_t) )</script><p>以上就是蒙特卡罗方法求解预测问题的整个过程。由于蒙特卡洛学习方法有许多缺点（后文会细说），因此实际应用并不多。接下来介绍实际常用的时序差分学习方法。</p>
<h2 id="时序差分学习-Temporal-Difference-Learning"><a href="#时序差分学习-Temporal-Difference-Learning" class="headerlink" title="时序差分学习 Temporal-Difference Learning"></a>时序差分学习 Temporal-Difference Learning</h2><h3 id="时序差分学习特点"><a href="#时序差分学习特点" class="headerlink" title="时序差分学习特点"></a>时序差分学习特点</h3><p>时序差分学习简称TD学习，它的特点如下：和蒙特卡洛学习一样，它也从Episode学习，不需要了解模型本身；但是它可以学习<strong>不完整</strong>的Episode，通过自身的引导（bootstrapping），猜测Episode的结果，同时持续更新这个猜测。</p>
<h3 id="时序差分策略评估"><a href="#时序差分策略评估" class="headerlink" title="时序差分策略评估"></a>时序差分策略评估</h3><p>我们已经学过，在Monte-Carlo学习中，使用实际的收获（return）$G_t$来更新价值（Value）：</p>
<script type="math/tex; mode=display">
\large V(S_t) = V(S_t)  + \alpha(G_t -  V(S_t) ) \tag1</script><p>由第一章的收获公式(注：收获/回报都是$G_t$，以后两者不会特别区分)可得：</p>
<script type="math/tex; mode=display">
\large
G_t = R_{t+1} + \gamma R_{t+2}+\gamma^2 R_{t+3} \ ...\ +\gamma^{T-1}R_T = \sum_{i=0}^{\infty}\gamma^i R_{t+i+1} \quad \quad \gamma\in[0,1],\quad (T\rightarrow\infty)</script><blockquote>
<p>注： $T$ 用来指示 $R$ 的下标，表明是第几个 $R$</p>
</blockquote>
<p>如果用$G_t$ 来更新价值的话，就可以写成如下：</p>
<script type="math/tex; mode=display">
\large
G_t = R_{t+1} + \gamma V{(S_{t+1})} \tag2</script><p>在TD学习中，算法在估计某一个状态的价值时，用的是离开该状态的即刻奖励 $R<em>{t+1}$ 与下一个状态 $S</em>{t+1}$的预估价值乘以衰减系数$\gamma$ 组成，这符合Bellman方程的描述，故把（2）式带入（1）式得：</p>
<script type="math/tex; mode=display">
\large V(S_t) = V(S_t)  + \alpha(R_{t+1} + \gamma V{(S_{t+1})} -  V(S_t) ) \tag3</script><p>其中（3）式中：</p>
<ul>
<li>$R<em>{t+1}+\gamma V(S</em>{t + 1})$  称为<strong>TD的目标值</strong></li>
<li>$\delta<em>t = R</em>{t+1}+\gamma V(S_{t + 1})-V(S_t)$ 称为<strong>TD误差</strong></li>
</ul>
<p><strong>BootStrapping</strong> 指的就是TD目标值 $R<em>{t+1}+\gamma V(S</em>{t + 1})$ 代替收获$G_t$的过程，暂时把它翻译成“<strong>引导”</strong>。</p>
<h3 id="蒙特卡洛和TD策略评估差别"><a href="#蒙特卡洛和TD策略评估差别" class="headerlink" title="蒙特卡洛和TD策略评估差别"></a>蒙特卡洛和TD策略评估差别</h3><p><strong>例子——驾车返家：</strong>想象一下你下班后开车回家，需要预估整个行程花费的时间。假如一个人在驾车回家的路上突然碰到险情：对面迎来一辆车感觉要和你相撞，严重的话他可能面临死亡威胁，但是最后双方都采取了措施没有实际发生碰撞。如果使用蒙特卡洛学习，路上发生的这一险情可能引发的负向奖励不会被考虑进去，不会影响总的预测耗时；但是在TD学习时，碰到这样的险情，这个人会立即更新这个状态的价值，随后会发现这比之前的状态要糟糕，会立即考虑决策降低速度赢得时间，也就是说你不必像蒙特卡洛学习那样直到他死亡后才更新状态价值，那种情况下也无法更新状态价值。</p>
<p>TD算法相当于在整个返家的过程中（一个Episode），根据已经消耗的时间和预期还需要的时间来不断更新最终回家需要消耗的时间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>已消耗时间（分钟）</th>
<th>预计仍需耗时（分钟）</th>
<th>预计总耗时（分钟）</th>
</tr>
</thead>
<tbody>
<tr>
<td>离开办公室</td>
<td>0</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>取车，发现下雨</td>
<td>5</td>
<td>35</td>
<td>40</td>
</tr>
<tr>
<td>离开高速公路</td>
<td>20</td>
<td>15</td>
<td>35</td>
</tr>
<tr>
<td>被迫跟在卡车后面</td>
<td>30</td>
<td>10</td>
<td>40</td>
</tr>
<tr>
<td>到达家所在街区</td>
<td>40</td>
<td>3</td>
<td>43</td>
</tr>
<tr>
<td>进入家门</td>
<td>43</td>
<td>0</td>
<td>43</td>
</tr>
</tbody>
</table>
</div>
<p>基于上表所示的数据，下图展示了蒙特卡洛学习和TD学习两种不同的学习策略来<strong>更新</strong>价值函数（各个状态的价值）。这里使用的是<strong>从某个状态预估的到家还需耗时</strong>来<strong>间接</strong>反映某状态的价值：某位置预估的到家时间越长，该位置价值越低，在优化决策时需要避免进入该状态。对于蒙特卡洛学习过程，驾驶员在路面上碰到各种情况时，他不会更新对于回家的预估时间，等他回到家得到了真实回家耗时后，他会重新估计在返家的路上着每一个主要节点状态到家的时间，在下一次返家的时候用新估计的时间来帮助决策；而对于TD学习，在一开始离开办公室的时候你可能会预估总耗时30分钟，但是当你取到车发现下雨的时候，你会立刻想到原来的预计过于乐观，因为既往的经验告诉你下雨会延长你的返家总时间，此时你会更新目前的状态价值估计，从原来的30分钟提高到40分钟。同样当你驾车离开高速公路时，会一路根据当前的状态（位置、路况等）对应的预估返家剩余时间，直到返回家门得到实际的返家总耗时。这一过程中，你会根据状态的变化实时更新该状态的价值。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101171811202.png" alt="image-20210101171811202"></p>
<h4 id="MC-vs-TD-一"><a href="#MC-vs-TD-一" class="headerlink" title="MC vs. TD (一)"></a>MC vs. TD (一)</h4><p>通过上面的例子我们可以分析得出MC和TD的不同如下</p>
<ul>
<li>TD 在知道结果之前可以学习，MC必须等到最后结果才能学习</li>
<li>TD 可以在没有结果时学习，可以在持续进行的环境里学习, MC必须要等到完整的Episdo结束后才能学习</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101173034838.png" alt="image-20210101173034838"></p>
<h4 id="MC-vs-TD-二"><a href="#MC-vs-TD-二" class="headerlink" title="MC vs. TD (二)"></a>MC vs. TD (二)</h4><p>$G_t$ : 实际收获，是基于某一策略状态价值的<strong>无偏</strong>估计：</p>
<script type="math/tex; mode=display">
\large
G_t = R_{t+1} + \gamma R_{t+2}+\gamma^2 R_{t+3} \ ...\ +\gamma^{T-1}R_T</script><p><code>TD target</code> ：TD目标值，是基于下一状态<strong>预估价值</strong>计算当前预估收获，是当前状态实际价值的<strong>有偏</strong>估计：</p>
<script type="math/tex; mode=display">
\large  R_{t+1} + \gamma V{(S_{t+1})}</script><p><code>True TD target</code>： 真实TD目标值，是基于下一状态的<strong>实际价值</strong>对当前状态实际价值的<strong>无偏</strong>估计：</p>
<script type="math/tex; mode=display">
\large  R_{t+1} + \gamma v_\pi{(S_{t+1})}</script><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101185956942.png" alt="image-20210101185956942"></p>
<ul>
<li>MC 没有偏倚（bias），但有着较高的变异性（Variance），且对初始值不敏感</li>
<li>TD 低变异性（Variance）, 但有一定程度的偏倚（bias），对初始值较敏感，通常比 MC 更高效</li>
</ul>
<p>这里的<strong>偏倚</strong>指的是距离期望的距离，预估的平均值与实际平均值的偏离程度；<strong>变异性</strong>指的是方差，评估单次采样结果相对于与平均值变动的范围大小。基本就是统计学上均值与方差的概念。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101190031371.png" alt="image-20210101190031371"></p>
<p>对于MC和TD的区别，还可以用下面的例子来加深理解：</p>
<p><strong>例子——随机行走：</strong></p>
<p><strong>状态空间</strong>：如下图：A、B、C、D、E为中间状态，C作为起始状态。灰色方格表示终止状态</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101190514260.png" alt="image-20210101190514260"></p>
<p><strong>行为空间</strong>：除终止状态外，任一状态可以选择向左、向右两个行为之一</p>
<p><strong>即时奖励：</strong>右侧的终止状态得到即时奖励为1，左侧终止状态得到的即时奖励为0，在其他状态间转化得到的即时奖励是0</p>
<p><strong>状态转移</strong>：100%按行为进行状态转移，进入终止状态即终止</p>
<p><strong>衰减系数：</strong>1</p>
<p><strong>给定的策略</strong>：随机选择向左、向右两个行为</p>
<p><strong>问题：</strong>对这个MDP问题进行预测，也就是评估随机行走这个策略的价值，也就是计算该策略下每个状态的价值，也就是确定该MDP问题的状态价值函数</p>
<p><strong>求解：</strong>下图是使用TD算法得到的结果。横坐标显示的是状态，纵坐标是各状态的价值估计，一共5条折线，数字表明的是实际经历的Episode数量，true value所指的那根折线反映的是各状态的实际价值。第0次时，各状态的价值被初始化为0.5，经过1次、10次、100次后得到的价值函数越来越接近实际状态价值函数。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101191128639.png" alt="image-20210101191128639"></p>
<p>下图比较了MC和TD算法的<strong>效率</strong>。横坐标是经历的Episode数量，纵坐标是计算得到的状态函数和实际状态函数下各状态价值的均方差。黑色是MC算法在不同step-size下的学习曲线，灰色的曲线使用TD算法。可以看出TD较MC更高效。此图还可以看出当step-size不是非常小的情况下，TD有可能得不到最终的实际价值，将会在某一区间震荡。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210101192751452.png" alt="image-20210101192751452"></p>
<p><strong>例子——AB：</strong></p>
<p><strong>已知：</strong>现有两个状态(A和B)，MDP未知，衰减系数为1，有如下表所示8个完整Episode的经验及对应的即时奖励，其中除了第1个Episode有状态转移外，其余7个均只有一个状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Episode</th>
<th>状态转移及奖励</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A：0，B：0</td>
</tr>
<tr>
<td>2</td>
<td>B：1</td>
</tr>
<tr>
<td>3</td>
<td>B：1</td>
</tr>
<tr>
<td>4</td>
<td>B：1</td>
</tr>
<tr>
<td>5</td>
<td>B：1</td>
</tr>
<tr>
<td>6</td>
<td>B：1</td>
</tr>
<tr>
<td>7</td>
<td>B：1</td>
</tr>
<tr>
<td>8</td>
<td>B：1</td>
</tr>
</tbody>
</table>
</div>
<p><strong>问题：依据仅有的Episode，衰减系数为1（即无衰减），计算状态A，B的价值分别是多少，即</strong>V(A)=？， V(B)=？</p>
<p><strong>答案：</strong>V(B) = 6/8，V(A)根据不同算法结果不同，用MC算法结果为0，TD则得出6/8。</p>
<p><strong>解释：</strong></p>
<p>应用MC算法，由于需要完整的Episode，因此仅Episode1可以用来计算A的状态价值，很明显是0；同时B的价值是6/8。</p>
<p>应用TD算法时，TD算法试图利用现有的Episode经验构建一个MDP（如下图），由于存在一个Episode使得状态A有后继状态B，因此状态A的价值是通过状态B的价值来计算的，同时经验表明A到B的转移概率是100%，且A状态的即时奖励是0，并且没有衰减，因此A的状态价值等于B的状态价值。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102164122980.png" alt="image-20210102164122980"></p>
<p>MC算法试图收敛至一个能够<strong>最小化状态价值</strong>与<strong>实际收获</strong>的均方差的解决方案，这一均方差用公式表示为：</p>
<script type="math/tex; mode=display">
\large \sum_{k=1}^K \sum_{t=1}^{T_k}(G_t^k-V(s_t^k))^2</script><p>上式中，$k$ 表示的是Episode序号，$K$为总的Episode数量，$t$ 为一个Episode 内状态序号（第1，2，3，4…个状态等），$T_k$ 表示的是第$k$ 个Episode中总的状态数，$G_t^k$ 表示第$k$ 个Episode里t时刻状态$s_t$ 获得的最终收获，$V(s_t^k)$ 表示的是第 $k$ 个Episode里算法估计的 $t$时刻状态$s_t$的价值。</p>
<p>在例子<strong>AB</strong>中，利用MC算法，V(A)=0。</p>
<p>TD算法则收敛至一个根据已有经验构建的最大可能的马儿可夫模型（MDP&lt;$S,A,P,R,\gamma$&gt;）的状态价值，也就是说TD算法将首先根据已有经验估计<strong>状态间的转移概率</strong>：</p>
<script type="math/tex; mode=display">
\large P_{ss'}^a = \frac{1}{N(s,a)}\sum_{k=1}^K\sum_{t=1}^{T_k}1(s_t^k,a_t^k,s_{t+1}^k = s,a,s')</script><p>同时估计某一状态的<strong>即时奖励：</strong></p>
<script type="math/tex; mode=display">
\large P_s^a = \frac{1}{N(s,a)}\sum_{k=1}^K\sum_{t=1}^{T_k}1(s_t^k,a_t^k = s,a)r_t^k</script><p>最后计算该MDP的状态函数。</p>
<p>在例子<strong>AB</strong>中，利用TD算法，V(A)=6/8。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102172416301.png" alt="image-20210102172416301"></p>
<blockquote>
<p>注：公式符号有所不同，但是表达意义一致。</p>
</blockquote>
<h4 id="MC-vs-TD-三"><a href="#MC-vs-TD-三" class="headerlink" title="MC vs. TD (三)"></a>MC vs. TD (三)</h4><p>通过比较可以看出，TD算法使用了MDP问题的马儿可夫性，在Markov 环境下更有效；但是MC算法并不利用马儿可夫性，通常在非Markov环境下更有效。</p>
<h2 id="DP，MC，TD-总结"><a href="#DP，MC，TD-总结" class="headerlink" title="DP，MC，TD 总结"></a>DP，MC，TD 总结</h2><p>Monte-Carlo，Temporal-Difference 和 Dynamic Programming 都是<strong>计算状态价值</strong>的一种方法，区别在于，前两种是在不知道Model的情况下的常用方法，这其中又以MC方法需要一个<strong>完整</strong>的Episode来更新状态价值，TD则不需要完整的Episode；DP方法则是基于Model（知道模型的运作方式）的计算状态价值的方法，它通过计算一个状态S所有可能的转移状态 S’ 及其转移概率以及对应的即时奖励来计算这个状态S的价值。</p>
<p><strong>关于是否Bootstrap：</strong>MC 没有引导数据，只使用实际收获；DP和TD都有引导数据。</p>
<p><strong>关于是否用样本来计算：</strong> MC和TD都是应用样本来估计实际的价值函数；而DP则是利用<strong>模型</strong>直接计算得到实际价值函数，没有样本或采样之说。</p>
<p>下面的几张图直观地体现了三种算法的区别：</p>
<ol>
<li>MC：采样，一次完整经历，用实际收获更新状态预估价值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102180703567.png" alt="image-20210102180703567"></p>
<ol>
<li>TD：采样，经历可不完整，用喜爱状态（已有的状态）的预估状态价值预估收获，再更新预估价值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102181120279.png" alt="image-20210102181120279"></p>
<ol>
<li>DP：没有采样，根据完整模型，依靠预估数据更新状态价值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102181252019.png" alt="image-20210102181252019"></p>
<p>下图从两个维度解释了四种算法的差别，多了一个穷举法。这两个维度分别是：<strong>采样深度和广度</strong>。当使用单个采样，同时不走完整个Episode就是TD；当使用单个采样但走完整个Episode就是MC；当考虑全部样本可能性，但对每一个样本并不走完整个Episode时，就是DP；当既考虑所有Episode又把Episode从开始到终止遍历完，就变成了穷举法。</p>
<p>需要提及的是：DP利用的是整个MDP问题的模型，也就是状态转移概率，虽然它并不实际利用样本，但是它利用了整个模型的规律，因此认为是Full Width的。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210102181531691.png" alt="image-20210102181531691"></p>
<h2 id="λ时序差分强化学习TD-λ"><a href="#λ时序差分强化学习TD-λ" class="headerlink" title="λ时序差分强化学习TD(λ)"></a>λ时序差分强化学习TD(λ)</h2><p>先前所介绍的TD算法实际上都是TD(0)算法，括号内的数字0表示的是在当前状态下往前多看1步，要是往前多看2步更新状态价值会怎样？这就引入了<code>n-step</code>的概念。</p>
<h3 id="n-步预测-n-Step-Prediction"><a href="#n-步预测-n-Step-Prediction" class="headerlink" title="n-步预测 (n-Step Prediction)"></a>n-步预测 (n-Step Prediction)</h3><p>在当前状态往前行动n步，计算n步的return，同样TD target 也由2部分组成，已走的步数使用确定的即时reward，剩下的使用估计的状态价值替代。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210103181438607.png" alt="image-20210103181438607"></p>
<blockquote>
<p>注：图中空心大圆圈表示状态，实心小圆圈表示行为</p>
</blockquote>
<h3 id="n-步收获-n-Step-Return"><a href="#n-步收获-n-Step-Return" class="headerlink" title="n-步收获(n-Step Return  )"></a>n-步收获(n-Step Return  )</h3><p>TD或TD(0)是基于<code>1-步</code>预测的，MC则是基于<code>∞-步</code>预测的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n=1</th>
<th>TD 或TD(0)</th>
<th>$G<em>t^{(1)} = R</em>{t+1} + \gamma(S_{t+1}) $</th>
</tr>
</thead>
<tbody>
<tr>
<td>n=2</td>
<td></td>
<td>$G<em>t^{(2)} = R</em>{t+1} + \gamma R<em>{t+2}+\gamma^2 V(S</em>{t+2})$</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n= ∞</td>
<td>MC</td>
<td>$G<em>t^\infin = R</em>{t+1} + \gamma R<em>{t+2}+\gamma^2 R</em>{t+3} \ …\ +\gamma^{T-1}R_T$</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注： n = 2时不写成TD(2)</p>
</blockquote>
<p><strong>n-步收获：</strong></p>
<script type="math/tex; mode=display">
\large G_t^\infin = R_{t+1} + \gamma R_{t+2}+\gamma^2 R_{t+3} \ ...\ +\gamma^{n-1}R_{t+n} + \gamma^nV(S_{t+n})</script><p>那么，n步TD学习状态<strong>价值函数</strong>的更新公式为：</p>
<script type="math/tex; mode=display">
\large V(S_t) \leftarrow V(S_t)  + \alpha(G_t^a -  V(S_t) )</script><p>既然存在n-步预测，那么n=？时效果最好呢，下面的例子试图回答这个问题：</p>
<p><strong>例子：大规模随机行走</strong></p>
<p>这个示例研究了使用多个不同步数预测联合不同步长(step-size，公式里的系数α）时，分别在在线和离线状态时状态函数均方差的差别。所有研究使用了10个Episode。离线与在线的区别在于，离线是在经历所有10个Episode后进行状态价值更新；而在线则至多经历一个Episode就更新依次状态价值。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105123410790.png" alt="image-20210105123410790"></p>
<p>结果如图表明，离线和在线之间曲线的形态差别不明显；从步数上来看，步数越长，越接近MC算法，均方差越大。对于这个大规模随机行走示例，在线计算比较好的步数是3-5步，离线计算比较好的是6-8步。但是不同的问题其对应的比较高效的步数不是一成不变的。因此选择多少步数作为一个较优的计算参数也是一个问题。</p>
<p>这里我们引入了一个新的参数：λ。通过引入这个新的参数，可以做到在不增加计算复杂度的情况下综合考虑所有步数的预测。这就是<strong>λ预测</strong>和<strong>λ收获。</strong></p>
<h3 id="λ收获"><a href="#λ收获" class="headerlink" title="λ收获"></a>λ收获</h3><p>λ-收获$G_t^\lambda$综合考虑了从1到∞的所有收获，它给其中的任意一个<code>n-step</code> 收获施加一定的权重$(1-\lambda)\lambda^{n-1}$。通过这样的权重设计，得到如下的公式：</p>
<script type="math/tex; mode=display">
\large G_t^\lambda =(1-\lambda)\sum_{n=1}^\infin\lambda^{n-1}G_t^{(n)}</script><h3 id="λ预测"><a href="#λ预测" class="headerlink" title="λ预测"></a>λ预测</h3><p>对应的λ-预测写成TD(λ):</p>
<script type="math/tex; mode=display">
\large V(S_t) \leftarrow V(S_t) + \alpha(G_t^\lambda-V(S_t))</script><p>下图是各步收获的<strong>权重分配图</strong>，图中最后一列λ的指数是$T-t-1$ 。$T$ 为终止状态的时刻步数，$t$ 为当前状态的时刻步数，所有的权重加起来为1。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105130732141.png" alt="image-20210105130732141"></p>
<h3 id="TD-λ-对于权重分配的图解"><a href="#TD-λ-对于权重分配的图解" class="headerlink" title="TD(λ)对于权重分配的图解"></a>TD(λ)对于权重分配的图解</h3><p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105130951563.png" alt="image-20210105130951563"></p>
<p>这张图还是比较好理解，例如对于n=3的3-步收获，赋予其在 $\lambda$ 收获中的权重如左侧阴影部分面积，对于终止状态的T-步收获，T以后的<strong>所有</strong>阴影部分面积。而所有节段面积之和为1。这种几何级数的设计也考虑了算法实现的计算方便性。</p>
<p>TD((λ)的设计使得Episode中，<strong>后一个状态的状态价值与之前所有状态的状态价值有关，同时也可以说成是一个状态价值参与决定了后续所有状态的状态价值。但是每个状态的价值对于后续状态价值的影响权重是不同的</strong>。我们可以从两个方向来理解TD(λ)：</p>
<p><strong>前向认识TD(λ)</strong></p>
<p>引入了λ之后，会发现要更新一个状态的状态价值，必须要走完整个Episode获得每一个状态的即时奖励以及最终状态获得的即时奖励。这和MC算法的要求一样，因此TD(λ)算法有着和MC方法一样的劣势。λ取值区间为[0,1]，<strong>当λ=1时对应的就是MC算法</strong>。这个实际计算带来了不便。</p>
<p><strong>反向认识TD(λ)</strong></p>
<p>TD(λ)从另一方面提供了一个单步更新的机制，通过下面的示例来说明。</p>
<p><strong>示例——被电击的原因</strong></p>
<p>这是之前见过的一个例子，老鼠在连续接受了3次响铃和1次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105131812554.png" alt="image-20210105131812554"></p>
<p>两个概念：</p>
<p><strong>频率启发 (Frequency heuristic)：</strong>将原因归因于出现频率最高的状态</p>
<p><strong>就近启发 (Recency heuristic)：</strong>将原因归因于较近的几次状态</p>
<p>给每一个状态引入一个数值：<strong>效用追踪</strong>（<strong>Eligibility Traces, ES，也有翻译成“资质追踪”，这是同一个概念从两个不同的角度理解得到的不同翻译</strong>），可以结合上述两个启发。定义：</p>
<script type="math/tex; mode=display">
E_0(s) = 0 \\
E_t(s) = \gamma\lambda E_{t-1}(s)+1(S_t = s)</script><p>其中 $1(S_t = s)$ 是一个条件判断表达式。</p>
<p>下图给出了$E_t(s)$ 关于$t$的一个可能的曲线图：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105152337864.png" alt="image-20210105152337864"></p>
<p>该图横坐标是时间$t$，横坐标下有竖线的位置代表当前进入了状态 $s$ ，纵坐标是效用追踪值 $E$。可以看出当某一状态连续出现，E值会在一定衰减的基础上有一个单位数值的提高，此时将增加该状态对于最终收获贡献的比重，因而在更新该状态价值的时候可以较多地考虑最终收获的影响。同时如果该状态距离最终状态较远，则其对最终收获的贡献越小，在更新该状态时也不需要太多的考虑最终收获。</p>
<p>特别的$E$值并不需要等到完整的Episode结束才能计算出来，它可以每经过一个时刻就得到更新。$E$值存在<strong>饱和现象</strong>，有一个瞬间最高上限：</p>
<script type="math/tex; mode=display">
\large E_{max} = 1/(1-\gamma\lambda)</script><p>把刚才的描述体现在公式里<strong>更新状态价值</strong>，得到如下式子：</p>
<script type="math/tex; mode=display">
\large \delta_t = R_{t+1} +\gamma V(S_{t+1})-V(S_t)</script><script type="math/tex; mode=display">
\large V(s)\leftarrow V(s)+\alpha\delta_tE_t(s)</script><blockquote>
<p>注：每一个状态都有一个 $E$值， $E$值随时间而变化。</p>
</blockquote>
<p>当λ=0时，只有当前状态得到更新，等同于TD(0)算法；</p>
<p>当λ=1时，TD(1)粗略看与每次访问的MC算法等同；</p>
<ul>
<li>在线更新时，状态价值差每一步都会有积累；</li>
<li>离线更新时，TD(1)等同于MC算法。</li>
</ul>
<blockquote>
<p>注：ET是一个非常符合神经科学相关理论的、非常精巧的设计。把它看成是神经元的一个参数，它反映了神经元对某一刺激的敏感性和适应性。神经元在接受刺激时会有反馈，在持续刺激时反馈一般也比较强，当间歇一段时间不刺激时，神经元又逐渐趋于静息状态；同时不论如何增加刺激的频率，神经元有一个最大饱和反馈。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下表给出了λ取各种值时，不同算法在不同情况下的关系。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongqiangsoliva/zhaohongqiangsoliva.github.io/master/images/image-20210105155527593.png" alt="image-20210105155527593"></p>
<p>相较于MC算法，TD算法应用更广，是一个非常有用的强化学习方法，在下一讲讲解控制相关的算法时会详细介绍TD算法的实现。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/28107168">https://zhuanlan.zhihu.com/p/28107168</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/9492980.html">https://www.cnblogs.com/pinard/p/9492980.html</a></p>
<p><a href="http://www.incompleteideas.net/book/the-book.html">http://www.incompleteideas.net/book/the-book.html</a></p>
<p><a href="https://www.davidsilver.uk/wp-content/uploads/2020/03/MC-TD.pdf">https://www.davidsilver.uk/wp-content/uploads/2020/03/MC-TD.pdf</a></p>
<p><a href="https://baike.baidu.com/item/21点/5481683?fr=aladdin">https://baike.baidu.com/item/21点/5481683?fr=aladdin</a></p>
]]></content>
      <tags>
        <tag>method</tag>
      </tags>
  </entry>
  <entry>
    <title>oh-my-bash 安装</title>
    <url>/2021/02/05/2022-08-26-oh-my-bash/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="oh-my-bash-安装"><a href="#oh-my-bash-安装" class="headerlink" title="oh-my-bash 安装"></a>oh-my-bash 安装</h1><p>插件在zsh不好用的情况下，使用bash 版本ohmybash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(wget https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>
<p>设置bashrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">82 plugins=(</span><br><span class="line"> 83   git</span><br><span class="line"> 84   bashmarks</span><br><span class="line"> 85   zoxide</span><br><span class="line"> 86 )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">125 # trash</span><br><span class="line">126 TRASH_DIR=/home/zhaohq/.trash          # 设置回收站目录路径</span><br><span class="line">127 alias rm=trash                      # 将rm命令用trash来实现</span><br><span class="line">128 alias list_trash=&#x27;ls $&#123;TRASH_DIR&#125;&#x27;  # 显示回收站中的文件</span><br><span class="line">129 trash()                             # 移动文件到回收站TRASH_DIR目录</span><br><span class="line">130 &#123;</span><br><span class="line">131     for file_path in $@;</span><br><span class="line">132     do</span><br><span class="line">133     ¦   # 利用IFS分割Unix风格的文件路径</span><br><span class="line">134     ¦   OLD_IFS=&quot;$IFS&quot;</span><br><span class="line">135     ¦   IFS=&quot;/&quot;</span><br><span class="line">136     ¦   array=($file_path)</span><br><span class="line">137     ¦   IFS=&quot;$OLD_IFS&quot;</span><br><span class="line">138</span><br><span class="line">139     ¦   # 在分割出的字符串数组中获取文件名(注意冒号后有空格)</span><br><span class="line">140     ¦   file_name=$&#123;array[@]: -1&#125;</span><br><span class="line">141</span><br><span class="line">142     ¦   # 删除文件(将当前时间作为后缀，方便误删后恢复，也防止回收站中不允许同名文件存在)</span><br><span class="line">143     ¦   mv $&#123;file_path&#125; $&#123;TRASH_DIR&#125;/$&#123;file_name&#125;.`date +%Y%m%d-%H:%M:%S`</span><br><span class="line">144     done</span><br><span class="line">145 &#125;</span><br><span class="line">146 clear_trash()                   # 清空回收站TRASH_DIR目录下的所有文件</span><br><span class="line">147 &#123;</span><br><span class="line">148     read -p &quot;clear sure?[n]&quot; confirm</span><br><span class="line">149     [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ]  &amp;&amp; /bin/rm -rf $&#123;TRASH_DIR&#125;/*</span><br><span class="line">150 &#125;</span><br><span class="line">151 export PATH=$PATH:$HOME/usr/local/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux tools</tag>
      </tags>
  </entry>
  <entry>
    <title>INTRODUCTION TO LINEAR MIXED MODELS</title>
    <url>/2021/02/05/2022-09-04-Mixed_linear_model/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="INTRODUCTION-TO-LINEAR-MIXED-MODELS"><a href="#INTRODUCTION-TO-LINEAR-MIXED-MODELS" class="headerlink" title="INTRODUCTION TO LINEAR MIXED MODELS"></a>INTRODUCTION TO LINEAR MIXED MODELS</h1><p>This page briefly introduces linear mixed models LMMs as a method for analyzing data that are non independent, multilevel/hierarchical, longitudinal, or correlated. We focus on the general concepts and interpretation of LMMS, with less time spent on the theory and technical details.</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Linear mixed models are an extension of simple linear models to allow both fixed and random effects, and are particularly used when there is non independence in the data, such as arises from a hierarchical structure. For example, students could be sampled from within classrooms, or patients from within doctors.</p>
<p>When there are multiple levels, such as patients seen by the same doctor, the variability in the outcome can be thought of as being either within group or between group. Patient level observations are not independent, as within a given doctor patients are more similar. Units sampled at the highest level (in our example, doctors) are independent. The figure below shows a sample where the dots are patients within doctors, the larger circles.</p>
<p><img src="2022-09-04-Mixed_linear_model.assets/image-20220904170808328.png" alt="image-20220904170808328" style="zoom:25%;" /></p>
<p>There are multiple ways to deal with hierarchical data. One simple approach is to aggregate. For example, suppose 10 patients are sampled from each doctor. Rather than using the individual patients’ data, which is not independent, we could take the average of all patients within a doctor. This aggregated data would then be independent.</p>
<p>Although aggregate data analysis yields consistent and effect estimates and standard errors, it does not really take advantage of all the data, because patient data are simply averaged. Looking at the figure above, at the aggregate level, there would only be six data points.</p>
<p>Another approach to hierarchical data is analyzing data from one unit at a time. Again in our example, we could run six separate linear regressions—one for each doctor in the sample. Again although this does work, there are many models, and each one does not take advantage of the information in data from other doctors. This can also make the results “noisy” in that the estimates from each model are not based on very much data</p>
<p>Linear mixed models (also called multilevel models) can be thought of as a trade off between these two alternatives. The individual regressions has many estimates and lots of data, but is noisy. The aggregate is less noisy, but may lose important differences by averaging all samples within each doctor. LMMs are somewhere inbetween.</p>
<p>Beyond just caring about getting standard errors corrected for non independence in the data, there can be important reasons to explore the difference between effects within and between groups. An example of this is shown in the figure below. Here we have patients from the six doctors again, and are looking at a scatter plot of the relation between a predictor and outcome. Within each doctor, the relation between predictor and outcome is negative. However, between doctors, the relation is positive. LMMs allow us to explore and understand these important effects.</p>
<p><img src="2022-09-04-Mixed_linear_model.assets/image-20220904170854688.png" alt="image-20220904170854688" style="zoom:25%;" /></p>
<h2 id="随机效应"><a href="#随机效应" class="headerlink" title="随机效应"></a>随机效应</h2><p>混合模型的核心是它们结合了固定效应和随机效应。固定效应是不变的参数。例如, 我们可以假设总体中有一些真实的回归线, $\beta$, 我们得到了一些估计, $\hat{\beta}$. 相 反, 随机效应是本身就是随机变量的参数。例如, 我们可以说 $\beta$ 分布为具有均值的随机正态变量 $\mu$ 和标准差 $\sigma$, 或方程形式:</p>
<script type="math/tex; mode=display">
\beta \sim \mathcal{N}(\mu, \sigma)</script><p>这实际上与线性回归中的相同, 我们假设数据是随机变量, 但参数是固定效应。现在数据是随机变量, 参数是随机变量 (在一个级别), 但在最高级别是固定的 (例如, 我们仍然假设一些总体总体均值， $\mu$ )。<br>线性混合模型理论</p>
<script type="math/tex; mode=display">
\mathbf{y}=\boldsymbol{X} \boldsymbol{\beta}+\boldsymbol{Z} \boldsymbol{u}+\boldsymbol{\varepsilon}</script><p>在哪里 $\mathbf{y}$ 是一个 $N \times 1$ 列向量, 结果变量; $\mathbf{X}$ 是一个 $N \times p$ 的矩阵 $p$ 预测变量; $\beta$ 是一个 $p \times 1$ 固定效应回归系数的列向量 $(\beta \mathrm{s}) ; \mathbf{Z}$ 是个 $N \times q J$ 设计矩阵 $q$ 随机效应 和 $J$ 团体; $u$ 是一个 $q J \times 1$ 向量 $q$ 随机效应（对固定的随机补充 $\beta$ )为了J团体; 和 $\varepsilon$ 是一个 $N \times 1$ 残差的列向量, 那部分 $\mathbf{y}$ 模型没有解释的, $\boldsymbol{X} \boldsymbol{\beta}+\boldsymbol{Z} u$. 回顾一 下:<br>为了使这一点更具体, 让我们考虑一个模拟数据集中的例子。医生 $(J=407)$ 索引的 $j$ 下标各见 $n_j$ 患者。所以我们的分组变量是医生。不是每个医生看的病人数 量都是一样的, 从2个病人一直到 40 个病人, 平均 21 个左右。病人总数是每个医生看的病人的总和</p>
<script type="math/tex; mode=display">
N=\sum_j^J n_j</script><p>在我们的示例中, $N=8525$ 医生看过病人。我们的结果, $\mathrm{y}$ 是一个连续变量, 流动性分数。此外, 假设我们有 6 个固定效应预测变量, 年龄 (年) 、已婚（0= 否, $1=$ 是）、性别 ( 0 = 女性, $1=$ 男性 $)$ 、红细胞 $(\mathrm{RBC})$ 计数和白细胞 $(\mathrm{WBC})$ 计数加上一个固定截距和一个随机截距 $(q=1)$ 对于每个 $J=407$ 医生。为简单起 见, 我们只考虑随机截距。我们现在将修复所有其他效果。我们想要任何随机效应的原因是因为我们预计医生内部的流动性分数可能是相关的。这有很多原因。 例如, 医生可能有专长, 这意味着他们往往会看到有特定症状的肺癌患者, 或者一些医生可能会看到更晩期的病例, 因此在医生内部, 患者比医生之间更加同 质。让这个例子回到我们的矩阵符号中, 对于 $n<em>j$ 维度响应 $\mathbf{y}</em>{\mathbf{j}}$ 给医生 $j$ 我们会有:<br>并通过将所有组的观察结果叠加在一起, 因为 $q=1$ 对于随机截距模型, $q J=(1)(407)=407$ 所以我们有:</p>
<script type="math/tex; mode=display">
\boldsymbol{\beta}=\left[\begin{array}{c}
4.782 \\
.025 \\
.011 \\
.012 \\
0 \\
-.009
\end{array}\right]</script><p>因为Z这么大，这里就不写数字了。因为我们只是对随机截距进行建模，所以在我们的例子中它是一个特殊的矩阵，只编码患者属于哪个医生。所以在这种情况下，它都是 0 和 1。每列是一位医生，每一行代表一位患者（数据集中的一行）。如果患者属于该列中的医生，则该单元格将为 1，否则为 0。这也意味着它是一个稀疏矩阵（即大部分为零的矩阵），我们可以轻松创建图片表示。请注意，如果我们添加一个随机斜率，则Z将保持不变，但列数会增加一倍。这就是为什么添加随机效应在计算上会变得繁重，尤其是当您有很多组时（我们有 407 名医生）。在所有情况下，矩阵将大部分包含零，因此它始终是稀疏的。在图形表示中，线条似乎在摆动，因为每位医生的患者数量不同。</p>
<p><img src="2022-09-04-Mixed_linear_model.assets/image-20220904171147750.png" alt="image-20220904171147750" style="zoom: 25%;" /></p>
<p>如果我们估计一下, $\boldsymbol{u}$ 将是一个列向量, 类似于 $\boldsymbol{\beta}$. 然而, 在经典统计中, 我们实际上并没有估计 $\boldsymbol{u}$. 相反, 我们几乎总是假设:</p>
<script type="math/tex; mode=display">
\boldsymbol{u} \sim \mathcal{N}(\mathbf{0}, \mathbf{G})</script><p>读作：“u 正态分布, 均值为 0, 方差为 G”。在哪里G是随机效应的方差-协方差矩阵。因为我们直接估计了固定效应, 包括固定效应截距, 随机效应互补被建模 为与固定效应的偏差, 所以它们的均值为零。随机效应只是围绕值的偏差 $\boldsymbol{\beta}$, 这是均值。所以剩下要估计的是方差。因为我们的例子只有一个随机截距, G只是 一个 $1 \times 1$ 矩阵, 随机截距的方差。但是, 它可以更大。例如, 假设我们有一个随机截距和一个随机斜率, 那么</p>
<script type="math/tex; mode=display">
\mathbf{G}=\left[\begin{array}{cc}
\sigma_{\text {int }}^2 & \sigma_{\text {int,slope }}^2 \\
\sigma_{\text {int }, \text { slope }}^2 & \sigma_{\text {slope }}^2
\end{array}\right]</script><p>因为 $\mathbf{G}$ 是一个方差-协方差矩阵, 我们知道它应该具有某些性质。特别是, 我们知道它是平方的、对称的和半正定的。我们也知道这个矩阵有吕余元素。为一个 $\left.\mathbf{G}=\mathbf{L D L}^{\mathbf{T}}\right)_{\text {。 }} \boldsymbol{\theta}$ 并不总是以相同的方式参数化，但您通常可以将其视为表示随机效应。它通常被设计为包含非冗余元素（与方差协方差矩阵不同），并以产生 比方差更稳定的估计的方式进行参数化（例如取自然对数以确保方差为正）。不管具体情况如何, 我们都可以这么说</p>
<script type="math/tex; mode=display">
\mathbf{G}=\sigma(\boldsymbol{\theta})</script><p>换句话说, G是一些函数 $\boldsymbol{\theta}$. 所以我们得到一些估计 $\boldsymbol{\theta}$ 我们称之为 $\boldsymbol{\theta}$. 各种参数化和约束允许我们简化模型, 例如假设随机效应是 独立的, 这意味着真正的结构是</p>
<script type="math/tex; mode=display">
\mathbf{G}=\left[\begin{array}{cc}
\sigma_{i n t}^2 & 0 \\
0 & \sigma_{\text {slope }}^2
\end{array}\right]</script><p>我们模型中的最后一个元素是残差的方差-协方差矩阵, $\varepsilon$ 或条件分布的方差-协方差矩阵 $(\mathbf{y} \mid \boldsymbol{\beta} ; \boldsymbol{u}=u)$. 最常见的残差协方差结构是</p>
<script type="math/tex; mode=display">
\mathbf{R}=\boldsymbol{I} \boldsymbol{\sigma}_{\varepsilon}^2</script><p>在哪里I是单位矩阵（1s 的对角矩阵）和 $\sigma_{\varepsilon}^2$ 是残差方差。该结构假定所有（条件）观察的均质残差方差, 并且它们是（条件）独立的。可以假设其他结构, 例如 复合对称或自回归。这G术语在 SAS 中很常见, 并且还导致谈论随机效应的方差协方差矩阵的 G 侧结构和残差协方差矩阵的 R 侧结构。<br>所以最终的固定元素是 $\mathbf{y}, \mathbf{X}, \mathbf{Z}$, 和 $\varepsilon$. 最终估计的元素是 $\hat{\boldsymbol{\beta}}, \hat{\boldsymbol{\theta}}$, 和 $\hat{\mathbf{R}}$. 最终模型取决于假设的分布, 但通常采用以下形式：</p>
<script type="math/tex; mode=display">
(\mathbf{y} \mid \boldsymbol{\beta} ; \boldsymbol{u}=u) \sim \mathcal{N}(\boldsymbol{X} \boldsymbol{\beta}+\boldsymbol{Z} u, \mathbf{R})</script><p>我们还可以将我们的模型构建为一个两级式的方程 $i$ - 第一名患者 $j$ - 医生。在那里, 我们正在使用我们下标的变量而不是像以前一样的向量。1 级方程为参数添加 下标 $\beta \mathrm{s}$ 表示他们属于哪个医生。转到第 2 级方程, 我们可以看到每个 $\beta$ 对特定医生的估计, $\beta<em>{p j}$, 可以表示为该参数的平均估计值的组合, $\gamma</em>{p 0}$, 以及该医生的 随机效应, $\left(u<em>{p j}\right)$ 。在这个特定的模型中, 我们看到只有截距 $\left(\beta</em>{0 j}\right)$ 允许因医生而异, 因为它是唯一具有随机效应项的方程, $\left(u<em>{0 j}\right)$ 。另一个 $\beta</em>{p j}$ 在医生之间是恒定 的。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
L 1: & Y_{i j}=\beta_{0 j}+\beta_{1 j} \text { Age }_{i j}+\beta_{2 j} \text { Married }_{i j}+\beta_{3 j} S x_{i j}+\beta_{4 j} W B C_{i j}+\beta_{5 j} R B C_{i j}+e_{i j} \\
L 2: & \beta_{0 j}=\gamma_{00}+u_{0 j} \\
L 2: & \beta_{1 j}=\gamma_{10} \\
L 2: & \beta_{2 j}=\gamma_{20} \\
L 2: & \beta_{3 j}=\gamma_{30} \\
L 2: & \beta_{4 j}=\gamma_{40} \\
L 2: & \beta_{5 j}=\gamma_{50}
\end{array}</script><p>将第 2 级方程代入第 1 级, 得到混合模型规范。在这里, 我们将固定和随机截距参数组合在一起, 以表明它们组合在一起给出了特定医生的估计截距。</p>
<script type="math/tex; mode=display">
Y_{i j}=\left(\gamma_{00}+u_{0 j}\right)+\gamma_{10} \text { Age }_{i j}+\gamma_{20} \text { Married }_{i j}+\gamma_{30} S E X_{i j}+\gamma_{40} W B C_{i j}+\gamma_{50} R B C_{i j}+e_{i j}</script><p>参考<br>-福克斯, J. (2008)。应用回归分析和广义线性模型, 第 2 版。圣人出版物。</p>
<ul>
<li>McCullagh, P 和 Nelder, JA (1989)。广义线性模型, 第 2 版。查普曼和霍尔/CRC 出版社。</li>
<li>Snijders, TAB 和 Bosker, RJ（2012 年）。多层次分析, 第 2 版。圣人出版物。</li>
<li>歌手, JD 和 Willett, JB（2003 年）。应用纵向数据分析：建模变化和事件发生。牛津大学出版社。</li>
<li>Pinheiro, J. \&amp; Bates, D. (2009)。S 和 S-Plus 中的混合效应模型。第二次印刷。施普林格。</li>
<li>Galecki, A. \&amp; Burzykowski, T. (2013)。使用 R 的线性混合效应模型。施普林格。</li>
<li>Skrondal, A. \&amp; Rabe-Hesketh, S. (2004)。广义潜变量建模：多级、纵向和结构方程模型。查普曼和霍尔/CRC 出版社。</li>
<li>Gelman, A. \&amp; Hill, J. (2006)。使用回归和多级/分层模型的数据分析。剑桥大学出版社。</li>
<li>Gelman, A., Carlin, JB, Stern, HS \&amp; Rubin, DB (2003)。贝叶斯数据分析, 第 2 版。查普曼和霍尔/CRC。</li>
</ul>
<p><img src="" alt="loading-ag-492"></p>
]]></content>
      <tags>
        <tag>method</tag>
      </tags>
  </entry>
  <entry>
    <title>Fzf的使用</title>
    <url>/2022/10/27/2022-10-27-fzf%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Fzf的使用"><a href="#Fzf的使用" class="headerlink" title="Fzf的使用"></a>Fzf的使用</h1><p>fzf 是一个通用的命令行模糊搜索工具，用 golang 编写，大家的评价都是目前最快的 fuzzy finder，配合 <a href="https://einverne.github.io/post/2019/04/the-silver-searcher.html">ag</a> 的使用，依靠模糊的关键词，可以快速定位文件。配合一些脚本，可以完全颠覆以前使用命令行的工作方式。</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure>
<p>or upgrade</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.fzf &amp;&amp; git pull &amp;&amp; ./install</span><br></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>最直接的使用方式就是在终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fzf</span><br></pre></td></tr></table></figure>
<p>或者 fzf 可以接受 stdin，比如使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find * -type f | fzf</span><br></pre></td></tr></table></figure>
<p>此时会进入 fzf 的交互窗口，在交互窗口中可以使用 Ctrl + n 或者 Ctrl + p 来上下移动光标。使用 Enter 选中条目</p>
<p>其他常用：</p>
<ul>
<li>Ctrl-j Ctrl-n 都能往下，不过 Ctrl-j 在我的配置中是切换到下 pane 所以我只用 Ctrl-n</li>
<li>Ctrl-k Ctrl-p 都能往上，不过 Ctrl-k 在我的配置中是切换到上 pane 所以我只用 Ctrl-p</li>
<li>Ctrl-c 或者 Ctrl-g 或者 Ctrl-q 或者 Esc 用来退出 abort</li>
<li>Ctrl-h 退格键 backspace，不过这个键和 tmux vim 有冲突所以一般不用</li>
<li>Ctrl-a 光标跳转到开头 Ctrl-e 跳转到行结尾</li>
<li>Ctrl-w 向前删以 word</li>
<li>Ctrl-u 删除所有输入</li>
</ul>
<p>其实看到后面就发现很多快捷键其实是和 Bash/Shell 下一致的，其他更多的交互命令，可以参考 <code>man fzf</code></p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="FZF-DEFAULT-COMMAND"><a href="#FZF-DEFAULT-COMMAND" class="headerlink" title="FZF_DEFAULT_COMMAND"></a>FZF_DEFAULT_COMMAND</h3><p>fzf 默认查找文件使用的是系统的 <code>find</code> 命令，你可以通过自定义该环境变量来更改使用其他命令比如 <a href="https://einverne.github.io/post/2019/04/the-silver-searcher.html">ag</a> 或者 <a href="https://einverne.github.io/post/2019/08/fd-find-entries-in-the-filesystem.html">fd</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这行配置开启 ag 查找隐藏文件 及忽略 .git 文件</span><br><span class="line">export FZF_DEFAULT_COMMAND=&#x27;ag --hidden --ignore .git -l -g &quot;&quot;&#x27;</span><br><span class="line"># or</span><br><span class="line">export FZF_DEFAULT_COMMAND=&quot;fd --exclude=&#123;.git,.idea,.sass-cache,node_modules,build&#125; --type f&quot;</span><br></pre></td></tr></table></figure>
<h3 id="FZF-DEFAULT-OPTS"><a href="#FZF-DEFAULT-OPTS" class="headerlink" title="FZF_DEFAULT_OPTS"></a>FZF_DEFAULT_OPTS</h3><p>该环境变量定义了 fzf 的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export FZF_DEFAULT_OPTS=&quot;--height 40% --layout=reverse --preview &#x27;(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&#x27;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="常见的一些操作"><a href="#常见的一些操作" class="headerlink" title="常见的一些操作"></a>常见的一些操作</h2><p>fzf 最最常用的快捷键应该就是 Ctrl + r 和 Ctrl + t 了。Ctrl-r 用来在历史中搜索，Ctrl-t 用来搜索当前文件夹下的内容。</p>
<h3 id="历史记录搜索"><a href="#历史记录搜索" class="headerlink" title="历史记录搜索"></a>历史记录搜索</h3><p>在没有使用 fzf 之前都是 Ctrl + r 来快速输入历史命令，用起来倒也没有太大的问题，fzf 使得 Ctrl-r 变得更加好用，按下 Ctrl-r 之后立即就能够显示之前的历史命令，通过模糊搜索能够展示一个列表，从列表中选择即可。</p>
<h3 id="历史命令-Ctrl-r"><a href="#历史命令-Ctrl-r" class="headerlink" title="历史命令 Ctrl-r"></a>历史命令 Ctrl-r</h3><p>在终端命令行下按下 Ctrl-r 会列出 history 命令目录，选中 Enter 离开 fzf 后，该条目会拷贝到命令行中。</p>
<h3 id="搜索当前文件夹-Ctrl-t"><a href="#搜索当前文件夹-Ctrl-t" class="headerlink" title="搜索当前文件夹 Ctrl-t"></a>搜索当前文件夹 Ctrl-t</h3><p>在命令行中按下 Ctrl-t 会打开 fzf 窗口，此时如果找到某文件，并选择 Enter，那么该文件名会被拷贝到命令行中。比如说想要打开某文件但是忘记了名字，那么可以先输入 <code>vi</code>然后按下 Ctrl-t 那么会出现 fzf 的搜索窗口，在窗口中可以模糊搜索文件，然后将文件路径及文件拷贝到命令行中。</p>
<p>同样的方式，如果要 <code>mv</code> 一个文件，同样先输入 <code>mv</code>然后再 Ctrl-t 找到文件，继续输入目的地址即可。</p>
<p>如果想要更简单 fzf GitHub wiki 中展示了非常多的 Bash Shell 的配置 <a href="https://einverne.github.io/post/2019/08/fzf-usage.html#fn:wiki">1</a>，比如可以定义命令 <code>fe</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fe() &#123;</span><br><span class="line">  local files</span><br><span class="line">  IFS=$&#x27;\n&#x27; files=($(fzf-tmux --query=&quot;$1&quot; --multi --select-1 --exit-0))</span><br><span class="line">  [[ -n &quot;$files&quot; ]] &amp;&amp; $&#123;EDITOR:-vim&#125; &quot;$&#123;files[@]&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在 shell 中直接输入 <code>fe</code> 然后回车会自动出现当前目录的 fzf，选择文件之后回车即可用默认 <code>$EDITOR</code> 打开文件。</p>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><p>假如在 fzf 选择窗口中想要选择多个文件，那么可以使用 <code>tab</code> 来进行多选，使用 Ctrl-n, Ctrl-p 上下切换的时候，可以使用 Tab 来选中期望的文件进行多选操作。</p>
<p>比如移动，删除，或者编辑多个文件时可以使用。</p>
<h3 id="更改路径"><a href="#更改路径" class="headerlink" title="更改路径"></a>更改路径</h3><p>在 fzf 之前最原始的方法就是 cd 然后输入一个词，不断的按 Tab 直到完整的输入 Path，回车。但假如 path 比较长，那么可能需要费一些时间找到真正想要去的目录，而如果用 fzf 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd() &#123;</span><br><span class="line">  local dir</span><br><span class="line">  dir=$(find $&#123;1:-.&#125; -path &#x27;*/\.*&#x27; -prune \</span><br><span class="line">				  -o -type d -print 2&gt; /dev/null | fzf +m) &amp;&amp;</span><br><span class="line">  cd &quot;$dir&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在终端输入 <code>fd</code> 然后搜索一下目录回车就能直接到该目录下，效率提升 x 倍。</p>
<h3 id="Kill-Process"><a href="#Kill-Process" class="headerlink" title="Kill Process"></a>Kill Process</h3><p>再比如说 <code>fkill</code> 用来 kill process</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fkill - kill process</span><br><span class="line">fkill() &#123;</span><br><span class="line">  local pid</span><br><span class="line">  pid=$(ps -ef | sed 1d | fzf -m | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">  if [ &quot;x$pid&quot; != &quot;x&quot; ]</span><br><span class="line">  then</span><br><span class="line">	echo $pid | xargs kill -$&#123;1:-9&#125;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h3><p>再比如创建 Tmux session 一般都是 <code>tmux new -s new-session</code> 创建，如果使用 <a href="https://github.com/tmuxinator/tmuxinator">tmuxinator</a> 则可能 <code>mux name</code> 比较快，但是如果在 fzf 这里只需要 <code>tm new-session</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tm - create new tmux session, or switch to existing one. Works from within tmux too. (@bag-man)</span><br><span class="line"># `tm` will allow you to select your tmux session via fzf.</span><br><span class="line"># `tm irc` will attach to the irc session (if it exists), else it will create it.</span><br><span class="line"></span><br><span class="line">tm() &#123;</span><br><span class="line">  [[ -n &quot;$TMUX&quot; ]] &amp;&amp; change=&quot;switch-client&quot; || change=&quot;attach-session&quot;</span><br><span class="line">  if [ $1 ]; then</span><br><span class="line">	tmux $change -t &quot;$1&quot; 2&gt;/dev/null || (tmux new-session -d -s $1 &amp;&amp; tmux $change -t &quot;$1&quot;); return</span><br><span class="line">  fi</span><br><span class="line">  session=$(tmux list-sessions -F &quot;#&#123;session_name&#125;&quot; 2&gt;/dev/null | fzf --exit-0) &amp;&amp;  tmux $change -t &quot;$session&quot; || echo &quot;No sessions found.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 session 不存在则会自动创建，使用 fs 可以快速选择目前可用的 session.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fs [FUZZY PATTERN] - Select selected tmux session</span><br><span class="line">#   - Bypass fuzzy finder if there&#x27;s only one match (--select-1)</span><br><span class="line">#   - Exit if there&#x27;s no match (--exit-0)</span><br><span class="line">fs() &#123;</span><br><span class="line">  local session</span><br><span class="line">  session=$(tmux list-sessions -F &quot;#&#123;session_name&#125;&quot; | \</span><br><span class="line">    fzf --query=&quot;$1&quot; --select-1 --exit-0) &amp;&amp;</span><br><span class="line">  tmux switch-client -t &quot;$session&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Alt-c"><a href="#Alt-c" class="headerlink" title="Alt-c"></a>Alt-c</h3><p>命令行中按下 Alt-c，会列出当前文件夹下的目录，选择后会直接进入该文件夹。</p>
<h2 id="搜索语法"><a href="#搜索语法" class="headerlink" title="搜索语法"></a>搜索语法</h2><p>在上面一系列的基础操作后，对 fzf 应该有了一定的了解，那么知道 fzf 的搜索语法其实非常强大，在熟悉正则的基础上，用 fzf 搜索语法可以实现很多的组合，比如使用 <code>!</code> 来表示不包含，比如 <code>!word</code> 不包含 <code>word</code> 的结果。</p>
<p>比如：</p>
<ul>
<li><code>^music</code> 以 music 开头</li>
<li><code>mp3$</code> 以 mp3 结尾</li>
<li><code>&#39;word</code> 严格匹配</li>
<li><code>!word</code> 不包含 word</li>
<li><code>!.mp3$</code> 不以 <code>.mp3</code> 结尾</li>
</ul>
<p>等等，可以在官方网站上看到。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>一些比较高效的搜索工具</p>
<ul>
<li>find 目录搜索</li>
<li>fd 目录搜索</li>
<li>grep 文本内容搜索</li>
<li><a href="https://github.com/ggreer/the_silver_searcher">ag</a> 文本内容搜索</li>
<li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> 文本内容搜索</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://revelry.co/terminal-workflow-fzf/">https://revelry.co/terminal-workflow-fzf/</a></li>
</ul>
<ol>
<li><a href="https://github.com/junegunn/fzf/wiki/examples">https://github.com/junegunn/fzf/wiki/examples</a> <a href="https://einverne.github.io/post/2019/08/fzf-usage.html#fnref:wiki">↩</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux tools</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 命令大全</title>
    <url>/2022/10/27/2022-10-27-linuxTools%E6%89%8B%E5%86%8C%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="命令行的艺术"><a href="#命令行的艺术" class="headerlink" title="命令行的艺术"></a>命令行的艺术</h1><p><a href="https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/jlevy/the-art-of-command-line"></a></p>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#基础">基础</a></li>
<li><a href="#日常使用">日常使用</a></li>
<li><a href="#文件及数据处理">文件及数据处理</a></li>
<li><a href="#系统调试">系统调试</a></li>
<li><a href="#单行脚本">单行脚本</a></li>
<li><a href="#冷门但有用">冷门但有用</a></li>
<li><a href="#仅限-os-x-系统">仅限 OS X 系统</a></li>
<li><a href="#仅限-windows-系统">仅限 Windows 系统</a></li>
<li><a href="#更多资源">更多资源</a></li>
<li><a href="#免责声明">免责声明</a></li>
</ul>
<p><img src="cowsay.png" alt="curl -s &#39;https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md&#39; | egrep -o &#39;`\w+`&#39; | tr -d &#39;`&#39; | cowsay -W50"></p>
<p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p>
<p>这篇文章是<a href="AUTHORS.md">许多作者和译者</a>共同的成果。<br>这里的部分内容<br><a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">首次</a><br><a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">出现</a><br>于 <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>，<br>但已经迁移到了 Github，并由众多高手做出了许多改进。<br>如果你在本文中发现了错误或者存在可以改善的地方，请<a href="/CONTRIBUTING.md"><strong>贡献你的一份力量</strong></a>。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>涵盖范围：</p>
<ul>
<li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li>
<li>本文主要为 Linux 所写，但在<a href="#仅限-os-x-系统">仅限 OS X 系统</a>章节和<a href="#仅限-windows-系统">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li>
<li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li>
<li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br><code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li>
<li>遇到问题的话，请尝试使用 <a href="http://explainshell.com/">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p>
</li>
<li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p>
</li>
<li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p>
</li>
<li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p>
</li>
<li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别（后文中有一些具体的例子）。</p>
</li>
<li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p>
</li>
<li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p>
</li>
<li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p>
</li>
<li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p>
</li>
<li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p>
</li>
<li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p>
</li>
<li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p>
</li>
</ul>
<h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><ul>
<li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p>
</li>
<li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-*</strong> 可以展开通配符。</p>
</li>
</ul>
<ul>
<li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p>
</li>
<li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p>
</li>
<li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p>
</li>
<li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>~</code>（例如 <code>~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p>
</li>
<li><p>回到前一个工作路径：<code>cd -</code>。</p>
</li>
<li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p>
</li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I&#123;&#125;</code> 会很方便。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&#x27;*.py&#x27;</span> | xargs grep some_function</span><br><span class="line"><span class="built_in">cat</span> hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p>
</li>
<li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p>
</li>
<li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p>
</li>
<li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p>
</li>
<li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p>
</li>
<li><p><code>lsof</code> 来查看开启的套接字和文件。</p>
</li>
<li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p>
</li>
<li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 创建了一个新的命令别名 <code>ll</code>。</p>
</li>
<li><p>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href="http://superuser.com/a/183980/7106">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p>
</li>
<li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p>
</li>
<li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p>
</li>
<li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>&quot;$FOO&quot;</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$&#39;\n&#39;</code> 把内部字段分隔符设为换行符。</p>
</li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;error: Script failed: see failed command above&#x27;&quot;</span> ERR</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 中，变量有许多的扩展方式。<code>$&#123;name:?error message&#125;</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=$&#123;1:?usage: $0 input_file&#125;</code>。在变量为空时使用默认值：<code>$&#123;name:-default&#125;</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=$&#123;2:-logfile&#125;</code>，如果省略了 $2，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>&#123;1..10&#125;</code>。截断字符串：<code>$&#123;var%suffix&#125;</code> 和 <code>$&#123;var#prefix&#125;</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo $&#123;var%.pdf&#125;.txt</code> 将输出 <code>foo.txt</code>。</p>
</li>
<li><p>使用括号扩展（<code>&#123;</code>…<code>&#125;</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.&#123;txt,pdf&#125; some-dir</code>（同时移动两个文件），<code>cp somefile&#123;,.bak&#125;</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-&#123;a,b,c&#125;/subtest-&#123;1,2,3&#125;</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>
</li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost <span class="built_in">cat</span> /etc/hosts)</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="comment"># 在这里写代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>
</li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>
</li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>
</li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href="https://github.com/bogner/dtach"><code>dtach</code></a>。</p>
</li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p>
</li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCPKeepAlive=yes</span><br><span class="line">ServerAliveInterval=15</span><br><span class="line">ServerAliveCountMax=6</span><br><span class="line">Compression=yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br><span class="line">ControlPersist yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p>
</li>
<li><p>考虑使用 <a href="https://mosh.mit.edu/"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p>
</li>
<li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">&#x27;%A %a %n&#x27;</span> /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/mooz/percol"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>
</li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>
</li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>
</li>
<li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入<em>你自己的</em>密码）。</p>
</li>
<li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>su - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入<em>哪个用户的</em>密码。</p>
</li>
<li><p>了解命令行的 <a href="https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p>
</li>
<li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2+3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文件及数据处理"><a href="#文件及数据处理" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul>
<li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname &#39;*something*&#39;</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p>
</li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p>
</li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p>
</li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/"><code>pandoc</code></a>。</p>
</li>
<li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p>
</li>
<li><p>使用 <a href="http://stedolan.github.io/jq/"><code>jq</code></a> 处理 JSON。</p>
</li>
<li><p>使用 <a href="https://github.com/0k/shyaml"><code>shyaml</code></a> 处理 YAML。</p>
</li>
<li><p>要处理 Excel 或 CSV 文件的话，<a href="https://github.com/onyxfish/csvkit">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p>
</li>
<li><p>当你要处理 Amazon S3 相关的工作的时候，<a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> 是一个很方便的工具而 <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href="https://github.com/aws/aws-cli"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p>
</li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p>
</li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p>
</li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>
</li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>
</li>
<li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href="https://www.gnu.org/software/datamash/"><code>datamash</code></a>。</p>
</li>
<li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p>
</li>
<li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p>
</li>
<li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href="#one-liners">One-liners</a> 获取示例。</p>
</li>
<li><p>替换一个或多个文件中出现的字符串：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">perl -pi.bak -e <span class="string">&#x27;s/old-string/new-string/g&#x27;</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/jlevy/repren"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件、目录和内容全部重命名 foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># 还原所有备份文件 whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">&#x27;(.*)\.bak&#x27;</span> --to <span class="string">&#x27;\1&#x27;</span> *.bak</span><br><span class="line"><span class="comment"># 用 rename 实现上述功能（若可用）:</span></span><br><span class="line">rename <span class="string">&#x27;s/\.bak$//&#x27;</span> *.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html">最快方法</a>之一：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; <span class="built_in">rmdir</span> some-dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href="https://github.com/dmerejkowsky/pycp"><code>pycp</code></a>，<a href="https://github.com/Xfennec/progress"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p>
</li>
<li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p>
</li>
<li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>
</li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>
</li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p>
</li>
<li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p>
</li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p>
</li>
<li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p>
</li>
<li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uconv -f utf-8 -t utf-8 -x <span class="string">&#x27;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#x27;</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>
</li>
<li><p>操作日期和时间表达式，可以用 <a href="http://www.fresse.org/dateutils/"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p>
</li>
<li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>
</li>
<li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p>
</li>
<li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getfacl -R /some/path &gt; permissions.txt</span><br><span class="line">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href="https://zh.wikipedia.org/wiki/稀疏文件">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</p>
</li>
</ul>
<h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href="https://github.com/jkbrzt/httpie"><code>httpie</code></a>。</p>
</li>
<li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p>
</li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>
</li>
<li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p>
</li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p>
</li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools">SJK tools</a> 更高级。</p>
</li>
<li><p>使用 <a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p>
</li>
<li><p>用 <a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p>
</li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>。</p>
</li>
<li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>
</li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a>，<a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a> 和 <a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a> 可用于复杂的网络调试。</p>
</li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>
</li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href="http://www.catonmat.net/blog/ldd-arbitrary-code-execution/">永远不要在不信任的文件上运行</a>。</p>
</li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>
</li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>
</li>
<li><p>当调试一些之前出现的问题的时候，<a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>
</li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>），<a href="https://en.wikipedia.org/wiki/Perf_(Linux"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig"><code>sysdig</code></a>。</p>
</li>
<li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p>
</li>
<li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p>
</li>
<li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br><code>lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;</code></p>
</li>
</ul>
<h2 id="单行脚本"><a href="#单行脚本" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p>
<ul>
<li><p>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> a b | <span class="built_in">uniq</span> &gt; c   <span class="comment"># c 是 a 并 b</span></span><br><span class="line"><span class="built_in">sort</span> a b | <span class="built_in">uniq</span> -d &gt; c   <span class="comment"># c 是 a 交 b</span></span><br><span class="line"><span class="built_in">sort</span> a b b | <span class="built_in">uniq</span> -u &gt; c   <span class="comment"># c 是 a - b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>
</li>
</ul>
<ul>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27;</span> myfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">egrep -o <span class="string">&#x27;acct_id=[0-9]+&#x27;</span> access.log | <span class="built_in">cut</span> -d= -f2 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn</span><br></pre></td></tr></table></figure>
</li>
<li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 &#39;ls -rtlh | tail&#39;</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p>
</li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class="line">    pandoc -f markdown -t html |</span><br><span class="line">    iconv -f <span class="string">&#x27;utf-8&#x27;</span> -t <span class="string">&#x27;unicode&#x27;</span> |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">&quot;(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]&quot;</span> |</span><br><span class="line">    xmlstarlet unesc | <span class="built_in">fmt</span> -80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="冷门但有用"><a href="#冷门但有用" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p>
</li>
<li><p><code>m4</code>：简单的宏处理器</p>
</li>
<li><p><code>yes</code>：多次打印字符串</p>
</li>
<li><p><code>cal</code>：漂亮的日历</p>
</li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>
</li>
<li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p>
</li>
<li><p><code>look</code>：查找以特定字符串开头的单词或行</p>
</li>
<li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p>
</li>
<li><p><code>fmt</code>：格式化文本段落</p>
</li>
<li><p><code>pr</code>：将文本格式化成页／列形式</p>
</li>
<li><p><code>fold</code>：包裹文本中的几行</p>
</li>
<li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p>
</li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>
</li>
<li><p><code>nl</code>：添加行号</p>
</li>
<li><p><code>seq</code>：打印数字</p>
</li>
<li><p><code>bc</code>：计算器</p>
</li>
<li><p><code>factor</code>：分解因数</p>
</li>
<li><p><a href="https://gnupg.org/"><code>gpg</code></a>：加密并签名文件</p>
</li>
<li><p><code>toe</code>：terminfo 入口列表</p>
</li>
<li><p><code>nc</code>：网络调试及数据传输</p>
</li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>
</li>
<li><p><a href="https://github.com/mattthias/slurm"><code>slurm</code></a>：网络流量可视化</p>
</li>
<li><p><code>dd</code>：文件或设备间传输数据</p>
</li>
<li><p><code>file</code>：确定文件类型</p>
</li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>
</li>
<li><p><code>stat</code>：文件信息</p>
</li>
<li><p><code>time</code>：执行命令，并计算执行时间</p>
</li>
<li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p>
</li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>
</li>
<li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p>
</li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p>
</li>
<li><p><a href="https://github.com/joh/when-changed"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p>
</li>
<li><p><code>tac</code>：反向输出文件</p>
</li>
<li><p><code>shuf</code>：文件中随机选取几行</p>
</li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p>
</li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p>
</li>
<li><p><code>tr</code>：转换字母</p>
</li>
<li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p>
</li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>
</li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>
</li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>
</li>
<li><p><code>apg</code>：随机生成密码</p>
</li>
<li><p><code>xz</code>：高比例的文件压缩</p>
</li>
<li><p><code>ldd</code>：动态库信息</p>
</li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p>
</li>
<li><p><code>ab</code> 或 <a href="https://github.com/wg/wrk"><code>wrk</code></a>：web 服务器性能分析</p>
</li>
<li><p><code>strace</code>：调试系统调用</p>
</li>
<li><p><a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a>：更好的网络调试跟踪工具</p>
</li>
<li><p><code>cssh</code>：可视化的并发 shell</p>
</li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>
</li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a> 和 <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>：抓包和网络调试工具</p>
</li>
<li><p><a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>：网络层的 grep</p>
</li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>
</li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>
</li>
<li><p><code>dstat</code>：系统状态查看</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>：高层次的多子系统总览</p>
</li>
<li><p><code>iostat</code>：硬盘使用状态</p>
</li>
<li><p><code>mpstat</code>： CPU 使用状态</p>
</li>
<li><p><code>vmstat</code>： 内存使用状态</p>
</li>
<li><p><code>htop</code>：top 的加强版</p>
</li>
<li><p><code>last</code>：登入记录</p>
</li>
<li><p><code>w</code>：查看处于登录状态的用户</p>
</li>
<li><p><code>id</code>：用户/组 ID 信息</p>
</li>
<li><p><a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a>：系统历史数据</p>
</li>
<li><p><a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>：套接字及进程的网络利用情况</p>
</li>
<li><p><code>ss</code>：套接字数据</p>
</li>
<li><p><code>dmesg</code>：引导及系统错误信息</p>
</li>
<li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p>
</li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>
</li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>
</li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>
</li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>
</li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>
</li>
</ul>
<h2 id="仅限-OS-X-系统"><a href="#仅限-OS-X-系统" class="headerlink" title="仅限 OS X 系统"></a>仅限 OS X 系统</h2><p>以下是<em>仅限于</em> OS X 系统的技巧。</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p>
</li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>
</li>
<li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>
</li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>
</li>
<li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>
</li>
<li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>
</li>
<li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p>
</li>
</ul>
<h2 id="仅限-Windows-系统"><a href="#仅限-Windows-系统" class="headerlink" title="仅限 Windows 系统"></a>仅限 Windows 系统</h2><p>以下是<em>仅限于</em> Windows 系统的技巧。</p>
<h3 id="在-Winodws-下获取-Unix-工具"><a href="#在-Winodws-下获取-Unix-工具" class="headerlink" title="在 Winodws 下获取 Unix 工具"></a>在 Winodws 下获取 Unix 工具</h3><ul>
<li><p>可以安装 <a href="https://cygwin.com/">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p>
</li>
<li><p>在 Windows 10 上，你可以使用 <a href="https://msdn.microsoft.com/commandline/wsl/about">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p>
</li>
<li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p>
</li>
<li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href="https://github.com/dthree/cash">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p>
</li>
</ul>
<h3 id="实用-Windows-命令行工具"><a href="#实用-Windows-命令行工具" class="headerlink" title="实用 Windows 命令行工具"></a>实用 Windows 命令行工具</h3><ul>
<li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p>
</li>
<li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p>
</li>
<li><p>可以使用 <code>Rundll32</code> 命令来实现<a href="http://www.thewindowsclub.com/rundll32-shortcut-commands-windows">许多有用的 Windows 任务</a> 。</p>
</li>
</ul>
<h3 id="Cygwin-技巧"><a href="#Cygwin-技巧" class="headerlink" title="Cygwin 技巧"></a>Cygwin 技巧</h3><ul>
<li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p>
</li>
<li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p>
</li>
<li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p>
</li>
<li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p>
</li>
<li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p>
</li>
<li><p>注意 Windows 驱动器路径 <code>C:\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p>
</li>
<li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p>
</li>
<li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href="https://github.com/dthree/cash">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p>
</li>
<li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p>
</li>
</ul>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
<li><a href="http://datascienceatthecommandline.com/#tools">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li>
</ul>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p>
<h2 id="授权条款"><a href="#授权条款" class="headerlink" title="授权条款"></a>授权条款</h2><p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>本文使用授权协议 <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>
]]></content>
      <tags>
        <tag>linux tools</tag>
      </tags>
  </entry>
</search>
